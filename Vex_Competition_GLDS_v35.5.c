#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    forkPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, in3,    LineL,          sensorLineFollower)
#pragma config(Sensor, in4,    LineM,          sensorLineFollower)
#pragma config(Sensor, in5,    LineR,          sensorLineFollower)
#pragma config(Sensor, in6,    LineB,          sensorLineFollower)
#pragma config(Sensor, in7,    nPowerex,       sensorAnalog)
#pragma config(Sensor, in8,    armPotentiometerL, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  GOR,            sensorTouch)
#pragma config(Sensor, dgtl2,  solDump,        sensorDigitalOut)
#pragma config(Sensor, dgtl3,  solShift,       sensorDigitalOut)
#pragma config(Sensor, dgtl4,  fork2,          sensorDigitalOut)
#pragma config(Sensor, dgtl5,  fork1,          sensorDigitalOut)
#pragma config(Sensor, dgtl6,  solBig,         sensorDigitalOut)
#pragma config(Sensor, dgtl7,  solBreak,       sensorDigitalOut)
#pragma config(Sensor, dgtl8,  solLock,        sensorDigitalOut)
#pragma config(Sensor, dgtl9,  pWarning,       sensorLEDtoVCC)
#pragma config(Sensor, dgtl10, wall,           sensorTouch)
#pragma config(Sensor, dgtl11, prgenc,         sensorRotation)
#pragma config(Sensor, dgtl12, GOL,            sensorTouch)
#pragma config(Sensor, I2C_1,  rightIEM,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  leftIEM,        sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           frontRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           backRight,     tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port4,           roller,        tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           armmotL,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           fork,          tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           armmotR,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           backLeft,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port9,           frontLeft,     tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#define LCD_left nLCDButtons==0x01
#define LCD_mid nLCDButtons==0x02
#define LCD_right nLCDButtons==0x04
#define eyeL (SensorValue[LineL]<threshold)
#define eyeM (SensorValue[LineM]<threshold)
#define eyeR (SensorValue[LineR]<threshold)
#define eyeB (SensorValue[LineB]<threshold)
#define t0 99999
#define t1 523
#define t2 587
#define t3 659
#define t4 698
#define t5 783
#define t6 880
#define t7 987
#define t8 1046
#define t15 830

#include "Vex_Competition_Includes.c"//Main competition background code...do not modify!
//#include "Dennis++_v1.0.h"


//autonumos options




void GoRH1();
void GoRH2();
void GoRH3();
void GoRH4();
void GoRH5();
void GoRH_Hang();

void GoRM1();
void GoRM2();
void GoRM3();
void GoRM4();

void GoBH1();
void GoBH2();
void GoBH3();
void GoBH4();
void GoBH5();
void GoBH_Hang();


void GoBM1();
void GoBM2();
void GoBM3();
void GoBM4();


void GoDrive();
void GoSkill();
void GoFeed();
void GoEatR();
void GoEatB();

void GoSkillRisk();

//calibration mothods
void gyrocali();
void forkpotcali();
void encodercali();

//maneuver mothods
void drift(int power, int howfar);
void forward(int power,int howfar);
void forwardNS(int power, int howfar);
void backward(int power,int howfar);
void backwardNS(int power,int howfar);
void turn(int power ,float angle);
void turnPCS90(int power,float angle);
void turnPCS45(int power,float angle);
void turnIEC(int power,int degrees);

//breaking mothods
void breakDrive();
void breakDrivet();
void breakDrivesideL();
void breakDrivesideR();

//line tracking mothods
void turnthenfollow(int power,int howfar,int approx);
int forwardLine(int power,int howfar,int lastinput);

void securedDump();
void autohang();

//servace/background tasks
task raiseOrLowerArm();
task masterreset();
task autoslection();
task shift();
task raiseOrLowerFork();
task openFork();
task visualMem();


//global variable delarations
int threshold=1600,lfc=0;
int gyrocorrection=0,joystick,joystickf,StartingTile,encoderL,encoderR,gyroref,kMaxPos = 3000,linethreshold=2400;
bool fire=false,liftDa=false,hangmode=false,skipcali=false,openup=false,lockarm=false,prehangmode=false;
bool eyeLm=false,eyeMm=false,eyeRm=false,eyeBm=false,memEn=false;//eye memory section;
bool LowV=false,LowP=false
bool lastwasHang=false;
float ki=0.0001,kd=0.40,kp=0.48;//arm PID consts
float kdf=0,kpf=0.17,kif=0;//fork PID consts
float kil=0.00,kdl=0,kpl=4;// Line following PID consts
int kMaxPosf = 1500;
int nPositionToHold;
int nPositionToHoldf;
int kMotorSpeedUp   = +127;
int battStd;
int inputl;
int fpc=0;
string mBattery,eBattery,fkpt;


void pre_auton()
{
	SensorValue[solShift]=0;
	clearLCDLine(0);
	clearLCDLine(1);// Set bstopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	SensorType[in2] = sensorNone;
	SensorType[in8] = sensorNone;
	wait1Msec(1000);
	//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
	SensorType[in2] = sensorGyro;
	SensorType[in8] = sensorPotentiometer;
	battStd=nAvgBatteryLevel;

	wait1Msec(400);
	SensorValue[gyro]=0;
	SensorValue[solDump]=1;
	bStopTasksBetweenModes = true;
	bLCDBacklight = true;
	StartingTile=8;
	startTask(masterreset);
	startTask(autoslection);
	lastwasHang=false;
	//	startTask(tune);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task

task autoslection()
{

	wait1Msec(10);
	while(1){
		while(nLCDButtons!=kButtonLeft)
		{
			//clearLCDLine(1);
			sprintf(mBattery, "%1.2f%c", nAvgBatteryLevel/1000.0);
			sprintf(eBattery, " %1.2f%c", (SensorValue[nPowerex]/284.0));
			sprintf(fkpt, " %4.0f%c ", (SensorValue[forkPot]));

			displayLCDString(1,0,mBattery);
			displayLCDString(1,5,eBattery);

			//	displayLCDString(1,11,fkpt);

			if(hangmode)
				displayLCDString(1,10,"hang");
			else
				displayLCDString(1,10,"normal");

			if(LCD_mid)
			{
				while(LCD_mid);
				forkpotcali();

			}
			if(LCD_right)
			{
				while(LCD_right);

				encodercali();
			}
			wait1Msec(1);
			clearLCDLine(0);
			switch (StartingTile){
			case 1:
				displayLCDPos(0,0); displayNextLCDString("Red Hanging 1");
				break;
			case 2:
				displayLCDPos(0,0); displayNextLCDString("Red Hanging 2");
				break;
			case 3:
				displayLCDPos(0,0); displayNextLCDString("Red Hanging 3");
				break;
			case 4:
				displayLCDPos(0,0); displayNextLCDString("Red Hanging 4");
				break;
			case 5:
				displayLCDPos(0,0); displayNextLCDString("Red Hanging 5");
				break;
			case 6:
				displayLCDPos(0,0); displayNextLCDString("Red Lowhang");
				break;
			case 7:
				displayLCDPos(0,0); displayNextLCDString("Red Middle 1");
				break;
			case 8:
				displayLCDPos(0,0); displayNextLCDString("Red Middle 2");
				break;
			case 9:
				displayLCDPos(0,0); displayNextLCDString("Red Middle 3");
				break;
			case 10:
				displayLCDPos(0,0); displayNextLCDString("Red Middle 4");
				break;
			case 11:
				displayLCDPos(0,0); displayNextLCDString("Blue Hanging 1");
				break;
			case 12:
				displayLCDPos(0,0); displayNextLCDString("Blue Hanging 2");
				break;
			case 13:
				displayLCDPos(0,0); displayNextLCDString("Blue Hanging 3");
				break;
			case 14:
				displayLCDPos(0,0); displayNextLCDString("Blue Hanging 4");
				break;
			case 15:
				displayLCDPos(0,0); displayNextLCDString("Blue Hanging 5");
				break;
			case 16:
				displayLCDPos(0,0); displayNextLCDString("Blue Lowhang");
				break;
			case 17:
				displayLCDPos(0,0); displayNextLCDString("Blue Middle 1");
				break;
			case 18:
				displayLCDPos(0,0); displayNextLCDString("Blue Middle 2");
				break;
			case 19:
				displayLCDPos(0,0); displayNextLCDString("Blue Middle 3");
				break;
			case 20:
				displayLCDPos(0,0); displayNextLCDString("Blue Middle 4");
				break;
			case 21:
				displayLCDPos(0,0); displayNextLCDString("Feed");
				break;
			case 22:
				displayLCDPos(0,0); displayNextLCDString("Red Eat");
				break;
			case 23:
				displayLCDPos(0,0); displayNextLCDString("Blue Eat");
				break;

			case 24:
				displayLCDPos(0,0); displayNextLCDString("Challenge");
				break;
			case 25:
				displayLCDPos(0,0); displayNextLCDString("Challenge Risk");
				break;

			}
		}
		StartingTile++;
		while(LCD_left){}
		wait1Msec(1);

		if(StartingTile>25)
			StartingTile=1;
		if(!bVEXNETActive){
			stopTask(main);
			wait1Msec(500);
			startTask(main);
		}

	}
}

task autonomous()
{
	//unfold
	liftDa=false;
	stopTask(usercontrol);
	stopTask(raiseOrLowerArm);
	//	startTask(shift);

	switch(StartingTile)
	{
	case 1:
		GoRH1();
		break;
	case 2:
		GoRH2();
		break;
	case 3:
		GoRH3();
		break;
	case 4:
		GoRH4();
		break;
	case 5:
		GoRH5();
		break;
	case 6:
		GoRH_Hang();
		break;
	case 7:
		GoRM1();
		break;
	case 8:
		GoRM2();
		break;
	case 9:
		GoRM3();
		break;
	case 10:
		GoRM4();
		break;
	case 11:
		GoBH1();
		break;
	case 12:
		GoBH2();
		break;
	case 13:
		GoBH3();
		break;
	case 14:
		GoBH4();
		break;
	case 15:
		GoBH5();
		break;
	case 16:
		GoBH_Hang();
		break;
	case 17:
		GoBM1();
		break;
	case 18:
		GoBM2();
		break;
	case 19:
		GoBM3();
		break;
	case 20:
		GoBM4();
		break;
	case 21:
		GoFeed();
		break;
	case 22:
		GoEatR();
		break;
	case 23:
		GoEatB();
		break;
	case 24:
		GoSkill();
		break;
	case 25:
		GoSkillRisk();
		break;
	default:
		break;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task


task flash()
{
	bool vg=true;
	int times=0;
	while(1)
	{
		if(!bVEXNETActive)
		{
			playTone(2000,5);
			wait1Msec(100);
		}
		if(LowV&LowP)
		{
			SensorValue[pWarning]=1;
			playTone(700,10);
			wait1Msec(150);
			SensorValue[pWarning]=0;
			wait1Msec(150);
			SensorValue[pWarning]=1;
			playTone(700,10);
			wait1Msec(150);
			SensorValue[pWarning]=0;
			wait1Msec(600);
		}
		else if(LowV)
		{
			SensorValue[pWarning]=!SensorValue[pWarning];
			playTone(1200,20);
			wait1Msec(250);
		}
		else if(LowP)
		{
			if(vg){
				vg=false;
				times=time1[T4];
			}

			SensorValue[pWarning]=!SensorValue[pWarning];
			if(time1[T4]-times<5000)
				playTone(700,10);
			wait1Msec(400);
		}
		else if(hangmode)
		{
			playTone(800,40);
			wait1Msec(300);
			playTone(600,40);
			wait1Msec(300);
			playTone(400,40);
			wait1Msec(300);
		}
		else if(prehangmode)
		{
			playTone(800,40);
			wait1Msec(300);
			playTone(400,40);
			wait1Msec(300);
		}

		else
		{}


	}
}

task pMonitor()
{

	int cBig=0,cDump=0,cFork=0,cBreak=0,cLock=0,cShift=0;
	float pLord;
	bool bBig,bDump,bFork,bBreak,bLock,bShift;
	const float pInit=100.0,pThresh=45.0;//psi
	const float kBig=1.0,kDump=0.8,kFork=0.5,kBreak=0.25,kLock=0.5,kShift=0.5;
	//          2 dbl    2 dbl     2 sgl       1 sgl       1 dbl      1 dbl
	//	bool tooLow=false;

	while(1)
	{
		bBig=(bool)SensorValue[solBig];
		bDump=(bool)SensorValue[solDump];
		bFork=(bool)SensorValue[fork1];
		bBreak=(bool)SensorValue[solBreak];
		bLock=(bool)SensorValue[solLock];
		bShift=(bool)SensorValue[solShift];
		pLord=(float) pInit - (kBig*cBig) - (kDump*cDump) - (kFork*cFork) - (kBreak*cBreak) - (kLock*cLock) - (kShift*cShift);
		if(pLord<pThresh)
			LowP=true;
		else
		{
			LowP=false;
			SensorValue[pWarning]=false;
		}

		wait1Msec(10);
		if(bBig!=(bool)SensorValue[solBig])//constracted or extended
			cBig++;
		if(bDump!=(bool)SensorValue[solDump])//constracted or extended
			cDump++;
		if(bLock!=(bool)SensorValue[solLock])//constracted or extended
			cLock++;
		if(bShift!=(bool)SensorValue[solShift])//constracted or extended
			cShift++;
		if(bBreak==false&SensorValue[solBreak]==true)//only extented count
			cBreak++;
		if(bFork==false&SensorValue[fork1]==true)//only extented count
			cFork++;
	}
}
task driveThisShit()
{
	const float Imax=7.0;
	const float Ri=0.08;//ohm s
	float current,Iratio,ctrRod=1.0;
	bool virgin=true,act=false;
	int powersav,poweravg,deltaS=0,lastpos=0;
	string inpt,time,speedd,currents,joystickk,powerrr;
	clearTimer(T4);
	nMotorEncoder[backLeft]=0;
	while(1)
	{
		int X2 = 0, Y1 = 0, threshold = 10;
		if(abs(vexRT[Ch3]) > threshold)
			Y1 = vexRT[Ch3];
		else
			Y1 = 0;
		if(abs(vexRT[Ch1]) > threshold)
			X2 = vexRT[Ch1];
		else
			X2 = 0;
		while(hangmode)
			motor[frontLeft] = 	motor[frontRight] = motor[backRight] =	motor[backLeft] =  -vexRT[Ch2];
		if(vexRT[Btn8DXmtr2])
		{
			motor[frontLeft] = (Y1 + X2 );
			motor[frontRight] = (Y1 - X2 );
			motor[backRight] = ( Y1 - X2 );
			motor[backLeft] = ( Y1 + X2 );
		}
		else{
			motor[frontLeft] = (float)ctrRod*(Y1 + X2 );
			motor[frontRight] = (float)ctrRod*(Y1 - X2 );
			motor[backRight] = (float)ctrRod*( Y1 - X2 );
			motor[backLeft] = (float)ctrRod*( Y1 + X2 );
		}
		current=(float)(battStd-nAvgBatteryLevel)/(1000.0*Ri);
		poweravg=(abs(Y1 + X2)+abs(Y1 - X2 ))/2;
		deltaS=nMotorEncoder[backLeft]-lastpos;
		lastpos=nMotorEncoder[backLeft];

		/*
		sprintf(speedd, " %4.0f%c", SensorValue[armPotentiometerL]);
		sprintf(time, " %5.0f%c", time1[T4]);
		sprintf(currents, " %2.3f%c", current);
		sprintf(powerrr, " %3.0f%c", motor[armmotL]);
		sprintf(joystickk, " %3.0f%c", joystick);
		writeDebugStream(time);
		writeDebugStream(currents);
		writeDebugStream(powerrr);
		writeDebugStream(joystickk);
		writeDebugStreamLine(speedd);*/
		if(ctrRod==1)
			LowV=false;
		else
			LowV=true;

		if(current>Imax & virgin)
		{
			virgin=false;
			clearTimer(T3);
			powersav=poweravg;
		}
		if(current>Imax & !virgin & time1[T3]>200 & abs(deltaS)<5 )//also consider delta pos
		{
			act=true;
		}
		if(act)
		{
			Iratio=(float)current/Imax;
			ctrRod=(float)(1/Iratio);
			if(current>Imax-3.5)
				ctrRod=(float)(ctrRod-0.04);
			else if(current<(Imax-3.5))
				ctrRod=(float)(ctrRod+0.04);
			if (ctrRod>1.5)
				ctrRod=1.5;
			else if (ctrRod<0.1)
				ctrRod=0.1;
			ctrRod=0.2;


		}
		if ((3*poweravg<=powersav & act)|abs(deltaS)>5)
		{
			act=false;
			virgin=true;
			ctrRod=1.0;
		}
		wait1Msec(40);
	}


}

task usercontrol()
{
	if(lastwasHang)
	{
		sensorValue[solLock]=false;
		SensorValue[solShift]=0;
		SensorValue[solBig]=1;
		motor[armmotL]=motor[armmotR]=70;
		motor[backLeft]=motor[frontRight]=motor[frontLeft]=motor[backLeft]=128;
		wait1Msec(80);
		motor[backLeft]=motor[frontRight]=motor[frontLeft]=motor[backLeft]=-128;
		wait1Msec(80);
		motor[backLeft]=motor[frontRight]=motor[frontLeft]=motor[backLeft]=128;
		wait1Msec(80);
		motor[backLeft]=motor[frontRight]=motor[frontLeft]=motor[backLeft]=-128;
		wait1Msec(80);
		motor[backLeft]=motor[frontRight]=motor[frontLeft]=motor[backLeft]=0;
		motor[armmotL]=motor[armmotR]=0;
		while(!vexRT[Btn7D])
		{
			motor[armmotL]=motor[armmotR]=vexRT[Ch2];
			motor[backLeft]=motor[frontRight]=vexRT[Ch3]-vexRT[Ch1];
			motor[frontLeft]=motor[backLeft]=vexRT[Ch3]+vexRT[Ch1];
		}
		//	SensorValue[solShift]=0;
		//	prehangmode=true;
		//	hangmode=false;
		SensorValue[solBig]=0;

	}


	bool forkopen=false;
	kMaxPos = 3070;

	SensorValue[solBig] = 0;
	startTask(raiseOrLowerArm);
	startTask(raiseOrLowerFork);
	startTask(autoslection);
	startTask(shift);
	startTask(openFork);
	startTask(masterreset);
	startTask(driveThisShit);
	startTask(pMonitor);
	startTask(flash);

	//	startTask(tune);
	while(true) //Loop forever
	{
		kMaxPosf = 2350+fpc;
		joystick=vexRT[Ch2];

		if(vexRT[Btn8L])//action
		{
			while(vexRT[Btn8L]){}
			forkopen=!forkopen;
			if(forkopen)
				openup=true;
			else
				openup=false;
		}

		if(vexRT[Btn6U])
			joystickf = 128;
		else if(vexRT[Btn6D])
			joystickf = -128;
		else
			joystickf = 0;
		if(vexRT[Btn5U] == 1)
			motor[roller] = 127;
		else if(vexRT[Btn5D] == 1)
			motor[roller] = -127;
		else
			motor[roller] = 0;
		/*	if(vexRT[Btn7R]==1)
		{
		while(vexRT[Btn7R]==1){}
		GoDrive();
		}*/
		/*	if(vexRT[Btn8DXmtr2]==1)
		kMaxPos=2400;
		else
		kMaxPos=2845;*/

		//	else if(vexRT[Btn7D])
		if(vexRT[Btn7L])
			SensorValue[solDump]=1;
		else if(vexRT[Btn7R])
			SensorValue[solDump]=0;
		if(SensorValue[armPotentiometerL]<=1500&!hangmode)
		{
			liftDa=true;
			if(joystick<=-70)
				motor[armmotL]=motor[armmotR]=joystick/4;
			else if(joystick>=100)
				motor[armmotL]=motor[armmotR]=joystick;
			else if(SensorValue[armPotentiometerL]>1400)
				motor[armmotL]=motor[armmotR]=-24;
			else if(SensorValue[armPotentiometerL]<1430)
				motor[armmotL]=motor[armmotR]=-8;
		}
		else if(SensorValue[armPotentiometerL]>=1500&!hangmode)
		{
			liftDa=false;
		}
		if(hangmode)
			motor[armmotL]=motor[armmotR]=vexRT[Ch2];
	}
}



void GoSkill()
{
	SensorValue[solShift]=0;
	joystick=0;
	kMaxPos=3100;
	kMaxPosf = 1150+fpc;
	bool scan;
	startTask(raiseOrLowerArm);
	startTask(raiseOrLowerFork);
	startTask(openFork);
	startTask(visualMem);
	liftDa=false;
	SensorValue[solDump]=0;
	kMaxPos=1700;
	joystick=128;
	wait1Msec(200);
	joystick=-128;
	//initialize

	motor[roller]=127;
	forward(127,300);
	joystickf=128;
	joystick=0;
	forward(90,250);
	wait1Msec(700);
	//intake buckyballs

	joystickf=0;
	stopTask(raiseOrLowerFork);
	liftDa=true;
	motor[armmotL]=motor[armmotR]=-15;
	backward(128,500);
	motor[roller]=50;
	backward(128,900);
	motor[armmotL]=motor[armmotR]=0;
	turn(128,-160);
	motor[roller]=20;
	//reposition, wait for button push


	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	forward(128,300);
	forward(128,940);
	liftDa=false;
	motor[roller]=80;
	forward(128,230);
	//	kMaxPosf=1200;
	//	joystickf=0;
	kMaxPos=3000;

	joystick=128;
	//	stopTask(raiseOrLowerFork);
	//	motor[fork]=-55;
	forward(70,160);
	//	breakDrive();
	while(SensorValue[armPotentiometerL]<2800);
	forward(80,400);
	joystick=-128;
	wait1Msec(50);
	motor[fork]=-15;
	joystick=128;
	//	joystickf=0;
	//breakDrive();

	motor[roller]=-128;
	//	SensorValue[solDump]=1;

	//dump buckyballs


	wait1Msec(1200);
	while(!SensorValue[GOL])
	{
		motor[backLeft]=motor[frontLeft]=128;
		motor[backRight]=motor[frontRight]=128;
	}
	if(SensorValue[GOL])
		motor[backLeft]=motor[frontLeft]=-80;
	else
		motor[backLeft]=motor[frontLeft]=0;
	motor[backRight]=motor[frontRight]=128;


	//align with wall

	while(!SensorValue[wall])
	{
		if(SensorValue[GOL])
			motor[backLeft]=motor[frontLeft]=-80;
		else
			motor[backLeft]=motor[frontLeft]=0;
	}
	if(!SensorValue[GOL])
	{
		motor[backRight]=motor[frontRight]=10;
		motor[backLeft]=motor[frontLeft]=90;
	}
	while(!(SensorValue[wall]&SensorValue[GOL]));
	motor[backLeft]=motor[frontLeft]=motor[backRight]=motor[frontRight]=30;//turnc
	wait1Msec(100);
	motor[backLeft]=motor[frontLeft]=motor[backRight]=motor[frontRight]=0;//turnc
	motor[roller]=0;
	//	eyeBm=false;
	//	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	backward(128,350);
	joystick=-128;
	backward(128,250);



	while(SensorValue[armPotentiometerL]>1400);
	wait1Msec(250);

	SensorValue[solDump]=0;
	//	kMaxPosf=1200;
	//joystickf=128;
	backward(128,250);
	joystick=0;
	backward(128,650);

	stopTask(raiseOrLowerArm);
	motor[armmotL]=motor[armmotR]=-5;
	//	joystickf=128;

	//joystickf=0;
	//	forward(128,350);
	//nPositionToHoldf=1200;


	startTask(raiseOrLowerFork);
	backward(128,1300);
	joystickf=-128;
	while(SensorValue[forkPot]>450+fpc){
		motor[backLeft]=motor[backRight]=70;
		motor[frontLeft]=motor[frontRight]=70;
	}
	openup=true;
	wait1Msec(300);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	joystickf=0;

	//SensorValue[fork1]=SensorValue[fork2]=true;
	backward(128,750);

	kMaxPosf=2500+fpc;
	joystickf=128;

	//pick up big ball

	startTask(raiseOrLowerArm);
	kMaxPos=2300;
	while(SensorValue[forkPot]<2400+fpc);
	joystick=128;

	//openup=false;
	joystickf=-128;
	//	nPositionToHold=2500:
	clearTimer(T3);
	motor[frontLeft]=motor[backLeft]=128;
	while(SensorValue[armPotentiometerL]<2100){
		if(time1[T3]>200)
			motor[backLeft]=motor[backRight]=0;
	}
	motor[backLeft]=motor[backRight]=0;
	joystickf=0;
	joystick=0;
	stopTask(raiseOrLowerFork);
	openup=false;
	forward(128,250);
	nPositionToHoldf=500+fpc;
	sensorValue[solBig]=1;

	//fire big ball

	forward(128,130);
	wait1Msec(200);
	sensorValue[solBig]=0;
	wait1Msec(100);
	turn(128,-70);
	wait1Msec(50);
	forward(128,300);

	//pull to wall, realign

	while(!SensorValue[wall]);



	startTask(raiseOrLowerArm);
	startTask(raiseOrLowerFork);
	openup=false;
	kMaxPosf=2500+fpc;
	joystickf=0;

	backward(128,200);
	joystick=-128;
	backward(128,200);


	//	motor[fork]=-25;
	openup=true;
	backward(128,600);
	joystick=0;
	motor[fork]=0;
	//	motor[fork]=0;
	//	SensorValue[solDump]=0;
	joystickf=128;

	//pick up 2nd big ball

	backward(80,300);
	while(SensorValue[forkPot]<2250+fpc);
	joystickf=-128
	//	backward(60,400);
	kMaxPos=2400;
	joystick=128;

	//pick up 3nd big ball

	while(SensorValue[forkPot]>450+fpc);
	motor[fork]=0;
	joystickf=0;
	backward(75,820);
	kMaxPosf=1400+fpc;
	joystickf=128;
	while(SensorValue[forkPot]<1300+fpc);
	//	backward(80,100);
	//	breakDrive();
	joystickf=0;
	turn(128,90);
	motor[backLeft]=motor[backRight]=70;
	motor[frontLeft]=motor[frontRight]=70;
	wait1Msec(400);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	backward(128,400);
	wait1Msec(400);
	forward(128,250);

	SensorValue[solBig]=1;
	forward(128,100);
	wait1Msec(200);
	SensorValue[solBig]=0;
	joystick=-128;
	motor[roller]=-128;
	breakDrive();
	backward(80,100);
	while(SensorValue[armPotentiometerL]>1390);
//	joystick=0;
	kMaxPosf=2500+fpc;

	motor[backLeft]=motor[backRight]=60;
	motor[frontLeft]=motor[frontRight]=60;
	wait1Msec(300);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	while(SensorValue[armPotentiometerL]>1390);
	joystickf=128;
	joystick=0;
	while(SensorValue[forkPot]<2400+fpc);
	joystickf=-128;
	openup=false;
	turn(128,-105);
	openup=true;
	motor[roller]=0;
	wait1Msec(400);
	backward(128,850);
	backward(70,230);
	kMaxPosf=1300+fpc;
	joystickf=128;
	while(SensorValue[forkPot]<1200+fpc);
	turn(128,100);
	motor[backLeft]=motor[backRight]=70;
	motor[frontLeft]=motor[frontRight]=70;
	wait1Msec(400);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	joystick=128;
	backward(128,350);
	wait1Msec(500);
	forward(128,250);
	joystick=0;
	SensorValue[solBig]=1;
	kMaxPos=2700;
	forward(128,150);
	wait1Msec(400);
	joystick=128;
	//	SensorValue[solBig]=0;
	//	joystick=-128;
	breakDrive();
	//	nPositionToHoldf=500;



	turn(128,-68);
	//	SensorValue[solBreak]=1;
	forward(128,500);
	joystick=0;
	stopTask(raiseOrLowerArm);
	motor[armmotL]=motor[armmotR]=0;
	forward(128,2350);
	//	SensorValue[solBig]=1;
	turn(128,-90);


	while(!(SensorValue[GOL]|SensorValue[GOR])){}





	forward(128,500);
	turn(128,30);
	//	stopTask(raiseOrLowerArm);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=50;
	wait1Msec(400);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	motor[armmotL]=motor[armmotR]=128;
	while(SensorValue[armPotentiometerL]<2980);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=-70;
	wait1Msec(200);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	motor[armmotL]=motor[armmotR]=128;
	SensorValue[solShift]=1;
	kMaxPosf=1700+fpc;
	joystickf=128;
	wait1Msec(200);
	motor[frontLeft] = 	motor[frontRight] = motor[backRight] =	motor[backLeft] =128;
	motor[armmotL]=motor[armmotR]=-60;
	wait1Msec(400);
	kMaxPosf=2100+fpc;

	int dhang=7;
	int hangpos;
	bool fuckedup=false;
	string ampt,ddhang,lklk;
	while(SensorValue[armPotentiometerL]>1380)
	{
		/*		sprintf(ddhang, " %2.0f%c ", dhang);
		sprintf(ampt, " %4.0f%c ", SensorValue[armPotentiometerL]);
		sprintf(lklk, " %1.0f%c ", SensorValue[solLock]);
		writeDebugStream(ampt);
		writeDebugStream(ddhang);
		writeDebugStreamLine(lklk);*/
		if(dhang<2)
		{
			SensorValue[solLock]=true;
			joystickf=0;
			motor[frontLeft] = 	motor[frontRight] = motor[backRight] =	motor[backLeft] =0;
			motor[armmotL]=motor[armmotR]=0;
			fuckedup=true;
		}
		if(fuckedup)
		{
			wait1Msec(2500);
			motor[frontLeft] = 	motor[frontRight] = motor[backRight] =	motor[backLeft] =128;
			motor[armmotL]=motor[armmotR]=-128;

		}

		hangpos=nMotorEncoder[backLeft];
		wait1Msec(100);
		dhang = nMotorEncoder[backLeft]-hangpos;
	}
	SensorValue[solLock]=true;
	joystickf=0;
	wait10Msec(300);
	motor[armmotL]=motor[armmotR]=0;
	motor[frontLeft] = 	motor[frontRight] = motor[backRight] =	motor[backLeft] =0;

}


void GoSkillRisk()
{

	turnIEC(50,90);
	breakDrivet();
}


void GoRH1()
{
	SensorValue[solShift]=0;
	joystick=0;
	kMaxPos=2400;
	kMaxPosf = 1150+fpc;
	bool scan;
	startTask(raiseOrLowerArm);
	startTask(openFork);
	startTask(visualMem);
	liftDa=false;
	SensorValue[solDump]=0;


	//intake
	forward(127,300);
	motor[roller]=127;
	//	joystickf=128;
	forward(90,300);


	wait1Msec(700);

	joystickf=0;
	liftDa=true;
	motor[armmotL]=motor[armmotR]=-15;
	joystick=128;
	backward(128,250);
	motor[roller]=50;//intake
	motor[armmotL]=motor[armmotR]=0;
	liftDa=false;
	backward(128,250);

	turn(128,-165);


	//	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	kMaxPos=2650;
	SensorValue[solBig]=1;
	wait1Msec(300);
	SensorValue[solBig]=0;
	//	motor[roller]=-128;
	turn(128,-140);


	//	turn(128,-60);
	//	joystickf=-128;
	startTask(raiseOrLowerFork);
	while(!(SensorValue[GOL]|SensorValue[wall])){}

	motor[roller]=0;//intake
	//	startTask(raiseOrLowerArm);
	//	startTask(raiseOrLowerFork);
	openup=true;
	kMaxPosf=2500+fpc;
	joystickf=-128
	joystick=-128;
	wait1Msec(350);
	joystickf=0;

	//	motor[fork]=-25;
	backward(128,370);

	//	motor[fork]=0;
	//	SensorValue[solDump]=0;
	joystickf=128;
	//	backward(80,300);
	while(SensorValue[forkPot]<2350+fpc);
	joystickf=-128;
	//	backward(60,400);
	kMaxPos=2300;
	joystick=128;
	while(SensorValue[forkPot]>450+fpc);
	joystickf=0;

	backward(60,625);
	kMaxPosf=1400+fpc;
	joystickf=128;
	while(SensorValue[forkPot]<1300+fpc);
	//	backward(80,100);
	//	breakDrive();
	joystickf=0;
	stopTask(raiseOrLowerFork);
	motor[fork]=0;
	turn(128,90);
	motor[backLeft]=motor[backRight]=128;
	motor[frontLeft]=motor[frontRight]=128;
	wait1Msec(250);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;


	//	backward(128,400);
	//wait1Msec(400);
	//forward(128,250);

	SensorValue[solBig]=1;
	motor[roller]=-128;
	//forward(128,100);
	wait1Msec(300);
	SensorValue[solBig]=0;
	joystick=-128;
	startTask(raiseOrLowerFork);

	motor[backLeft]=motor[backRight]=-128;
	motor[frontLeft]=motor[frontRight]=-128;
	wait1Msec(300);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	//	breakDrive();
	//	backward(80,100);
	while(SensorValue[armPotentiometerL]>1400);
	//	joystick=0;
	kMaxPosf=2500+fpc;
	joystickf=128;

	//	backward(80,300);
	while(SensorValue[forkPot]<2350+fpc);
	//joystickf=-128
	//	backward(60,400);
	kMaxPos=2500;
	joystick=128;
	motor[backLeft]=motor[backRight]=128;
	motor[frontLeft]=motor[frontRight]=128;
	wait1Msec(250);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;

	while(SensorValue[armPotentiometerL]<2350);
	joystick=0;
	//	forward(128,100);
	SensorValue[solBig]=1;

	wait1Msec(400);
	SensorValue[solBig]=0;



}




////////////////////////////////////////////////////////////////////////////////////////////
void GoRH2()
{


turn(55,-50):
	SensorValue[solBig]=1;
	wait1Msec(300);
	SensorValue[solBig]=0;
	turn(128,-135);
	startTask(openFork);
	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	startTask(raiseOrLowerArm);
	//	startTask(raiseOrLowerArm);
	startTask(raiseOrLowerFork);
	openup=true;
	kMaxPosf=2500+fpc;
	joystickf=-128
	//	joystick=-128;
	wait1Msec(350);
	joystickf=0;

	//	motor[fork]=-25;
	backward(128,370);
	SensorValue[solDump]=0;
	//	motor[fork]=0;
	//	SensorValue[solDump]=0;
	joystickf=128;
	//	backward(80,300);
	while(SensorValue[forkPot]<2250+fpc);
	joystickf=-128;
	//	backward(60,400);
	kMaxPos=2300;
	joystick=128;
	while(SensorValue[forkPot]>450+fpc);
	joystickf=0;

	backward(60,625);
	kMaxPosf=1400+fpc;
	joystickf=128;
	while(SensorValue[forkPot]<1300+fpc);
	//	backward(80,100);
	//	breakDrive();
	joystickf=0;
	stopTask(raiseOrLowerFork);
	motor[fork]=0;
	turn(128,90);
	motor[roller]=-128;
	motor[backLeft]=motor[backRight]=128;
	motor[frontLeft]=motor[frontRight]=128;
	wait1Msec(250);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	//	backward(128,400);
	//wait1Msec(400);
	//forward(128,250);
	wait1Msec(450);
	SensorValue[solBig]=1;

	//forward(128,100);
	wait1Msec(300);
	SensorValue[solBig]=0;
	joystick=-128;
	startTask(raiseOrLowerFork);
	motor[backLeft]=motor[backRight]=-128;
	motor[frontLeft]=motor[frontRight]=-128;
	wait1Msec(300);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	//	breakDrive();
	//	backward(80,100);
	while(SensorValue[armPotentiometerL]>1400);
	//	joystick=0;
	kMaxPosf=2500+fpc;
	joystickf=128;

	//	backward(80,300);
	while(SensorValue[forkPot]<2350+fpc);
	//joystickf=-128
	//	backward(60,400);
	kMaxPos=2500;
	joystick=128;
	motor[backLeft]=motor[backRight]=128;
	motor[frontLeft]=motor[frontRight]=128;
	wait1Msec(250);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;

	while(SensorValue[armPotentiometerL]<2350);
	joystick=0;
	//	forward(128,100);
	SensorValue[solBig]=1;

	wait1Msec(400);
	SensorValue[solBig]=0;



}
///////////////////////////////////////////////////////////////////////////////////////
void GoRH3()
{
	nPositionToHoldf=410;
	SensorValue[solShift]=0;
	joystick=0;
	kMotorSpeedup=128;
	kMaxPos=2400;
	kMaxPosf = 1150+fpc;
	bool scan;
	startTask(raiseOrLowerArm);
	startTask(openFork);
	startTask(visualMem);
	liftDa=false;
	SensorValue[solDump]=0;


	//intake
	forward(127,300);
	motor[roller]=127;
	//	joystickf=128;
	forward(90,300);


	//	wait1Msec(700);

	joystickf=0;
	liftDa=true;
	motor[armmotL]=motor[armmotR]=-15;
	//	joystick=128;
	backward(128,300);
	motor[roller]=50;//intake
	motor[armmotL]=motor[armmotR]=0;
	liftDa=false;
	backward(128,300);

	motor[roller]=0;//intake
	startTask(raiseOrLowerFork);
	while(!(SensorValue[GOL]|SensorValue[GOR])){}

	motor[roller]=0;//intake
	//	startTask(raiseOrLowerArm);
	//	startTask(raiseOrLowerFork);
	openup=true;
	kMaxPosf=2500+fpc;
	joystickf=-128
	joystick=-128;
	wait1Msec(350);
	joystickf=0;

	//	motor[fork]=-25;
	backward(128,240);

	//	motor[fork]=0;
	//	SensorValue[solDump]=0;
	joystickf=128;
	//	backward(80,300);
	while(SensorValue[forkPot]<2350+fpc);
	joystickf=-128;
	//	backward(60,400);
	kMaxPos=2300;
	joystick=128;
	while(SensorValue[forkPot]>450+fpc);
	joystickf=0;

	backward(60,625);
	kMaxPosf=1400+fpc;
	joystickf=128;
	while(SensorValue[forkPot]<1300+fpc);
	//	backward(80,100);
	//	breakDrive();
	joystickf=0;
	stopTask(raiseOrLowerFork);
	motor[fork]=0;
	turn(128,90);
	motor[backLeft]=motor[backRight]=128;
	motor[frontLeft]=motor[frontRight]=128;
	wait1Msec(250);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;


	//	backward(128,400);
	//wait1Msec(400);
	//forward(128,250);

	SensorValue[solBig]=1;
	motor[roller]=-128;
	//forward(128,100);
	wait1Msec(300);
	SensorValue[solBig]=0;
	joystick=-128;
	startTask(raiseOrLowerFork);

	motor[backLeft]=motor[backRight]=-128;
	motor[frontLeft]=motor[frontRight]=-128;
	wait1Msec(300);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	//	breakDrive();
	//	backward(80,100);
	while(SensorValue[armPotentiometerL]>1400);
	//	joystick=0;
	kMaxPosf=2500+fpc;
	joystickf=128;

	//	backward(80,300);
	while(SensorValue[forkPot]<2350+fpc);
	//joystickf=-128
	//	backward(60,400);
	kMaxPos=2500;
	joystick=128;
	motor[backLeft]=motor[backRight]=128;
	motor[frontLeft]=motor[frontRight]=128;
	wait1Msec(250);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;

	while(SensorValue[armPotentiometerL]<2350);
	joystick=0;
	//	forward(128,100);
	SensorValue[solBig]=1;

	wait1Msec(400);
	SensorValue[solBig]=0;


}
////////////////////////////////////////////////////////////////////////////////////////////////////////
void GoRH4()
{
	motor[roller]=0;//intake
	startTask(openFork);
	startTask(raiseOrLowerArm);
	startTask(raiseOrLowerFork);
	openup=true;
	kMaxPosf=2500+fpc;
	joystickf=-128
	joystick=-128;
	wait1Msec(350);
	joystickf=0;

	//	motor[fork]=-25;
	backward(128,370);

	//	motor[fork]=0;
	SensorValue[solDump]=0;
	joystickf=128;
	//	backward(80,300);
	while(SensorValue[forkPot]<2350+fpc);
	joystickf=-128;
	//	backward(60,400);
	kMaxPos=2300;
	joystick=128;
	while(SensorValue[forkPot]>450+fpc);
	joystickf=0;

	backward(90,625);
	kMaxPosf=1400+fpc;
	joystickf=128;
	while(SensorValue[forkPot]<1300+fpc);
	//	backward(80,100);
	//	breakDrive();
	joystickf=0;
	//stopTask(raiseOrLowerFork);
	motor[fork]=0;
	turn(128,90);
	motor[backLeft]=motor[backRight]=128;
	motor[frontLeft]=motor[frontRight]=128;
	wait1Msec(250);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;


	//	backward(128,400);
	//wait1Msec(400);
	//forward(128,250);

	SensorValue[solBig]=1;
	motor[roller]=-128;
	//forward(128,100);
	wait1Msec(300);
	SensorValue[solBig]=0;
	joystick=-128;
	//startTask(raiseOrLowerFork);

	motor[backLeft]=motor[backRight]=-128;
	motor[frontLeft]=motor[frontRight]=-128;
	wait1Msec(300);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	//	breakDrive();
	//	backward(80,100);
	while(SensorValue[armPotentiometerL]>1400);
	//	joystick=0;
	kMaxPosf=2500+fpc;
	joystickf=128;

	//	backward(80,300);
	while(SensorValue[forkPot]<2350+fpc);
	//joystickf=-128
	//	backward(60,400);
	kMaxPos=2500;
	joystick=128;
	motor[backLeft]=motor[backRight]=128;
	motor[frontLeft]=motor[frontRight]=128;
	wait1Msec(250);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;

	while(SensorValue[armPotentiometerL]<2350);
	joystick=0;
	//	forward(128,100);
	SensorValue[solBig]=1;

	wait1Msec(400);
	SensorValue[solBig]=0;
	openup=false;
	joystickf=-128
	joystick=-128;
	motor[roller]=0;
	turn(128,100);
	backward(128,800);
	turn(128,70);
	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	motor[roller]=128;
	forward(128,700);


}
////////////////////////////////////////////////////////////////////////////////
void GoRH5()
{
	nPositionToHoldf=410;
	SensorValue[solShift]=0;
	joystick=0;
	kMotorSpeedup=128;
	kMaxPos=2400;
	kMaxPosf = 1150+fpc;
	bool scan;
	startTask(raiseOrLowerArm);
	startTask(openFork);
	startTask(visualMem);
	liftDa=false;
	SensorValue[solDump]=0;


	//intake
	forward(127,300);
	motor[roller]=127;
	//	joystickf=128;
	forward(90,300);


	wait1Msec(700);

	joystickf=0;
	liftDa=true;
	motor[armmotL]=motor[armmotR]=-15;
	//	joystick=128;
	backward(128,300);
	motor[roller]=50;//intake
	motor[armmotL]=motor[armmotR]=0;
	liftDa=false;
	backward(128,300);
	turn(128,990);
	motor[roller]=0;//intake
	kMaxPosf=1400;
	startTask(raiseOrLowerFork);
	joystickf=128;

	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	motor[roller]=50;
	backward(128,300);
	joystickf=0;
	motor[armmotL]=motor[armmotR]=0;
	liftDa=false;

	while(!(eyeM|eyeR|eyeL))//eyehits line)		//
	{
		motor[backLeft]=motor[frontLeft]=80;
		motor[backRight]=motor[frontRight]=80;
	}
	motor[backLeft]=motor[frontLeft]=motor[backRight]=motor[frontRight]=0;
	forward(60,100);
	breakDrive();
	turn(128,-90);
	motor[backLeft]=motor[backRight]=60;
	motor[frontLeft]=motor[frontRight]=60;
	wait1Msec(400);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	forward(128,2300);
	kMaxPos=3000;
	joystick=128;
	while(SensorValue[armPotentiometerL]<2950);
	joystick=0;
	forward(80,650);
	breakDrive();
	motor[roller]=-128;


}

void GoRM1()
{
	startTask(raiseOrLowerArm);
	//startTask(raiseOrLowerFork);
	liftDa=false;
	SensorValue[solDump]=0;
	kMaxPos=1700;
	joystick=128;
	wait1Msec(200);
	joystick=-128;
	//initialize

	motor[roller]=127;
	forward(127,300);
	joystickf=128;
	joystick=0;

	forward(128,940);
	motor[roller]=80;
	forward(128,230);
	//	kMaxPosf=1200;
	//	joystickf=0;
	kMaxPos=3000;
	liftDa=false;
	joystick=128;
	//	stopTask(raiseOrLowerFork);
	//	motor[fork]=-55;
	forward(128,250);
	//	breakDrive();
	while(SensorValue[armPotentiometerL]<2800);
	forward(70,400);
	//	joystick=-128;
	wait1Msec(50);
	//	motor[fork]=-15;
	joystick=128;
	//	joystickf=0;
	//breakDrive();

	motor[roller]=-128;
	//	SensorValue[solDump]=1;

	//dump buckyballs


	wait1Msec(1200);
	while(!SensorValue[GOL])
	{
		motor[backLeft]=motor[frontLeft]=128;
		motor[backRight]=motor[frontRight]=128;
	}
	if(SensorValue[GOL])
		motor[backLeft]=motor[frontLeft]=-80;
	else
		motor[backLeft]=motor[frontLeft]=0;
	motor[backRight]=motor[frontRight]=128;


	//align with wall

	while(!SensorValue[wall])
	{
		if(SensorValue[GOL])
			motor[backLeft]=motor[frontLeft]=-80;
		else
			motor[backLeft]=motor[frontLeft]=0;
	}
	if(!SensorValue[GOL])
	{
		motor[backRight]=motor[frontRight]=10;
		motor[backLeft]=motor[frontLeft]=90;
	}
	while(!(SensorValue[wall]&SensorValue[GOL]));
	motor[backLeft]=motor[frontLeft]=motor[backRight]=motor[frontRight]=30;//turnc
	wait1Msec(100);
	motor[backLeft]=motor[frontLeft]=motor[backRight]=motor[frontRight]=0;//turnc
	motor[roller]=0;
	//	eyeBm=false;
	//	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	backward(128,350);
	joystick=-128;
	backward(128,250);


	while(SensorValue[armPotentiometerL]>1450);
	wait1Msec(100);
	while(SensorValue[armPotentiometerL]>1380);
	joystick=0;
	//	stopTask(raiseOrLowerArm);
	motor[armmotL]=motor[armmotR]=-5;
	SensorValue[solDump]=0;
	//	kMaxPosf=1200;
	//joystickf=128;
	backward(128,900);
	joystick=128;
	while(SensorValue[armPotentiometerL]<2200);
	joystick=0;
	turn(128,15);
	forward(128,300);
	backward(128,400);
	joystick=-128;
	turn(128,90);
	joystick=0;




}
void GoRM2()
{
	startTask(raiseOrLowerArm);
	//startTask(raiseOrLowerFork);

turn(55,-40):
	SensorValue[solBig]=1;
	wait1Msec(300);
	SensorValue[solBig]=0;
	turn(128,-35);
	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	liftDa=false;
	SensorValue[solDump]=0;
	kMaxPos=1700;
	joystick=128;
	wait1Msec(200);
	joystick=-128;
	//initialize

	motor[roller]=127;
	forward(127,200);
	//	joystickf=128;
	joystick=0;
	forward(127,900);
	turn(128,-60);
	backward(128,600);
	kMaxPos=2300;
	joystick=128;
	backward(128,500);
	turn(128,20);
	forward(128,300);
	backward(128,500);
	joystick=-128;
	wait1Msec(1000);
	joystick=0;
	//	while(!(SensorValue[GOL]|SensorValue[GOR])){}

	//	stopTask(raiseOrLowerFork);
	//	motor[fork]=-55;
}

void GoRM3()
{
	SensorValue[solShift]=0;
	joystick=0;
	kMaxPos=3100;
	kMaxPosf = 1350;
	//	bool scan;
	startTask(raiseOrLowerFork);
	startTask(openFork);
	startTask(visualMem);





	SensorValue[solDump]=0;
	motor[armmotL]=motor[armmotR]=-25;
	forward(128,300);
	motor[armmotL]=motor[armmotR]=0;
	liftDa=false;

	while(!(eyeM|eyeR|eyeL))//eyehits line)		//
	{
		motor[backLeft]=motor[frontLeft]=80;
		motor[backRight]=motor[frontRight]=80;
	}
	startTask(raiseOrLowerArm);
	kMaxPos=1700;
	joystick=128;
	forward(50,100);
	breakDrive();
	nPositionToHold=1700;
	SensorValue[solBreak]=1;
	while(SensorValue[armPotentiometerL]<1550);
	motor[roller]=128;
	turnPCS45(128,53);
	//	breakDrivet();
	SensorValue[solBreak]=0;
	SensorValue[gyro]=0;
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=60;
	wait1Msec(200);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	joystick=-128;
	while(SensorValue[armPotentiometerL]>1390);
	wait1Msec(400);
	backward(90,80);
	joystick=0;
	turn(128,-35);
	backward(128,400);
	turn(128,-70);
	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	liftDa=false;
	SensorValue[solDump]=0;
	kMaxPos=1700;
	joystick=128;
	wait1Msec(200);
	joystick=-128;
	//initialize

	motor[roller]=127;
	forward(127,300);
	joystickf=128;
	joystick=0;

	forward(128,940);
	motor[roller]=80;
	forward(128,230);
	//	kMaxPosf=1200;
	//	joystickf=0;
	kMaxPos=3000;
	liftDa=false;
	joystick=128;
	//	stopTask(raiseOrLowerFork);
	//	motor[fork]=-55;
	forward(128,250);
	//	breakDrive();
	while(SensorValue[armPotentiometerL]<2800);
	forward(70,400);
	//	joystick=-128;
	wait1Msec(50);
	//	motor[fork]=-15;
	joystick=128;
	//	joystickf=0;
	//breakDrive();

	motor[roller]=-128;
	//	SensorValue[solDump]=1;

	//dump buckyballs


	wait1Msec(1200);
	while(!SensorValue[GOL])
	{
		motor[backLeft]=motor[frontLeft]=128;
		motor[backRight]=motor[frontRight]=128;
	}
	if(SensorValue[GOL])
		motor[backLeft]=motor[frontLeft]=-80;
	else
		motor[backLeft]=motor[frontLeft]=0;
	motor[backRight]=motor[frontRight]=128;


	//align with wall

	while(!SensorValue[wall])
	{
		if(SensorValue[GOL])
			motor[backLeft]=motor[frontLeft]=-80;
		else
			motor[backLeft]=motor[frontLeft]=0;
	}
	if(!SensorValue[GOL])
	{
		motor[backRight]=motor[frontRight]=10;
		motor[backLeft]=motor[frontLeft]=90;
	}
	while(!(SensorValue[wall]&SensorValue[GOL]));
	motor[backLeft]=motor[frontLeft]=motor[backRight]=motor[frontRight]=30;//turnc
	wait1Msec(100);
	motor[backLeft]=motor[frontLeft]=motor[backRight]=motor[frontRight]=0;//turnc
	motor[roller]=0;
	//	eyeBm=false;
	//	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	backward(128,350);
	joystick=-128;
	backward(128,250);

	while(SensorValue[armPotentiometerL]>1450);
	wait1Msec(100);
	while(SensorValue[armPotentiometerL]>1380);
	joystick=0;


}
void GoRM4()
{

	//	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	startTask(raiseOrLowerArm);
	liftDa=false;
	SensorValue[solDump]=0;
	kMaxPos=1700;
	joystick=128;
	wait1Msec(200);
	joystick=-128;
	//initialize


	forward(127,300);
	//	joystickf=128;
	joystick=0;
	forward(128,1200);
	motor[roller]=-127;
	kMaxPos=2200;
	joystick=128;
	turnPCS45(128,68);
	SensorValue[solDump]=0;
	forwardNS(128,1900);
	turn(128,90);
	SensorValue[solDump]=1;
	forwardNS(128,400);
	backwardNS(128,300);
	turn(128,-60);
	forwardNS(128,700);
	turn(128,60);
	forwardNS(128,300);
	backwardNS(128,500);
	joystick=-128;
	wait1Msec(800);
	joystick=0;

}










void GoBH1()
{
	SensorValue[solShift]=0;
	joystick=0;
	kMaxPos=2400;
	kMaxPosf = 1150+fpc;
	bool scan;
	startTask(raiseOrLowerArm);
	startTask(openFork);
	startTask(visualMem);
	liftDa=false;
	SensorValue[solDump]=0;


	//intake
	forward(127,300);
	motor[roller]=127;
	//	joystickf=128;
	forward(90,300);


	wait1Msec(700);

	joystickf=0;
	liftDa=true;
	motor[armmotL]=motor[armmotR]=-15;
	joystick=128;
	backward(128,250);
	motor[roller]=50;//intake
	motor[armmotL]=motor[armmotR]=0;
	liftDa=false;
	backward(128,250);

	turn(128,165);


	//	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	kMaxPos=2650;
	SensorValue[solBig]=1;
	wait1Msec(300);
	SensorValue[solBig]=0;
	//	motor[roller]=-128;
	turn(128,140);


	//	turn(128,-60);
	//	joystickf=-128;
	startTask(raiseOrLowerFork);
	while(!(SensorValue[GOL]|SensorValue[wall])){}

	motor[roller]=0;//intake
	//	startTask(raiseOrLowerArm);
	//	startTask(raiseOrLowerFork);
	openup=true;
	kMaxPosf=2500+fpc;
	joystickf=-128
	joystick=-128;
	wait1Msec(350);
	joystickf=0;

	//	motor[fork]=-25;
	backward(128,370);

	//	motor[fork]=0;
	//	SensorValue[solDump]=0;
	joystickf=128;
	//	backward(80,300);
	while(SensorValue[forkPot]<2350+fpc);
	joystickf=-128;
	//	backward(60,400);
	kMaxPos=2300;
	joystick=128;
	while(SensorValue[forkPot]>450+fpc);
	joystickf=0;

	backward(60,625);
	kMaxPosf=1400+fpc;
	joystickf=128;
	while(SensorValue[forkPot]<1300+fpc);
	//	backward(80,100);
	//	breakDrive();
	joystickf=0;
	stopTask(raiseOrLowerFork);
	motor[fork]=0;
	turn(128,-90);
	motor[backLeft]=motor[backRight]=128;
	motor[frontLeft]=motor[frontRight]=128;
	wait1Msec(250);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;


	//	backward(128,400);
	//wait1Msec(400);
	//forward(128,250);

	SensorValue[solBig]=1;
	motor[roller]=-128;
	//forward(128,100);
	wait1Msec(300);
	SensorValue[solBig]=0;
	joystick=-128;
	startTask(raiseOrLowerFork);

	motor[backLeft]=motor[backRight]=-128;
	motor[frontLeft]=motor[frontRight]=-128;
	wait1Msec(300);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	//	breakDrive();
	//	backward(80,100);
	while(SensorValue[armPotentiometerL]>1400);
	//	joystick=0;
	kMaxPosf=2500+fpc;
	joystickf=128;

	//	backward(80,300);
	while(SensorValue[forkPot]<2350+fpc);
	//joystickf=-128
	//	backward(60,400);
	kMaxPos=2500;
	joystick=128;
	motor[backLeft]=motor[backRight]=128;
	motor[frontLeft]=motor[frontRight]=128;
	wait1Msec(250);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;

	while(SensorValue[armPotentiometerL]<2350);
	joystick=0;
	//	forward(128,100);
	SensorValue[solBig]=1;

	wait1Msec(400);
	SensorValue[solBig]=0;



}


////////////////////////////////////////////////////////////////////////////////////////////
void GoBH2()
{


turn(55,50):
	SensorValue[solBig]=1;
	wait1Msec(300);
	SensorValue[solBig]=0;
	turn(128,135);
	startTask(openFork);
	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	startTask(raiseOrLowerArm);
	//	startTask(raiseOrLowerArm);
	startTask(raiseOrLowerFork);
	openup=true;
	kMaxPosf=2500+fpc;
	joystickf=-128
	//	joystick=-128;
	wait1Msec(350);
	joystickf=0;

	//	motor[fork]=-25;
	backward(128,370);
	SensorValue[solDump]=0;
	//	motor[fork]=0;
	//	SensorValue[solDump]=0;
	joystickf=128;
	//	backward(80,300);
	while(SensorValue[forkPot]<2250+fpc);
	joystickf=-128;
	//	backward(60,400);
	kMaxPos=2300;
	joystick=128;
	while(SensorValue[forkPot]>450+fpc);
	joystickf=0;

	backward(60,625);
	kMaxPosf=1400+fpc;
	joystickf=128;
	while(SensorValue[forkPot]<1300+fpc);
	//	backward(80,100);
	//	breakDrive();
	joystickf=0;
	stopTask(raiseOrLowerFork);
	motor[fork]=0;
	turn(128,-90);
	motor[roller]=-128;
	motor[backLeft]=motor[backRight]=128;
	motor[frontLeft]=motor[frontRight]=128;
	wait1Msec(250);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	//	backward(128,400);
	//wait1Msec(400);
	//forward(128,250);
	wait1Msec(450);
	SensorValue[solBig]=1;

	//forward(128,100);
	wait1Msec(300);
	SensorValue[solBig]=0;
	joystick=-128;
	startTask(raiseOrLowerFork);
	motor[backLeft]=motor[backRight]=-128;
	motor[frontLeft]=motor[frontRight]=-128;
	wait1Msec(300);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	//	breakDrive();
	//	backward(80,100);
	while(SensorValue[armPotentiometerL]>1400);
	//	joystick=0;
	kMaxPosf=2500+fpc;
	joystickf=128;

	//	backward(80,300);
	while(SensorValue[forkPot]<2350+fpc);
	//joystickf=-128
	//	backward(60,400);
	kMaxPos=2500;
	joystick=128;
	motor[backLeft]=motor[backRight]=128;
	motor[frontLeft]=motor[frontRight]=128;
	wait1Msec(250);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;

	while(SensorValue[armPotentiometerL]<2350);
	joystick=0;
	//	forward(128,100);
	SensorValue[solBig]=1;

	wait1Msec(400);
	SensorValue[solBig]=0;



}
///////////////////////////////////////////////////////////////////////////////////////
void GoBH3()
{
	nPositionToHoldf=410;
	SensorValue[solShift]=0;
	joystick=0;
	kMotorSpeedup=128;
	kMaxPos=2400;
	kMaxPosf = 1150+fpc;
	bool scan;
	startTask(raiseOrLowerArm);
	startTask(openFork);
	startTask(visualMem);
	liftDa=false;
	SensorValue[solDump]=0;


	//intake
	forward(127,300);
	motor[roller]=127;
	//	joystickf=128;
	forward(90,300);


	//	wait1Msec(700);

	joystickf=0;
	liftDa=true;
	motor[armmotL]=motor[armmotR]=-15;
	//	joystick=128;
	backward(128,300);
	motor[roller]=50;//intake
	motor[armmotL]=motor[armmotR]=0;
	liftDa=false;
	backward(128,300);

	motor[roller]=0;//intake
	startTask(raiseOrLowerFork);
	while(!(SensorValue[GOL]|SensorValue[GOR])){}

	motor[roller]=0;//intake
	//	startTask(raiseOrLowerArm);
	//	startTask(raiseOrLowerFork);
	openup=true;
	kMaxPosf=2500+fpc;
	joystickf=-128
	joystick=-128;
	wait1Msec(350);
	joystickf=0;

	//	motor[fork]=-25;
	backward(128,240);

	//	motor[fork]=0;
	//	SensorValue[solDump]=0;
	joystickf=128;
	//	backward(80,300);
	while(SensorValue[forkPot]<2350+fpc);
	joystickf=-128;
	//	backward(60,400);
	kMaxPos=2300;
	joystick=128;
	while(SensorValue[forkPot]>450+fpc);
	joystickf=0;

	backward(60,625);
	kMaxPosf=1400+fpc;
	joystickf=128;
	while(SensorValue[forkPot]<1300+fpc);
	//	backward(80,100);
	//	breakDrive();
	joystickf=0;
	stopTask(raiseOrLowerFork);
	motor[fork]=0;
	turn(128,-90);
	motor[backLeft]=motor[backRight]=128;
	motor[frontLeft]=motor[frontRight]=128;
	wait1Msec(250);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;


	//	backward(128,400);
	//wait1Msec(400);
	//forward(128,250);

	SensorValue[solBig]=1;
	motor[roller]=-128;
	//forward(128,100);
	wait1Msec(300);
	SensorValue[solBig]=0;
	joystick=-128;
	startTask(raiseOrLowerFork);

	motor[backLeft]=motor[backRight]=-128;
	motor[frontLeft]=motor[frontRight]=-128;
	wait1Msec(300);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	//	breakDrive();
	//	backward(80,100);
	while(SensorValue[armPotentiometerL]>1400);
	//	joystick=0;
	kMaxPosf=2500+fpc;
	joystickf=128;

	//	backward(80,300);
	while(SensorValue[forkPot]<2350+fpc);
	//joystickf=-128
	//	backward(60,400);
	kMaxPos=2500;
	joystick=128;
	motor[backLeft]=motor[backRight]=128;
	motor[frontLeft]=motor[frontRight]=128;
	wait1Msec(250);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;

	while(SensorValue[armPotentiometerL]<2350);
	joystick=0;
	//	forward(128,100);
	SensorValue[solBig]=1;

	wait1Msec(400);
	SensorValue[solBig]=0;


}
////////////////////////////////////////////////////////////////////////////////////////////////////////
void GoBH4()
{
	motor[roller]=0;//intake
	startTask(openFork);
	startTask(raiseOrLowerArm);
	startTask(raiseOrLowerFork);
	openup=true;
	kMaxPosf=2500+fpc;
	joystickf=-128
	joystick=-128;
	wait1Msec(350);
	joystickf=0;

	//	motor[fork]=-25;
	backward(128,370);

	//	motor[fork]=0;
	SensorValue[solDump]=0;
	joystickf=128;
	//	backward(80,300);
	while(SensorValue[forkPot]<2350+fpc);
	joystickf=-128;
	//	backward(60,400);
	kMaxPos=2300;
	joystick=128;
	while(SensorValue[forkPot]>450+fpc);
	joystickf=0;

	backward(90,625);
	kMaxPosf=1400+fpc;
	joystickf=128;
	while(SensorValue[forkPot]<1300+fpc);
	//	backward(80,100);
	//	breakDrive();
	joystickf=0;
	//stopTask(raiseOrLowerFork);
	motor[fork]=0;
	turn(128,-90);
	motor[backLeft]=motor[backRight]=128;
	motor[frontLeft]=motor[frontRight]=128;
	wait1Msec(250);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;


	//	backward(128,400);
	//wait1Msec(400);
	//forward(128,250);

	SensorValue[solBig]=1;
	motor[roller]=-128;
	//forward(128,100);
	wait1Msec(300);
	SensorValue[solBig]=0;
	joystick=-128;
	//startTask(raiseOrLowerFork);

	motor[backLeft]=motor[backRight]=-128;
	motor[frontLeft]=motor[frontRight]=-128;
	wait1Msec(300);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	//	breakDrive();
	//	backward(80,100);
	while(SensorValue[armPotentiometerL]>1400);
	//	joystick=0;
	kMaxPosf=2500+fpc;
	joystickf=128;

	//	backward(80,300);
	while(SensorValue[forkPot]<2350+fpc);
	//joystickf=-128
	//	backward(60,400);
	kMaxPos=2500;
	joystick=128;
	motor[backLeft]=motor[backRight]=128;
	motor[frontLeft]=motor[frontRight]=128;
	wait1Msec(250);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;

	while(SensorValue[armPotentiometerL]<2350);
	joystick=0;
	//	forward(128,100);
	SensorValue[solBig]=1;

	wait1Msec(400);
	SensorValue[solBig]=0;
	openup=false;
	joystickf=-128
	joystick=-128;
	motor[roller]=0;
	turn(128,100);
	backward(128,800);
	turn(128,70);
	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	motor[roller]=128;
	forward(128,700);


}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void GoBH5()
{
	nPositionToHoldf=410;
	SensorValue[solShift]=0;
	joystick=0;
	kMotorSpeedup=128;
	kMaxPos=2400;
	kMaxPosf = 1150+fpc;
	bool scan;
	startTask(raiseOrLowerArm);
	startTask(openFork);
	startTask(visualMem);
	liftDa=false;
	SensorValue[solDump]=0;


	//intake
	forward(127,300);
	motor[roller]=127;
	//	joystickf=128;
	forward(90,300);


	wait1Msec(700);

	joystickf=0;
	liftDa=true;
	motor[armmotL]=motor[armmotR]=-15;
	//	joystick=128;
	backward(128,300);
	motor[roller]=50;//intake
	motor[armmotL]=motor[armmotR]=0;
	liftDa=false;
	backward(128,300);
	turn(128,990);
	motor[roller]=0;//intake
	kMaxPosf=1400;
	startTask(raiseOrLowerFork);
	joystickf=128;

	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	motor[roller]=50;
	backward(128,300);
	joystickf=0;
	motor[armmotL]=motor[armmotR]=0;
	liftDa=false;

	while(!(eyeM|eyeR|eyeL))//eyehits line)		//
	{
		motor[backLeft]=motor[frontLeft]=80;
		motor[backRight]=motor[frontRight]=80;
	}
	motor[backLeft]=motor[frontLeft]=motor[backRight]=motor[frontRight]=0;
	forward(60,100);
	breakDrive();
	turn(128,-90);
	motor[backLeft]=motor[backRight]=60;
	motor[frontLeft]=motor[frontRight]=60;
	wait1Msec(400);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	forward(128,2300);
	kMaxPos=3000;
	joystick=128;
	while(SensorValue[armPotentiometerL]<2950);
	joystick=0;
	forward(80,650);
	breakDrive();
	motor[roller]=-128;


}

void GoBM1()
{
	startTask(raiseOrLowerArm);
	//startTask(raiseOrLowerFork);
	liftDa=false;
	SensorValue[solDump]=0;
	kMaxPos=1700;
	joystick=128;
	wait1Msec(200);
	joystick=-128;
	//initialize

	motor[roller]=127;
	forward(127,300);
	joystickf=128;
	joystick=0;

	forward(128,940);
	motor[roller]=80;
	forward(128,230);
	//	kMaxPosf=1200;
	//	joystickf=0;
	kMaxPos=3000;
	liftDa=false;
	joystick=128;
	//	stopTask(raiseOrLowerFork);
	//	motor[fork]=-55;
	forward(128,250);
	//	breakDrive();
	while(SensorValue[armPotentiometerL]<2800);
	forward(70,400);
	//	joystick=-128;
	wait1Msec(50);
	//	motor[fork]=-15;
	joystick=128;
	//	joystickf=0;
	//breakDrive();

	motor[roller]=-128;
	//	SensorValue[solDump]=1;

	//dump buckyballs


	wait1Msec(1200);
	while(!SensorValue[wall])
	{
		motor[backLeft]=motor[frontLeft]=128;
		motor[backRight]=motor[frontRight]=128;
	}
	if(SensorValue[wall])
		motor[backLeft]=motor[frontLeft]=0;
	else
		motor[backLeft]=motor[frontLeft]=-80;
	motor[backRight]=motor[frontRight]=128;


	//align with wall

	while(!SensorValue[GOL])
	{
		if(SensorValue[wall])
			motor[backLeft]=motor[frontLeft]=0;
		else
			motor[backLeft]=motor[frontLeft]=-80;
	}
	if(!SensorValue[wall])
	{
		motor[backRight]=motor[frontRight]=90;
		motor[backLeft]=motor[frontLeft]=10;
	}
	while(!(SensorValue[wall]&SensorValue[GOL]));
	motor[backLeft]=motor[frontLeft]=motor[backRight]=motor[frontRight]=30;//turnc
	wait1Msec(100);
	motor[backLeft]=motor[frontLeft]=motor[backRight]=motor[frontRight]=0;//turnc
	motor[roller]=0;
	//	eyeBm=false;
	//	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	backward(128,350);
	joystick=-128;
	backward(128,250);

	while(SensorValue[armPotentiometerL]>1450);
	wait1Msec(100);
	while(SensorValue[armPotentiometerL]>1380);
	joystick=0;
	//	stopTask(raiseOrLowerArm);
	motor[armmotL]=motor[armmotR]=-5;
	SensorValue[solDump]=0;
	//	kMaxPosf=1200;
	//joystickf=128;
	backward(128,900);
	joystick=128;
	while(SensorValue[armPotentiometerL]<2200);
	joystick=0;
	turn(128,-15);
	forward(128,300);
	backward(128,400);
	joystick=-128;
	turn(128,-90);
	joystick=0;




}
void GoBM2()
{
	startTask(raiseOrLowerArm);
	//startTask(raiseOrLowerFork);

turn(55,40):
	SensorValue[solBig]=1;
	wait1Msec(300);
	SensorValue[solBig]=0;
	turn(128,35);
	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	liftDa=false;
	SensorValue[solDump]=0;
	kMaxPos=1700;
	joystick=128;
	wait1Msec(200);
	joystick=-128;
	//initialize

	motor[roller]=127;
	forward(127,200);
	//	joystickf=128;
	joystick=0;
	forward(127,900);
	turn(128,60);
	backward(128,600);
	kMaxPos=2300;
	joystick=128;
	backward(128,500);
	turn(128,-20);
	forward(128,300);
	backward(128,500);
	joystick=-128;
	wait1Msec(1000);
	joystick=0;
	//	while(!(SensorValue[GOL]|SensorValue[GOR])){}

	//	stopTask(raiseOrLowerFork);
	//	motor[fork]=-55;
}


void GoBM3()
{
	SensorValue[solShift]=0;
	joystick=0;
	kMaxPos=3100;
	kMaxPosf = 1350;
	//	bool scan;
	startTask(raiseOrLowerFork);
	startTask(openFork);
	startTask(visualMem);





	SensorValue[solDump]=0;
	motor[armmotL]=motor[armmotR]=-25;
	forward(128,300);
	motor[armmotL]=motor[armmotR]=0;
	liftDa=false;

	while(!(eyeM|eyeR|eyeL))//eyehits line)		//
	{
		motor[backLeft]=motor[frontLeft]=80;
		motor[backRight]=motor[frontRight]=80;
	}
	startTask(raiseOrLowerArm);
	kMaxPos=1700;
	joystick=128;
	forward(50,100);
	breakDrive();
	nPositionToHold=1700;
	SensorValue[solBreak]=1;
	while(SensorValue[armPotentiometerL]<1550);
	motor[roller]=128;
	turnPCS45(128,-53);
	//	breakDrivet();
	SensorValue[solBreak]=0;
	SensorValue[gyro]=0;
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=60;
	wait1Msec(200);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	joystick=-128;
	while(SensorValue[armPotentiometerL]>1390);
	wait1Msec(400);
	backward(90,80);
	joystick=0;
	turn(128,35);
	backward(128,400);
	turn(128,70);
	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	liftDa=false;
	SensorValue[solDump]=0;
	kMaxPos=1700;
	joystick=128;
	wait1Msec(200);
	joystick=-128;
	//initialize

	motor[roller]=127;
	forward(127,300);
	joystickf=128;
	joystick=0;

	forward(128,940);
	motor[roller]=80;
	forward(128,230);
	//	kMaxPosf=1200;
	//	joystickf=0;
	kMaxPos=3000;
	liftDa=false;
	joystick=128;
	//	stopTask(raiseOrLowerFork);
	//	motor[fork]=-55;
	forward(128,250);
	//	breakDrive();
	while(SensorValue[armPotentiometerL]<2800);
	forward(70,400);
	//	joystick=-128;
	wait1Msec(50);
	//	motor[fork]=-15;
	joystick=128;
	//	joystickf=0;
	//breakDrive();

	motor[roller]=-128;
	//	SensorValue[solDump]=1;

	//dump buckyballs


	wait1Msec(1200);
	while(!SensorValue[wall])
	{
		motor[backLeft]=motor[frontLeft]=128;
		motor[backRight]=motor[frontRight]=128;
	}
	if(SensorValue[wall])
		motor[backLeft]=motor[frontLeft]=0;
	else
		motor[backLeft]=motor[frontLeft]=-80;
	motor[backRight]=motor[frontRight]=128;


	//align with wall

	while(!SensorValue[GOL])
	{
		if(SensorValue[wall])
			motor[backLeft]=motor[frontLeft]=0;
		else
			motor[backLeft]=motor[frontLeft]=-80;
	}
	if(!SensorValue[wall])
	{
		motor[backRight]=motor[frontRight]=90;
		motor[backLeft]=motor[frontLeft]=10;
	}
	while(!(SensorValue[wall]&SensorValue[GOL]));
	motor[backLeft]=motor[frontLeft]=motor[backRight]=motor[frontRight]=30;//turnc
	wait1Msec(100);
	motor[backLeft]=motor[frontLeft]=motor[backRight]=motor[frontRight]=0;//turnc
	motor[roller]=0;
	//	eyeBm=false;
	//	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	backward(128,350);
	joystick=-128;
	backward(128,250);


	while(SensorValue[armPotentiometerL]>1450);
	wait1Msec(100);
	while(SensorValue[armPotentiometerL]>1380);
	joystick=0;


}
void GoBM4()
{

	//	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	startTask(raiseOrLowerArm);
	liftDa=false;
	SensorValue[solDump]=0;
	kMaxPos=1700;
	joystick=128;
	wait1Msec(200);
	joystick=-128;
	//initialize


	forward(127,300);
	//	joystickf=128;
	joystick=0;
	forward(128,1200);
	motor[roller]=-127;
	kMaxPos=2200;
	joystick=128;
	turnPCS45(128,-68);
	SensorValue[solDump]=0;
	forwardNS(128,1900);
	turn(128,-90);
	SensorValue[soldump]=1;
	forwardNS(128,400);
	backwardNS(128,300);
	turn(128,60);
	forwardNS(128,700);
	turn(128,-60);
	forwardNS(128,300);
	backwardNS(128,500);
	joystick=-128;
	wait1Msec(800);
	joystick=0;

}



void GoFeed()
{
	SensorValue[solShift]=0;
	joystick=0;
	kMaxPos=2400;
	kMaxPosf = 1150+fpc;
	bool scan;
	startTask(raiseOrLowerArm);
	startTask(openFork);
	startTask(visualMem);
	liftDa=false;
	SensorValue[solDump]=0;


	//intake
	forward(127,300);
	motor[roller]=127;
	//	joystickf=128;
	forward(90,300);

	kMaxPos=1600;
	wait1Msec(700);

	joystickf=0;
	liftDa=true;
	motor[armmotL]=motor[armmotR]=-15;
	joystick=128;
	backward(128,250);
	motor[roller]=50;//intake
	motor[armmotL]=motor[armmotR]=0;
	liftDa=false;
	backward(128,600);
	joystick=128;
	kMaxPos=1600;
	turn(128,-180);
	motor[roller]=0;//intake
	joystick=0;
	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	motor[roller]=-128;//intake


}

void GoEatR()
{
	startTask(raiseOrLowerArm);
	//startTask(raiseOrLowerFork);
	liftDa=false;
	SensorValue[solDump]=0;
	kMaxPos=1700;
	joystick=128;
	wait1Msec(200);
	joystick=-128;
	//initialize

	motor[roller]=127;
	backward(80,200);
	wait1Msec(250);
	joystick=0;
	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	turn(128,-160);
	while(!(SensorValue[GOL]|SensorValue[GOR])){}

	forward(127,300);
	joystickf=128;
	joystick=0;

	forward(128,940);
	motor[roller]=80;
	forward(128,230);
	//	kMaxPosf=1200;
	//	joystickf=0;
	kMaxPos=3050;
	liftDa=false;
	joystick=128;
	//	stopTask(raiseOrLowerFork);
	//	motor[fork]=-55;
	forward(128,250);
	//	breakDrive();
	while(SensorValue[armPotentiometerL]<2900);
	forward(70,400);
	//	joystick=-128;
	wait1Msec(50);
	//	motor[fork]=-15;
	joystick=128;
	//	joystickf=0;
	//breakDrive();

	motor[roller]=-128;
	//	SensorValue[solDump]=1;

	//dump buckyballs


	wait1Msec(1200);
	motor[backRight]=motor[frontRight]=90;
	motor[backLeft]=motor[frontLeft]=35;

	//align with wall

	while(!SensorValue[wall]);
	if(!SensorValue[GOL])
	{
		motor[backRight]=motor[frontRight]=30;
		motor[backLeft]=motor[frontLeft]=70;
	}
	while(!(SensorValue[wall]&SensorValue[GOL]));
	motor[backLeft]=motor[frontLeft]=motor[backRight]=motor[frontRight]=0;//turnc

	motor[roller]=0;
	//	eyeBm=false;
	//	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	backward(128,300);
	joystick=-128;
	backward(128,400);


	while(SensorValue[armPotentiometerL]>1450);
	wait1Msec(100);
	while(SensorValue[armPotentiometerL]>1380);
	joystick=0;
	//	stopTask(raiseOrLowerArm);
	motor[armmotL]=motor[armmotR]=-5;
	SensorValue[solDump]=0;
	//	kMaxPosf=1200;
	//joystickf=128;
	backward(128,900);
	joystick=128;
	while(SensorValue[armPotentiometerL]<2200);
	joystick=0;
	turn(128,15);
	forward(128,300);
	backward(128,400);
	joystick=-128;
	turn(128,90);
	joystick=0;


}
void GoEatB()
{
	startTask(raiseOrLowerArm);
	//startTask(raiseOrLowerFork);
	liftDa=false;
	SensorValue[solDump]=0;
	kMaxPos=1700;
	joystick=128;
	wait1Msec(200);
	joystick=-128;
	//initialize

	motor[roller]=127;
	backward(80,200);
	wait1Msec(250);
	joystick=0;
	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	turn(128,160);
	while(!(SensorValue[GOL]|SensorValue[GOR])){}

	forward(127,300);
	joystickf=128;
	joystick=0;

	forward(128,940);
	motor[roller]=80;
	forward(128,230);
	//	kMaxPosf=1200;
	//	joystickf=0;
	kMaxPos=3050;
	liftDa=false;
	joystick=128;
	//	stopTask(raiseOrLowerFork);
	//	motor[fork]=-55;
	forward(128,250);
	//	breakDrive();
	while(SensorValue[armPotentiometerL]<2900);
	forward(70,400);
	//	joystick=-128;
	wait1Msec(50);
	//	motor[fork]=-15;
	joystick=128;
	//	joystickf=0;
	//breakDrive();

	motor[roller]=-128;
	//	SensorValue[solDump]=1;

	//dump buckyballs


	wait1Msec(1200);
	motor[backRight]=motor[frontRight]=35;
	motor[backLeft]=motor[frontLeft]=90;

	//align with wall

	while(!SensorValue[GOL]);
	if(!SensorValue[wall])
	{
		motor[backRight]=motor[frontRight]=70;
		motor[backLeft]=motor[frontLeft]=30;
	}
	while(!(SensorValue[wall]&SensorValue[GOL]));
	motor[backLeft]=motor[frontLeft]=motor[backRight]=motor[frontRight]=0;//turnc

	motor[roller]=0;
	//	eyeBm=false;
	//	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	backward(128,300);
	joystick=-128;
	backward(128,400);


	while(SensorValue[armPotentiometerL]>1450);
	wait1Msec(100);
	while(SensorValue[armPotentiometerL]>1380);
	joystick=0;
	//	stopTask(raiseOrLowerArm);
	motor[armmotL]=motor[armmotR]=-5;
	SensorValue[solDump]=0;
	//	kMaxPosf=1200;
	//joystickf=128;
	backward(128,900);
	joystick=128;
	while(SensorValue[armPotentiometerL]<2200);
	joystick=0;
	turn(128,-15);
	forward(128,300);
	backward(128,400);
	joystick=-128;
	turn(128,-90);
	joystick=0;


}

void GoRH_Hang()
{
	startTask(raiseOrLowerFork);
	startTask(raiseOrLowerArm);
	startTask(openFork);


	motor[roller]=0;//intake
	//	startTask(raiseOrLowerArm);
	//	startTask(raiseOrLowerFork);
	openup=true;
	kMaxPosf=2500+fpc;
	joystickf=-128
	joystick=0;
	////joystick=-128;
	wait1Msec(350);
	//	joystickf=0;

	//	motor[fork]=-25;
	backward(128,200);
	backward(70,170);

	//	motor[fork]=0;
	SensorValue[solDump]=0;
	joystickf=128;
	//	backward(80,300);
	while(SensorValue[forkPot]<2350+fpc);
	joystickf=-128;
	//	backward(60,400);
	kMaxPos=2300;
	joystick=128;
	while(SensorValue[forkPot]>450+fpc);
	//	joystickf=0;

	backward(90,625);
	kMaxPosf=1400+fpc;
	joystickf=128;
	while(SensorValue[forkPot]<1300+fpc);
	//	backward(80,100);
	//	breakDrive();
	joystickf=0;
	//	stopTask(raiseOrLowerFork);
	motor[fork]=0;
	turn(128,90);
	motor[backLeft]=motor[backRight]=128;
	motor[frontLeft]=motor[frontRight]=128;
	wait1Msec(250);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;


	//	backward(128,400);
	//wait1Msec(400);
	//forward(128,250);

	SensorValue[solBig]=1;
	kMaxPos=2800;
	motor[roller]=-128;
	//forward(128,100);
	wait1Msec(300);
	//	SensorValue[solBig]=0;
	kMaxPosf=2000+fpc;
	joystickf=128;
	//	while(SensorValue[forkPot]<1200+fpc);
	//	nPositionToHoldf=500;

	turn(128,-75);
	//	SensorValue[solBreak]=1;
	forward(128,600);
	joystick=0;
	//	stopTask(raiseOrLowerArm);
	motor[armmotL]=motor[armmotR]=0;
	//forward(128,2350);
	//	SensorValue[solBig]=1;
	turn(128,-90);
	while(!(SensorValue[GOL]|SensorValue[GOR])){}

	forward(128,600);
	turn(128,30);
	stopTask(raiseOrLowerArm);
	//	stopTask(raiseOrLowerArm);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=50;
	wait1Msec(400);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	motor[armmotL]=motor[armmotR]=128;
	while(SensorValue[armPotentiometerL]<2955);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=-70;
	wait1Msec(200);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	motor[armmotL]=motor[armmotR]=128;
	SensorValue[solShift]=1;
	kMaxPosf=1700+fpc;
	joystickf=128;
	wait1Msec(200);
	motor[frontLeft] = 	motor[frontRight] = motor[backRight] =	motor[backLeft] =128;
	motor[armmotL]=motor[armmotR]=-60;
	lastwashang=true;
	wait1Msec(400);
	kMaxPosf=2100+fpc;


	string ampt,ddhang,lklk;
	while(SensorValue[armPotentiometerL]>2450){}
	wait1Msec(100);
	while(SensorValue[armPotentiometerL]>2450){}
	SensorValue[solLock]=true;
	joystickf=0;
	motor[armmotL]=motor[armmotR]=0;
	motor[frontLeft] = 	motor[frontRight] = motor[backRight] =	motor[backLeft] =0;


}
void GoBH_Hang()
{
	startTask(raiseOrLowerFork);
	startTask(raiseOrLowerArm);
	startTask(openFork);


	motor[roller]=0;//intake
	//	startTask(raiseOrLowerArm);
	//	startTask(raiseOrLowerFork);
	openup=true;
	kMaxPosf=2500+fpc;
	joystickf=-128
	joystick=0;
	////joystick=-128;
	wait1Msec(350);
	//	joystickf=0;

	//	motor[fork]=-25;
	backward(128,200);
	backward(70,170);

	//	motor[fork]=0;
	SensorValue[solDump]=0;
	joystickf=128;
	//	backward(80,300);
	while(SensorValue[forkPot]<2350+fpc);
	joystickf=-128;
	//	backward(60,400);
	kMaxPos=2300;
	joystick=128;
	while(SensorValue[forkPot]>450+fpc);
	//	joystickf=0;

	backward(90,625);
	kMaxPosf=1400+fpc;
	joystickf=128;
	while(SensorValue[forkPot]<1300+fpc);
	//	backward(80,100);
	//	breakDrive();
	joystickf=0;
	//	stopTask(raiseOrLowerFork);
	motor[fork]=0;
	turn(128,-90);
	motor[backLeft]=motor[backRight]=128;
	motor[frontLeft]=motor[frontRight]=128;
	wait1Msec(250);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;


	//	backward(128,400);
	//wait1Msec(400);
	//forward(128,250);

	SensorValue[solBig]=1;
	kMaxPos=2800;
	motor[roller]=-128;
	//forward(128,100);
	wait1Msec(300);
	//	SensorValue[solBig]=0;
	kMaxPosf=2000+fpc;
	joystickf=128;
	//	while(SensorValue[forkPot]<1200+fpc);
	//	nPositionToHoldf=500;

	turn(128,75);
	//	SensorValue[solBreak]=1;
	forward(128,600);
	joystick=0;
	//	stopTask(raiseOrLowerArm);
	motor[armmotL]=motor[armmotR]=0;
	//forward(128,2350);
	//	SensorValue[solBig]=1;
	turn(128,90);
	while(!(SensorValue[GOL]|SensorValue[GOR])){}

	forward(128,600);
	turn(128,30);
	stopTask(raiseOrLowerArm);
	//	stopTask(raiseOrLowerArm);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=50;
	wait1Msec(400);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	motor[armmotL]=motor[armmotR]=128;
	while(SensorValue[armPotentiometerL]<2955);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=-70;
	wait1Msec(200);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	motor[armmotL]=motor[armmotR]=128;
	SensorValue[solShift]=1;
	kMaxPosf=1700+fpc;
	joystickf=128;
	wait1Msec(200);
	motor[frontLeft] = 	motor[frontRight] = motor[backRight] =	motor[backLeft] =128;
	motor[armmotL]=motor[armmotR]=-60;
	lastwashang=true;
	wait1Msec(400);
	kMaxPosf=2100+fpc;


	string ampt,ddhang,lklk;
	while(SensorValue[armPotentiometerL]>2450){}
	wait1Msec(100);
	while(SensorValue[armPotentiometerL]>2450){}
	SensorValue[solLock]=true;
	joystickf=0;
	motor[armmotL]=motor[armmotR]=0;
	motor[frontLeft] = 	motor[frontRight] = motor[backRight] =	motor[backLeft] =0;


}

void turn(int power,float angle)
{
	int decidegrees = -10*angle;
	int error = 15;

	//While the absolute value of the gyro is less than the desired rotation - 100...
	if(decidegrees>=0)
	{
		decidegrees= (float)decidegrees+(decidegrees/900)*gyrocorrection;
		SensorValue[gyro]=0;
		while(abs(SensorValue[gyro]) < decidegrees*0.6 )
		{
			motor[frontRight] = power;
			motor[backRight] = power;
			motor[frontLeft] = -power;
			motor[backLeft] = -power;
		}
		clearTimer(T3);
		while((SensorValue[gyro] > decidegrees + error || SensorValue[gyro] < decidegrees - error)&time1[T3]<500)
		{
			if(SensorValue[gyro] < decidegrees)
			{
				motor[frontRight] = 30;
				motor[backRight] = 30;
				motor[frontLeft] = -30;
				motor[backLeft] = -30;
			}
			else
			{
				motor[frontRight] = -30;
				motor[backRight] = -30;
				motor[frontLeft] = 30;
				motor[backLeft] = 30;
			}
		}
	}
	else
	{

		decidegrees=decidegrees-gyrocorrection;
		SensorValue[gyro]=0;
		wait1Msec(10);
		while(SensorValue[gyro] > decidegrees*0.6 )
		{
			wait1Msec(10);
			motor[frontRight] = -power;
			motor[backRight] = -power;
			motor[frontLeft] = power;
			motor[backLeft] = power;
		}
		clearTimer(T3);
		while((SensorValue[gyro] > decidegrees + error || SensorValue[gyro] < decidegrees - error)&time1[T3]<500)
		{
			if(SensorValue[gyro] < decidegrees)
			{
				motor[frontRight] = 40;
				motor[backRight] = 40;
				motor[frontLeft] = -40;
				motor[backLeft] = -40;
			}
			else
			{
				motor[frontRight] = -40;
				motor[backRight] = -40;
				motor[frontLeft] = 40;
				motor[backLeft] = 40;
			}
		}

	}
	motor[frontRight] = 0;
	motor[backRight] = 0;
	motor[frontLeft] = 0;
	motor[backLeft] = 0;

}

void turnPCS90(int power,float angle)
{
	int decidegrees = -10*angle;
	int error = 10;
	float const kt=0.1;
	float const kit=0.025;
	float const kdt=0.020;
	float errort,outpower;
	long Ierr=0;
	int Derr=0;
	int lastInput=0;
	int timewait;
	bool vv=true;
	bool stillfinding=true;
	//	string PPP,III,DDD,gyrooo,timeee,powerrr;
	//	float Pp,Ii,Dd;
	//While the absolute value of the gyro is less than the desired rotation - 100...
	if(decidegrees>=0)
	{
		vv=true;
		decidegrees=(float)decidegrees+(decidegrees/900)*gyrocorrection;
		SensorValue[gyro]=0;
		while(abs(SensorValue[gyro]) < decidegrees-200 )
		{
			motor[frontRight] = power;
			motor[backRight] = power;
			motor[frontLeft] = -power;
			motor[backLeft] = -power;
		}
		clearTimer(T3);
		timewait=10*power;
		while(time1[T3]<timewait&stillfinding)
		{
			errort=-(decidegrees-SensorValue[gyro]);
			if(vv)
				outpower=kt*errort;
			else{
				outpower=4*kt*errort+kit*Ierr-kdt*Derr;
				Ierr+=errort;}
			Derr=lastInput-SensorValue[gyro];

			if(outpower>0)
				outpower=(float)(outpower*0.675)+25;
			if(outpower<0)
				outpower=(float)(outpower*0.675)-25;

			motor[frontRight] = -outpower;
			motor[backRight] = -outpower;
			motor[frontLeft] = outpower;
			motor[backLeft] = outpower;
			lastInput=SensorValue[gyro];
			wait1Msec(50);
			if(abs(decidegrees-SensorValue[gyro]) <10)
				Ierr=0;

			if(vv&abs(decidegrees-SensorValue[gyro]) <20)
			{
				vv=false;
				//	wait1Msec(40);
				Ierr=0;
			}
			if(abs(errort)<error&abs(Derr)<3)
				stillfinding=false;

		}
	}
	else
	{
		vv=true;
		decidegrees=decidegrees-gyrocorrection;
		SensorValue[gyro]=0;
		wait1Msec(10);
		while(SensorValue[gyro] > (float)decidegrees+200 )
		{
			motor[frontRight] = -power;
			motor[backRight] = -power;
			motor[frontLeft] = power;
			motor[backLeft] = power;
		}

		clearTimer(T3);
		timewait=10*power;
		while((time1[T3]<timewait)&stillfinding)
		{
			errort=decidegrees-SensorValue[gyro];
			if(vv)
				outpower=kt*errort;
			else{
				outpower=4*kt*errort+kit*Ierr-kdt*Derr;
				Ierr+=errort;}
			Derr=lastInput-SensorValue[gyro];

			if(outpower>0)
				outpower=(float)(outpower*0.675)+25;
			if(outpower<0)
				outpower=(float)(outpower*0.675)-25;

			motor[frontRight] = outpower;
			motor[backRight] = outpower;
			motor[frontLeft] = -outpower;
			motor[backLeft] = -outpower;
			lastInput=SensorValue[gyro];
			wait1Msec(50);
			if(abs(decidegrees-SensorValue[gyro]) <10)
				Ierr=0;

			if(vv&decidegrees-SensorValue[gyro] > -20)
			{
				vv=false;
				//	wait1Msec(40);
				Ierr=0;
			}
			if(abs(errort)<error&abs(Derr)<3)
				stillfinding=false;

			/*			Pp=errort*kt
			Ii=Ierr*kit;
			Dd=Derr*kdt;

			sprintf(PPP, " %2.5f%c", Pp );
			sprintf(III, " %2.5f%c", Ii);
			sprintf(DDD, " %2.5f%c", Dd);
			sprintf(powerrr, " %3.0f%c", motor[backLeft]);
			sprintf(timeee, " %4.0f%c", time1[T4]);
			sprintf(gyrooo, " %5.0f%c", SensorValue[gyro]);
			writeDebugStream(PPP);
			writeDebugStream(III);
			writeDebugStream(DDD);
			writeDebugStream(powerrr);
			writeDebugStream(timeee);
			writeDebugStreamLine(gyrooo);*/


		}
	}
	motor[frontRight] = 0;
	motor[backRight] = 0;
	motor[frontLeft] = 0;
	motor[backLeft] = 0;
}


void turnPCS45(int power,float angle)
{
	int decidegrees = -10*angle;
	int error = 10;
	float const kt=0.1;
	float const kit=0.025;
	float const kdt=0.020;
	float errort,outpower;
	long Ierr=0;
	int Derr=0;
	int lastInput=0;
	int timewait;
	bool vv=true;
	bool stillfinding=true;
	//string PPP,III,DDD,gyrooo,timeee,powerrr;
	//	float Pp,Ii,Dd;
	//While the absolute value of the gyro is less than the desired rotation - 100...
	if(decidegrees>=0)
	{
		vv=true;
		decidegrees=(float)decidegrees+(decidegrees/900)*gyrocorrection;
		SensorValue[gyro]=0;
		while(abs(SensorValue[gyro]) < decidegrees-200 )
		{
			motor[frontRight] = power;
			motor[backRight] = power;
			motor[frontLeft] = -power;
			motor[backLeft] = -power;
		}
		clearTimer(T3);
		timewait=8*power;
		while(time1[T3]<timewait*stillfinding)
		{
			errort=-(decidegrees-SensorValue[gyro]);
			if(vv)
				outpower=kt*errort;
			else{
				outpower=4*kt*errort+kit*Ierr-kdt*Derr;
				Ierr+=errort;}
			Derr=lastInput-SensorValue[gyro];

			if(outpower>0)
				outpower=(float)(outpower*0.675)+25;
			if(outpower<0)
				outpower=(float)(outpower*0.675)-25;

			motor[frontRight] = -outpower;
			motor[backRight] = -outpower;
			motor[frontLeft] = outpower;
			motor[backLeft] = outpower;
			lastInput=SensorValue[gyro];
			wait1Msec(50);
			if(abs(decidegrees-SensorValue[gyro]) <10)
				Ierr=0;

			if(vv&abs(decidegrees-SensorValue[gyro]) <20)
			{
				vv=false;
				//	wait1Msec(40);
				Ierr=0;
			}
			if(abs(errort)<error&abs(Derr)<3)
				stillfinding=false;

		}
	}
	else
	{
		vv=true;
		decidegrees=decidegrees-gyrocorrection;
		SensorValue[gyro]=0;
		wait1Msec(10);
		while(SensorValue[gyro] > (float)decidegrees+200 )
		{
			motor[frontRight] = -power;
			motor[backRight] = -power;
			motor[frontLeft] = power;
			motor[backLeft] = power;
		}

		clearTimer(T3);
		timewait=8*power;
		while(time1[T3]<timewait&stillfinding)
		{
			errort=decidegrees-SensorValue[gyro];
			if(vv)
				outpower=kt*errort;
			else{
				outpower=4*kt*errort+kit*Ierr-kdt*Derr;
				Ierr+=errort;}
			Derr=lastInput-SensorValue[gyro];

			if(outpower>0)
				outpower=(float)(outpower*0.675)+25;
			if(outpower<0)
				outpower=(float)(outpower*0.675)-25;

			motor[frontRight] = outpower;
			motor[backRight] = outpower;
			motor[frontLeft] = -outpower;
			motor[backLeft] = -outpower;
			lastInput=SensorValue[gyro];
			wait1Msec(50);
			if(abs(decidegrees-SensorValue[gyro]) <10)
				Ierr=0;

			if(vv&decidegrees-SensorValue[gyro] > -20)
			{
				vv=false;
				//	wait1Msec(40);
				Ierr=0;
			}
			if(abs(errort)<error&abs(Derr)<3)
				stillfinding=false;

			/*			Pp=errort*kt
			Ii=Ierr*kit;
			Dd=Derr*kdt;

			sprintf(PPP, " %2.5f%c", Pp );
			sprintf(III, " %2.5f%c", Ii);
			sprintf(DDD, " %2.5f%c", Dd);
			sprintf(powerrr, " %3.0f%c", motor[backLeft]);
			sprintf(timeee, " %4.0f%c", time1[T4]);
			sprintf(gyrooo, " %5.0f%c", SensorValue[gyro]);
			writeDebugStream(PPP);
			writeDebugStream(III);
			writeDebugStream(DDD);
			writeDebugStream(powerrr);
			writeDebugStream(timeee);
			writeDebugStreamLine(gyrooo);*/


		}
	}
	motor[frontRight] = 0;
	motor[backRight] = 0;
	motor[frontLeft] = 0;
	motor[backLeft] = 0;
}


void forward(int power,int howfar)
{
	nMotorEncoder[backRight] = 0;
	nMotorEncoder[backLeft] = 0;
	while(howfar-nMotorEncoder[backRight]>5 | howfar-nMotorEncoder[backLeft]>5)
	{
		if(nMotorEncoder[backRight] < howfar ){
			motor[backRight] = power;
			motor[frontRight] = power;}
		else {
			motor[backRight] = 0;
			motor[frontRight] = 0;}

		if(nMotorEncoder[backLeft] < howfar ){
			motor[backLeft] = power;
			motor[frontLeft] = power;}
		else {
			motor[backLeft] = 0;
			motor[frontLeft] = 0;}
	}
	motor[frontRight] = 0;
	motor[backRight] = 0;
	motor[frontLeft] = 0;
	motor[backLeft] = 0;
}

void backward(int power,int howfar)
{
	nMotorEncoder[backRight] = 0;
	nMotorEncoder[backLeft]  = 0;
	while(nMotorEncoder[backRight]+howfar>10 | nMotorEncoder[backLeft]+howfar>10)
	{
		if(nMotorEncoder[backRight] > -howfar ){
			motor[backRight] = -power;
			motor[frontRight] = -power;}
		else if(nMotorEncoder[backRight]<-howfar){
			motor[backRight] = 0;
			motor[frontRight] = 0;}

		if(nMotorEncoder[backLeft] > -howfar ){
			motor[backLeft] = -power;
			motor[frontLeft] = -power;}
		else if(nMotorEncoder[backLeft]<-howfar){
			motor[backLeft] = 0;
			motor[frontLeft] = 0;}
	}
	motor[frontRight] = 0;
	motor[backRight] = 0;
	motor[frontLeft] = 0;
	motor[backLeft] = 0;
}

void autohang()//rewrite
{
	stopTask(raiseOrLowerArm);
	SensorValue[solShift]=1;
	motor[backLeft]=motor[backRight]=0;
	while(SensorValue[armPotentiometerL]<3050)
		motor[armmotL]=motor[armmotR]=128;
	SensorValue[solBig]=1;
	motor[frontLeft]=motor[frontRight]=128;
	wait1Msec(600);
	motor[armmotL]=motor[armmotR]=0;
	motor[frontLeft]=motor[frontRight]=0;

	motor[armmotL]=motor[armmotR]=-128;
	while(SensorValue[armPotentiometerL]>1380)
	{
		motor[backLeft]=motor[backRight]=128;
	}
	wait1Msec(200);
	motor[backLeft]=motor[backRight]=100;
	wait1Msec(200);
	motor[backLeft]=motor[backRight]=80;
	wait1Msec(200);
	motor[backLeft]=motor[backRight]=60;
	wait1Msec(200);
	motor[backLeft]=motor[backRight]=40;
	wait1Msec(200);
	motor[armmotL]=motor[armmotR]=-10;
	SensorValue[solBig]=0;
	motor[backLeft]=motor[backRight]=20;
	wait1Msec(200);
	motor[backLeft]=motor[backRight]=10;
	SensorValue[solBig]=0;
	wait1Msec(1000);
}


//-----------------------------------------------------------------------------------


task shift()
{
	while(true){

		if(vexRT[Btn8R])//hangmode
		{
			while(vexRT[Btn8R]){}
			if(prehangmode){
				hangmode=true;
				prehangmode=false;
				liftDa=true;
				SensorValue[solShift]=1;
				SensorValue[solLock]=1;
				stopTask(raiseOrLowerArm);
			}
			if(!prehangmode)
				prehangmode=true;
		}
		if(vexRT[Btn7U])
		{
			while(vexRT[Btn7U]);
			SensorValue[solBreak] =!SensorValue[solBreak];
		}
		if(vexRT[Btn8U])         // If button 6U (upper right shoulder button) is pressed:
		{
			//		while(vexRT[Btn8U]);
			if(!hangmode&!prehangmode)
				SensorValue[solBig] = 1;
			if(prehangmode)
				SensorValue[solBig] = !SensorValue[solBig] ;
			while(vexRT[Btn8U]);
		}
		else
		{
			if(!hangmode&!prehangmode)
				SensorValue[solBig] = 0;
		}

	}
}
task openFork()
{
	bool openupsav;
	while(1)
	{
		if(!openup)//action
		{
			SensorValue[fork1]=0;
			wait1Msec(200);
			SensorValue[fork2]=0;
		}
		else
		{
			SensorValue[fork2]=1;
			//	wait1Msec(200);
			SensorValue[fork1]=1;
		}
		openupsav=openup;
		//		while(openup==openupsav){}
	}
}


task masterreset()
{
	while(1){
		while(vexRT[Btn8D] == 1){}
		while(vexRT[Btn8D] == 0){}
		stopTask(raiseOrLowerArm);
		stopTask(raiseOrLowerFork);
		stopTask(usercontrol);
		stopTask(shift);
		stopTask(autoslection);
		stopTask(openFork);
		stopTask(driveThisShit);
		startTask(driveThisShit);
		startTask(raiseOrLowerArm);
		startTask(raiseOrLowerFork);
		startTask(usercontrol);
		startTask(shift);
		startTask(autoslection);
		startTask(openFork);
		kMaxPos=3070;
		kMaxPosf=2500+fpc;
		kMotorSpeedUp=128;
		joystick=0;
		hangmode=false;
		liftDa=false;
		openup=false;
		prehangmode=false;
		SensorValue[solBig]=0;
		SensorValue[solShift]=0;
		SensorValue[solLock]=0;
	}
}
//-----------------------------------------------------------------------------------

task raiseOrLowerArm()
{
	const int kSlowSpeedRange = 50;
	const int kMinPos = 1355;

	const int kSlowSpeedPosLowering = kMinPos + kSlowSpeedRange;
	const int kSlowSpeedRaising     = kMaxPos - kSlowSpeedRange;

	const int kMotorSpeedUpa   = +127;
	const int kMotorSpeedDown = -127;
	float ITerm;
	int error;
	const float outMax=128,outMin=-128;
	bool bLastUpdateWasButtonPress = false;
	bool bButtonsHaveBeenPressed   = false;

	while(true)
	{
		while(liftDa){}
		if (joystick <= -90)// button is puchsed indicating ARM should be lowered
		{
			if (SensorValue[armPotentiometerL] < kMinPos)
			{
				motor[armmotL] = 0;
				motor[armmotR] = 0;// Arm is fully lowered. Stop the motor
			}
			else if (SensorValue[armPotentiometerL] < kSlowSpeedPosLowering){
				motor[armmotL] = kMotorSpeedDown / 2;
				motor[armmotR] = kMotorSpeedDown / 2;
			}
			else{
				motor[armmotL] = kMotorSpeedDown;
				motor[armmotR] = kMotorSpeedDown;
			}
			nPositionToHold = (SensorValue[armPotentiometerL]+10);
			bLastUpdateWasButtonPress = true;
		}

		else if (joystick >= 90)// button is puchsed indicating ARM should be raised
		{
			if (SensorValue[armPotentiometerL] > kMaxPos)
			{
				motor[armmotL] = 10;
				motor[armmotR] = 10;// Arm is fully raised. Stop the motor
			}
			else if (SensorValue[armPotentiometerL] > kSlowSpeedRaising){
				motor[armmotL] = kMotorSpeedUpa / 2;
				motor[armmotR] = kMotorSpeedUpa / 2;
			}
			else{
				motor[armmotL] = kMotorSpeedUpa;
				motor[armmotR] = kMotorSpeedUpa;
			}

			nPositionToHold = (SensorValue[armPotentiometerL]+10);
			bLastUpdateWasButtonPress = true;
		}


		else// No buttons are pushed.
		{


			if (bLastUpdateWasButtonPress) // A button has just been released.- Remember the position.-- Stop motor
			{
				bLastUpdateWasButtonPress = false;
				if (nPositionToHold < kMinPos)
					nPositionToHold = kMinPos;
				else if (nPositionToHold > kMaxPos)
					nPositionToHold = kMaxPos;
				motor[armmotL] = 0;
				motor[armmotR] = 0;
				clearTimer(T4);
				bButtonsHaveBeenPressed = true;
			}
			else if (bButtonsHaveBeenPressed)
			{
				int SampleTime=10;
				long lastInput;
				if(time1[T4]>=SampleTime)
				{
					float input = SensorValue[armPotentiometerL];
					error = nPositionToHold - input;

					ITerm+= (ki * error);
					ITerm= 0;
					if(ITerm > outMax) ITerm= outMax;
					else if(ITerm < outMin) ITerm= outMin;
					if(ki==0) ITerm=0;
					float dInput = (input - lastInput);
					/*Compute PID Output*/
					float output = kp * error + ITerm- kd * dInput;
					if(output > outMax) output = outMax;
					else if(output < outMin) output = outMin;
					motor[armmotL]= motor[armmotR]= output;
					lastInput = input;
					clearTimer(T4);
				}
			}
			else
			{
				//		motor[armmotL]= motor[armmotR]= 0;
			}
		}
	}
}


//-----------------------------------------------------------------------------------



task raiseOrLowerFork()
{

	const int kMinPosf = 400+fpc;
	float error,input;
	const int kSlowSpeedRange = 40;
	const int kSlowSpeedLowering = kMinPosf + kSlowSpeedRange;
	const int kSlowSpeedRaising     = kMaxPosf - kSlowSpeedRange;


	const float outMax=128,outMin=-128;

	float ITerm;
	bool bLastUpdateWasButtonPress = false;
	bool bButtonsHaveBeenPressed   = false;
	while(true)
	{
		if (joystickf<-90)// button is puchsed indicating ARM should be lowered
		{
			if (SensorValue[forkPot] <= kMinPosf)
			{
				motor[fork] = -10; // Arm is fully lowered. Stop the motor
			}
			else if (SensorValue[forkPot] <= kSlowSpeedLowering)
				motor[fork] =-kMotorSpeedUp / 2;
			else
				motor[fork] = -kMotorSpeedUp;
			nPositionToHoldf = SensorValue[forkPot];
			bLastUpdateWasButtonPress = true;
		}

		else if (joystickf>90)// button is puchsed indicating ARM should be raised
		{
			if (SensorValue[forkPot] >= kMaxPosf)
			{
				motor[fork] = +10;// Arm is fully raised. Stop the motor
			}
			else if (SensorValue[forkPot] >= kSlowSpeedRaising)
				motor[fork] = kMotorSpeedUp / 2;
			else
				motor[fork] = kMotorSpeedUp;
			nPositionToHoldf = SensorValue[forkPot];
			bLastUpdateWasButtonPress = true;
		}

		else  // No buttons are pushed.
		{
			if (bLastUpdateWasButtonPress) // A button has just been released.- Remember the position.-- Stop motor
			{
				bLastUpdateWasButtonPress = false;
				if (nPositionToHoldf < kMinPosf)
					nPositionToHoldf = kMinPosf;
				else if (nPositionToHoldf > kMaxPosf)
					nPositionToHoldf = kMaxPosf;
				motor[fork] = 0;
				motor[fork] = 0;
				clearTimer(T2);
				bButtonsHaveBeenPressed = true;
			}
			else if (bButtonsHaveBeenPressed)
			{
				unsigned long now = time1[T2];
				long lastInput;
				unsigned long lastTime;
				unsigned long SampleTime=10;

				unsigned long timeChange = (now - lastTime);
				if(timeChange>=SampleTime)
				{
					input = SensorValue[forkPot];
					error = -(nPositionToHoldf - input);
					ITerm+= (ki * error);
					if(ITerm > outMax) ITerm= outMax;
					else if(ITerm < outMin) ITerm= outMin;
					if(kif==0) ITerm=0;

					float dInput = (input - lastInput);
					/*Compute PID Output*/
					float output = -(kpf * error + ITerm - kdf * dInput);
					if(output > outMax) output = outMax;
					else if(output < outMin) output = outMin;
					motor[fork]= output;
					lastInput = input;
					lastTime = now;
				}
			}
			else
			{
			}

		}
	}
}




void turnthenfollow(int power,int howfar,int approx)
{
	int degturned;
	//	const int b=150;//lengh factor of the robot
	SensorValue[gyro]=0;


	wait1Msec(100);
	while(!eyeL&-SensorValue[gyro]>approx*15)//eyehits line)		//turn left
	{
		motor[backLeft]=motor[frontLeft]=-power;
		motor[backRight]=motor[frontRight]=power;
	}
	if(eyeL)
	{
		motor[backLeft]=motor[frontLeft]=15;
		motor[backRight]=motor[frontRight]=-15;
		wait1Msec(100);
		motor[backLeft]=motor[frontLeft]=0;
		motor[backRight]=motor[frontRight]=0;//brief break
		nMotorEncoder[backLeft]=nMotorEncoder[backRight]=0;
		degturned=SensorValue(gyro);//read gyro
	}
	else if(!eyeL&-SensorValue[gyro]<=approx*15)
	{
		while(!eyeL&-SensorValue[gyro]<approx*5)//eyehits line)		//turn left
		{
			motor[backLeft]=motor[frontLeft]=power;
			motor[backRight]=motor[frontRight]=-power;
		}
		if(eyeL)
		{
			motor[backLeft]=motor[frontLeft]=-15;
			motor[backRight]=motor[frontRight]=15;
			wait1Msec(100);
			motor[backLeft]=motor[frontLeft]=0;
			motor[backRight]=motor[frontRight]=0;//brief break
			nMotorEncoder[backLeft]=nMotorEncoder[backRight]=0;
			degturned=SensorValue(gyro);//read gyro
		}
	}
	SensorValue[solBreak]=0;
	//	forwardLine(power,howfar);//calc corrected distance



}
int forwardLine(int power,int howfar,int lastinput)//howfar uses encoder
{
	float ITerm;
	int error;
	//int lastInput;
	const float outMax=128,outMin=-128;
	nMotorEncoder[backLeft]=nMotorEncoder[backRight]=0;
	clearTimer(T3);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=power;
	//	motor[frontLeft]=motor[frontRight]=power;
	while((nMotorEncoder[backLeft]+nMotorEncoder[backRight])/2<howfar)
	{
		//motor[frontLeft]=power-lfc;//don't forget the back wheels
		//	motor[frontRight]=power+lfc;

		motor[frontLeft]=motor[backLeft]=power-lfc;//don't forget the back wheels
		motor[frontRight]=motor[backRight]=power+lfc;
		long SampleTime=10;
		if(!eyeL&eyeM&!eyeR)//on track, clear stuff
		{
			ITerm=0;
			lfc=0;//line follower correction zero
		}
		else if(!(!eyeL&eyeM&!eyeR)&time1[T3]>=SampleTime)//off track, then react. sample time minaly for motor reaction delay
		{
			static float input;
			if(!eyeL&!eyeM&!eyeR&(lastInput==-4|lastInput==-8))//to much too the right
				input = -8;
			if(eyeL&!eyeM&!eyeR)//to much too the right
				input = -4;//give a negative
			if(eyeL&eyeM&!eyeR)
				input = -1;
			if(!eyeL&eyeM&!eyeR)//
				input = 0;//perfect
			if(eyeL&eyeM&eyeR)//
				input = 0;//horizontal line
			if(!eyeL&eyeM&eyeR)
				input = 1;
			if(!eyeL&!eyeM&eyeR)
				input = 4;
			if(!eyeL&!eyeM&!eyeR&(lastInput==4|lastInput==8))
				input = 8;


			error = - input;

			ITerm+= kil * error;//should be the longer time refreshes, the better
			if(ITerm > outMax) ITerm= outMax;
			else if(ITerm < outMin) ITerm= outMin;
			//		float dInput = (input - lastInput)/timeChange;
			/*Compute PID Output*/
			float dInput=0;
			float output = kpl * error + ITerm - kdl * dInput;
			if(output > outMax) output = outMax;
			else if(output < outMin) output = outMin;
			lfc= output;
			lastInput = input;
			clearTimer(T3);
		}
	}
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	return lastinput;
	//	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
}

void securedDump()
{
	//int gyromov;
	//	SensorValue[gyro]=0;
	kMaxPos=2900;
	joystick=128;
	while(SensorValue[armPotentiometerL]<2800);
	forward(128,350);
	motor[roller]=-128;
	wait1Msec(2000);
	backward(128,300);
	motor[roller]=0;
	while(SensorValue[armPotentiometerL]>1400){
		joystick=-128;}
	//	gyromov=SensorValue[gyro]/10;
	//turn(40,gyromov);

}



void breakDrive()
{
	int speed;
	nMotorEncoder[backLeft]=0;
	wait1Msec(10);
	int initspeed=nMotorEncoder[backLeft];
	int power=-initspeed*1000;
	speed=initspeed;
	motor[frontRight] =	motor[backRight] =motor[frontLeft] =motor[backLeft] = power;
	clearTimer(T4);
	while(abs(speed)>1)
	{
		speed=nMotorEncoder[backLeft];
		wait1Msec(20);
		nMotorEncoder[backLeft]=0;
		if(((speed<=0) & (initspeed>0))|((speed>=0) & (initspeed<0)))
		{
			motor[frontRight] =	motor[backRight] =motor[frontLeft] =motor[backLeft] = 0;
			break;
		}
		if(time1[T4]>300)
			break;
	}
	motor[frontRight] =	motor[backRight] =motor[frontLeft] =motor[backLeft] = 0;
}


void breakDrivet()
{
	int speedl,speedr,initg;
	initg=SensorValue[gyro];
	wait1Msec(20);
	int initspeedl=SensorValue[gyro]-initg;
	int initspeedr=initg-SensorValue[gyro];//left neg
	int powerl=initspeedl*1000;
	int powerr=initspeedr*1000;
	speedr=initspeedr;
	speedl=initspeedl;
	motor[frontRight] =	motor[backRight] = powerr;
	motor[frontLeft] =motor[backLeft] =powerl;
	clearTimer(T3);
	while((abs(speedl)>1|abs(speedr)>1)&time1[T3]<300)
	{
		initg=SensorValue[gyro];
		wait1Msec(20);
		speedl=SensorValue[gyro]-initg;
		speedr=initg-SensorValue[gyro];//left neg
		if(((speedl<=0) & (initspeedl>0))|((speedl>=0) & (initspeedl<0)))
		{
			motor[frontLeft] =motor[backLeft] = 0;
		}
		if(((speedr<=0) & (initspeedr>0))|((speedr>=0) & (initspeedr<0)))
		{
			motor[frontRight] =	motor[backRight]=0;
		}

	}
	motor[frontRight] =	motor[backRight] =motor[frontLeft] =motor[backLeft] = 0;
}
void breakDrivesideL()
{

	int speedl;
	nMotorEncoder[backLeft]=0;
	wait1Msec(10);
	int initspeedl=nMotorEncoder[backLeft];
	int powerl=-initspeedl*1000;
	speedl=initspeedl;
	motor[frontLeft] =motor[backLeft] =powerl;
	clearTimer(T3);
	while(abs(speedl)>1)
	{
		speedl=nMotorEncoder[backLeft];
		wait1Msec(20);
		nMotorEncoder[backLeft]=0;
		if(((speedl<=0) & (initspeedl>0))|((speedl>=0) & (initspeedl<0)))
		{
			motor[frontLeft] =motor[backLeft] = 0;
		}
		if(time1[T3]>300)
			break;
	}
	if((speedl<=0&initspeedl>0)|(speedl>=0&initspeedl<0))
		motor[frontLeft] =motor[backLeft] = 0;


}

void breakDrivesideR()
{

	int speedr;
	nMotorEncoder[backRight]=0;
	wait1Msec(10);
	int initspeedr=nMotorEncoder[backRight];
	int powerr=-initspeedr*1000;
	speedr=initspeedr;
	motor[frontRight] =motor[backRight] =powerr;
	clearTimer(T3);
	while(abs(speedr)>1)
	{
		speedr=nMotorEncoder[backRight];
		wait1Msec(20);
		nMotorEncoder[backRight]=0;
		if(((speedr<=0) & (initspeedr>0))|((speedr>=0) & (initspeedr<0)))
		{
			motor[frontRight] =motor[backRight] = 0;
		}
		if(time1[T3]>300)
			break;
	}
	if((speedr<=0&initspeedr>0)|(speedr>=0&initspeedr<0))
		motor[frontRight] =motor[backRight] = 0;
}

task visualMem()//auton only
{
	while(true)
	{
		if(memEn)
		{
			if(eyeL)
				eyeLm=true;
			if(eyeM)
				eyeMm=true;
			if(eyeR)
				eyeRm=true;
			if(eyeB)
				eyeBm=true;
		}
		else
			eyeLm=eyeRm=eyeMm=eyeBm=false;

	}
}

void turnIEC(int power,int degrees)
{
	bool booml=false,boomr=false,leftgood=false,rightgood=false;//break-ed
	int howfar=(int)degrees*2.7;
	if(howfar<=0)
	{
		nMotorEncoder[backRight] = 0;
		nMotorEncoder[backLeft] = 0;
		while(!leftgood | !rightgood)
		{
			if(nMotorEncoder[backRight] < -howfar&(!boomr) ){
				motor[backRight] = power;
				motor[frontRight] = power;}
			else if(nMotorEncoder[backRight] >howfar &(!boomr))
			{
				breakDrivesideR();
				boomr=true;
			}
			else if(boomr)
			{
				motor[backRight] = 	motor[frontRight] = 0;
				rightgood=true;
			}
			if(nMotorEncoder[backLeft] > howfar&(!booml) )
			{
				motor[backLeft] = -power;
				motor[frontLeft] = -power;
			}
			else if(nMotorEncoder[backLeft] < -howfar&(!booml))
			{
				breakDrivesideL();
				booml=true;
			}
			else if(booml)
			{
				motor[backLeft] = 	motor[frontLeft] = 0;
				leftgood=true;
			}
		}
	}
	else if(howfar>=0)
	{
		nMotorEncoder[backRight] = 0;
		nMotorEncoder[backLeft] = 0;
		while(!leftgood | !rightgood)
		{
			if(nMotorEncoder[backLeft] >- howfar&(!booml) ){
				motor[backLeft] = power;
				motor[frontLeft] = power;}
			else if(nMotorEncoder[backLeft] <-howfar &(!booml))
			{
				breakDrivesideL();
				booml=true;
			}
			else if(booml)
			{
				motor[backLeft] = 	motor[frontLeft] = 0;
				leftgood=true;
			}
			if(nMotorEncoder[backRight] <howfar&(!boomr) )
			{
				motor[backRight] = -power;
				motor[frontRight] = -power;
			}
			else if(nMotorEncoder[backRight] >howfar&(!boomr))
			{
				breakDrivesideR();
				boomr=true;
			}
			else if(boomr)
			{
				motor[backRight] = 	motor[frontRight] = 0;
				rightgood=true;
			}

		}
	}

}

void gyrocali()//gyro calibration
{
	SensorValue[gyro]=0;
	displayLCDString(0,0,"turn -90");
	while(nLCDButtons!=kButtonCenter)
	{
		displayLCDPos(0,9);
		displayNextLCDNumber(SensorValue[gyro]);
		wait1Msec(100);
	}
	gyrocorrection=SensorValue[gyro]-900;
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDString(0,0,"Gyro Good");
	displayLCDPos(0,10);
	displayNextLCDNumber(gyrocorrection,5);
	while(LCD_mid);
	clearLCDLine(0);
	clearLCDLine(1);
}

void forkpotcali()
{
	playTone(800,10);
	stopTask(raiseOrLowerFork);
	displayLCDString(0,0,"Push fork")
	while(nLCDButtons!=kButtonCenter)
	{
		displayLCDNumber(0,10,SensorValue[forkPot])
	}
	playTone(800,10);
	while(LCD_mid);
	SensorType[gyro]=sensorNone;
	fpc = SensorValue[forkpot]-400;
	wait1Msec(100);
	displayLCDString(0,0,"fork calibrated ");
	while(nLCDButtons!=kButtonCenter);
	playTone(1200,10);
	wait1Msec(200);
	playTone(1200,10);
	clearLCDLine(0);
	SensorType[gyro]=sensorGyro;
	startTask(raiseOrLowerFork);
	while(LCD_mid);

}



void encodercali()
{
	bool redo=true;
	while(redo)
	{
		redo=false;
		int samplel1,samplel2;
		int sampler1,sampler2;
		nMotorEncoder[backLeft]=nMotorEncoder[backRight]=0;
		displayLCDCenteredString(0,"testing....");

		wait1Msec(300);
		samplel1=nMotorEncoder[backLeft];
		sampler1=nMotorEncoder[backRight];

		wait1Msec(300);
		samplel2=nMotorEncoder[backLeft];
		sampler2=nMotorEncoder[backRight];

		motor[backLeft]=motor[backRight]=0;
		wait1Msec(50);

		if(samplel1!=0|samplel2!=0)
		{
			displayLCDPos(0,0);
			displayNextLCDString("LL Good");
		}
		else
		{
			displayLCDPos(0,0);
			displayNextLCDString("LL BAD");
			redo=true;
		}

		if(sampler1!=0|sampler2!=0)
		{
			displayLCDPos(0,8);
			displayNextLCDString("RR Good");
		}
		else
		{
			displayLCDPos(0,8);
			displayNextLCDString("RR BAD");
			redo=true;
		}

		while(nLCDButtons==kButtonNone)
		{
			displayLCDPos(1,5);
			displayNextLCDString("redo  skip ");
		}
		if(nLCDButtons==kButtonRight)
		{
			redo=false;
			while(nLCDButtons==kButtonRight);
		}

		else if(nLCDButtons==kButtonCenter)
		{
			redo=true;
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDPos(0,0);
			displayNextLCDString("reboot encoders");
			displayLCDPos(1,0);
			displayNextLCDString("......");
			//			resetMotorEncoder(backRight);
			//			resetMotorEncoder(backLeft);

			SensorType[rightIEM]=sensorQuadEncoderOnI2CPort;
			SensorType[leftIEM]=sensorQuadEncoderOnI2CPort;
			wait1Msec(400);

		}

	}
}

task tune()
{
	int val=0;
	string value;
	while(true)
	{
		switch (val)
		{
		case 0:
			displayLCDPos(0,0); displayNextLCDString("Kppp=");break;
		case 1:
			displayLCDPos(0,0); displayNextLCDString("Kiii=");break;
		case 2:
			displayLCDPos(0,0); displayNextLCDString("Kddd=");break;
		}

		while(!(SensorValue[GOL]|SensorValue[GOR]))
		{
			SensorValue[prgenc]=0;
			wait1Msec(50);
			switch (val)
			{
			case 0:
				kpf+=(float)(SensorValue[prgenc]/10000.0);
				if(kpf<0)
					kpf=0;
				sprintf(value, "%1.4f%c", kpf);
				break;
			case 1:
				kif+=(float)(SensorValue[prgenc]/10000.0);
				if(kif<0)
					kif=0;
				sprintf(value, "%1.4f%c", kif);
				break;
			case 2:
				kdf+=(float)(SensorValue[prgenc]/10000.0);
				if(kdf<0)
					kdf=0;
				sprintf(value, "%1.4f%c", kdf);
				break;
			}
			displayLCDString(0,5,value);
		}
		while(SensorValue[GOL]){}
		val++;
		if(val>=3)
			val=0;
	}
}


task sing()
{

	int i=0;
	int n=0;
	int t=33;

	int mryth []={3,5,5,99,1,2,3,4,5,6,2,0,3,4,4,99,5,6,7,7,6,6,5,2,3,4,3,2,3,4,5,4,3,4,5,6,5,4,3,2,2,3,4,3,2,3,4
		,5,4,3,3,2,5,5,4,3,4,5,3,5,5,1,0,0,4,6,6,2,0,0,5,15,5,6,4,3,2,1,2,3,0,0,5,8,8,6,4,3,2,5,7,8,8,8};
	int mtime []={4,2,1,1 ,6,2,2,2,2,2,6,2,4,2,1,1 ,6,2,2,2,2,2,6,1,1,2,1,2,2,1,2,1,2,2,1,2,2,2,2,6,2,2,2,1,2,2,1
		,3,1,2,2,2,2,1,1,1,1,8,4,3,1,4,2,2,4,3,1,4,2,2,4,3 ,1,2,2,2,2,4,4,4,2,2,4,3,2,2,2,2,2,4,4,4,2,2};

	while(1)
	{
		switch (mryth[i])
		{
		case 0:
			playTone(t0,mtime[i]*t);
			break;
		case 1:
			playTone(t1,mtime[i]*t);
			break;
		case 2:
			playTone(t2,mtime[i]*t);
			break;
		case 3:
			playTone(t3,mtime[i]*t);
			break;
		case 4:
			playTone(t4,mtime[i]*t);
			break;
		case 5:
			playTone(t5,mtime[i]*t);
			break;
		case 6:
			playTone(t6,mtime[i]*t);
			break;
		case 7:
			playTone(t7,mtime[i]*t);
			break;
		case 8:
			playTone(t8,mtime[i]*t);
			break;
		case 15:
			playTone(t15,mtime[i]*t);
			break;
		case 99:
			wait1Msec(mtime[i]*t)	;
			break;
		}
		for(int a=mtime[i];a--;a>0)
		{
			wait10Msec(t);
			n++;
			if(n%4==0)
				SensorValue[solBig]=!SensorValue[solBig];
			SensorValue[solLock]=!SensorValue[solLock];

		}
		i++;
	}
}


task data()
{
	string timeee,lokkk,powerrr,pott,enc;
	clearTimer(T4);
	while(1){

		//	sprintf(lokkk, " %1.0f%c", SensorValue[solLock]);
		//	sprintf(powerrr, " %3.0f%c", motor[backLeft]);
		sprintf(pott, " %4.0f%c", SensorValue[armPotentiometerL]);
		sprintf(timeee, " %5.0f%c", time1[T4]);
		//	sprintf(enc, " %5.0f%c", nMotorEncoder[backLeft]);
		/*	writeDebugStream(mBattery);
		writeDebugStream(eBattery);
		writeDebugStream(lokkk);
		writeDebugStream(powerrr);
		writeDebugStream(pott);*/
		writeDebugStream(timeee);
		writeDebugStreamLine(pott);
		wait1Msec(1);


	}


}

void forwardNS(int power, int howfar)
{
	const float Imax=8.0;
	const float Ri=0.08;//ohms
	float current,Iratio,ctrRod=1.0;
	bool virgin=true,act=false;
	int powersav,poweravg,deltaS=0,lastpos=0;
	string inpt,time,speedd,currents,joystickk,powerrr;
	clearTimer(T3);
	nMotorEncoder[backLeft]=0;
	while(nMotorEncoder[backLeft]<howfar)
	{
		motor[frontLeft] = (float)ctrRod*(power);
		motor[frontRight] = (float)ctrRod*(power);
		motor[backRight] = (float)ctrRod*(power);
		motor[backLeft] = (float)ctrRod*(power);
		current=(float)(battStd-nAvgBatteryLevel)/(1000.0*Ri);
		poweravg=power;
		deltaS=nMotorEncoder[backLeft]-lastpos;
		lastpos=nMotorEncoder[backLeft];


		sprintf(speedd, " %4.0f%c", SensorValue[armPotentiometerL]);
		sprintf(time, " %5.0f%c", time1[T4]);
		sprintf(currents, " %2.3f%c", current);
		sprintf(powerrr, " %3.0f%c", motor[armmotL]);
		sprintf(joystickk, " %3.0f%c", joystick);
		writeDebugStream(time);
		writeDebugStream(currents);
		writeDebugStream(powerrr);
		writeDebugStream(joystickk);
		writeDebugStreamLine(speedd);
		if(ctrRod==1)
			LowV=false;
		else
			LowV=true;

		if(current>Imax & virgin)
		{
			virgin=false;
			clearTimer(T3);
			powersav=poweravg;
		}
		if(current>Imax & !virgin & time1[T3]>200 & abs(deltaS)<5 )//also consider delta pos
		{
			act=true;
		}
		if(act)
		{
			Iratio=(float)current/Imax;
			ctrRod=(float)(1/Iratio);
			if(current>Imax-3.5)
				ctrRod=(float)(ctrRod-0.04);
			else if(current<(Imax-3.5))
				ctrRod=(float)(ctrRod+0.04);
			if (ctrRod>1.5)
				ctrRod=1.5;
			else if (ctrRod<0.1)
				ctrRod=0.1;
			ctrRod=0.2;


		}
		if ((3*poweravg<=powersav & act)|abs(deltaS)>5)
		{
			act=false;
			virgin=true;
			ctrRod=1.0;
		}
		wait1Msec(40);
	}
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
}


void backwardNS(int power, int howfar)
{
	const float Imax=8.0;
	const float Ri=0.08;//ohms
	float current,Iratio,ctrRod=1.0;
	bool virgin=true,act=false;
	int powersav,poweravg,deltaS=0,lastpos=0;
	string inpt,time,speedd,currents,joystickk,powerrr;
	clearTimer(T3);
	nMotorEncoder[backLeft]=0;
	while(nMotorEncoder[backLeft]>-howfar)
	{
		motor[frontLeft]=motor[frontRight]=motor[backRight]=motor[backLeft] = -(float)ctrRod*(power);
		current=(float)(battStd-nAvgBatteryLevel)/(1000.0*Ri);
		poweravg=power;
		deltaS=nMotorEncoder[backLeft]-lastpos;
		lastpos=nMotorEncoder[backLeft];


		sprintf(speedd, " %4.0f%c", SensorValue[armPotentiometerL]);
		sprintf(time, " %5.0f%c", time1[T4]);
		sprintf(currents, " %2.3f%c", current);
		sprintf(powerrr, " %3.0f%c", motor[armmotL]);
		sprintf(joystickk, " %3.0f%c", joystick);
		writeDebugStream(time);
		writeDebugStream(currents);
		writeDebugStream(powerrr);
		writeDebugStream(joystickk);
		writeDebugStreamLine(speedd);
		if(ctrRod==1)
			LowV=false;
		else
			LowV=true;

		if(current>Imax & virgin)
		{
			virgin=false;
			clearTimer(T3);
			powersav=poweravg;
		}
		if(current>Imax & !virgin & time1[T3]>200 & abs(deltaS)<5 )//also consider delta pos
		{
			act=true;
		}
		if(act)
		{
			Iratio=(float)current/Imax;
			ctrRod=(float)(1/Iratio);
			if(current>Imax-3.5)
				ctrRod=(float)(ctrRod-0.04);
			else if(current<(Imax-3.5))
				ctrRod=(float)(ctrRod+0.04);
			if (ctrRod>1.5)
				ctrRod=1.5;
			else if (ctrRod<0.1)
				ctrRod=0.1;
			ctrRod=0.2;


		}
		if ((3*poweravg<=powersav & act)|abs(deltaS)>4)
		{
			act=false;
			virgin=true;
			ctrRod=1.0;
		}
		wait1Msec(40);
	}
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
}
