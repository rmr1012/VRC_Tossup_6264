#pragma config(Sensor, in1,    armPotentiometerL, sensorPotentiometer)
#pragma config(Sensor, in2,    armPotentiometerR, sensorPotentiometer)
#pragma config(Sensor, in3,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  RH,             sensorTouch)
#pragma config(Sensor, dgtl2,  led1,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl3,  led2,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl4,  led3,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl5,  led4,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl7,  warning,        sensorLEDtoVCC)
#pragma config(Sensor, dgtl8,  solenoid2,      sensorDigitalOut)
#pragma config(Sensor, dgtl9,  solenoid,       sensorDigitalOut)
#pragma config(Sensor, I2C_1,  rightIEM,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  leftIEM,        sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           frontRight,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           backRight,     tmotorServoContinuousRotation, openLoop, encoder, encoderPort, I2C_1, 1000))
#pragma config(Motor,  port4,           roller,        tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port5,           armmotL,       tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port6,           conveyor,      tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port7,           armmotR,       tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port8,           backLeft,      tmotorServoContinuousRotation, openLoop, reversed, encoder, encoderPort, I2C_2, 1000))
#pragma config(Motor,  port9,           frontLeft,     tmotorServoContinuousRotation, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "Vex_Competition_v3.0_autonomus.h"
/*----------------------------------------------------------------------------------------------------*/
bool liftDa;
void mecanumdrive();
void GoRH();
void GoRH1();
void GoRM();
void GoRM1();
void GoBH();
void GoBH1();
void GoBM();
void GoBM1();
void drift(int power, int howfar);
void forward(int power,int howfar);
void backward(int power,int howfar);
void turn(int power ,int angle);
void selfcheck();
task raiseOrLowerArmL();
task raiseOrLowerArmR();
task projectile();
task autoslection();
int joystick,StartingTile,encoderL,encoderR,gyroref,kMaxPos = 3000;
bool fire=false;

//-----------------------============================---------------------------==============================----------------

/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
  SensorValue[led1]=0;
  SensorValue[led2]=0;
  SensorValue[led3]=0;
  SensorValue[led4]=0;// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
  StartTask(autoslection);// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	StartingTile=4;

// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}
void selfcheck()
{
	bool skip=false;
	nMotorEncoder[backRight]=0;
	nMotorEncoder[backLeft]=0;
	SensorValue[gyro]=0;
	ClearTimer(T2);
	while(time100[T2]<3){}
	if(abs(SensorValue[gyro])>50){
		SensorValue[warning]=1;
		skip=true;
	}
	else
		SensorValue[warning]=0;
	if(!skip)
	{
		motor[frontRight] = 127;
	  motor[backRight] = 127;
	  motor[frontLeft] = -127;
	  motor[backLeft] = -127;
		wait10Msec(13);
		motor[frontRight] = 0;
	  motor[backRight] = 0;
	  motor[frontLeft] = 0;
	  motor[backLeft] = 0;
		if(nMotorEncoder[backLeft]!=0&nMotorEncoder[backRight]!=0&SensorValue[gyro]<=-15)
			SensorValue[warning]=0;
		else
			SensorValue[warning]=1;
	}
}
/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////
task autoslection()
{
	while(1){
		switch (StartingTile){
				case 1:
				SensorValue[led1]=0;SensorValue[led2]=0;SensorValue[led3]=0;SensorValue[led4]=1;
				break;
				case 2:
				SensorValue[led1]=0;SensorValue[led2]=0;SensorValue[led3]=1;SensorValue[led4]=0;
				break;
				case 3:
				SensorValue[led1]=0;SensorValue[led2]=0;SensorValue[led3]=1;SensorValue[led4]=1;
				break;
				case 4:
				SensorValue[led1]=0;SensorValue[led2]=1;SensorValue[led3]=0;SensorValue[led4]=0;
				break;
				case 5:
				SensorValue[led1]=0;SensorValue[led2]=1;SensorValue[led3]=0;SensorValue[led4]=1;
				break;
				case 6:
				SensorValue[led1]=0;SensorValue[led2]=1;SensorValue[led3]=1;SensorValue[led4]=0;
				break;
				case 7:
				SensorValue[led1]=0;SensorValue[led2]=1;SensorValue[led3]=1;SensorValue[led4]=1;
				break;
				case 8:
				SensorValue[led1]=1;SensorValue[led2]=0;SensorValue[led3]=0;SensorValue[led4]=0;
				break;

			}
		while(!SensorValue[RH]){}
		StartingTile++;
		while(SensorValue[RH]){}
		wait10Msec(50);
		if(SensorValue[RH]==0)
		{
			if(StartingTile>5)
				StartingTile=1;
		}
	}
}

task autonomous()
{
	//unfold
	liftDa=false;
  StopTask(usercontrol);
  StopTask(raiseOrLowerArmL);
  StopTask(raiseOrLowerArmR);
	StartTask(projectile);

	switch(StartingTile)
	{
		case 1:
			GoRH();
			break;
		case 2:
			GoRM();
			break;
		case 3:
			GoBH();
			break;
		case 4:
			GoBM();
			break;
		case 5:
			GoRH1();
			break;
		case 6:
			GoRM1();
			break;
		case 7:
			GoBH1();
			break;
		case 8:
			GoBM1();
			break;
		default:
			break;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	// User control code here, inside the loop
	selfcheck();
	kMaxPos = 3000;
	StartTask(raiseOrLowerArmL);
  StartTask(raiseOrLowerArmR);
	StartTask(projectile);
	StartTask(autoslection);
  while(true) //Loop forever
  {
		mecanumdrive();
//		motor[armmot]=vexRT[Ch2];
		joystick=vexRT[Ch2];
		if(vexRT[Btn5U] == 1)
      motor[roller] = 127;
    else if(vexRT[Btn5D] == 1)
    	motor[roller] = -127;
    else
    	motor[roller] = 0;

		if(vexRT[Btn8DXmtr2]==1)
			kMaxPos=2400;
		else
			kMaxPos=3000;
    motor[conveyor] = vexRT[Ch3Xmtr2];



   if(SensorValue[armPotentiometerL]<=1450)
    {
    	liftDa=true;
			motor[armmotL]=motor[armmotR]=joystick;
		}
		else
		{
			liftDa=false;
		}
	}
}



void mecanumdrive()
{
  //Create "deadzone" variables. Adjust threshold value to increase/decrease deadzone
	int X2 = 0, Y1 = 0, X1 = 0, threshold = 25;
  //Create "deadzone" for Y1/Ch3
  if(abs(vexRT[Ch3]) > threshold)
    Y1 = vexRT[Ch3];
  else
    Y1 = 0;
  //Create "deadzone" for X1/Ch4
  if(abs(vexRT[Ch4]) > threshold)
    X1 = vexRT[Ch4];
  else
    X1 = 0;
  //Create "deadzone" for X2/Ch1
  if(abs(vexRT[Ch1]) > threshold)
    X2 = vexRT[Ch1];
  else
    X2 = 0;

  //Remote Control Commands
  motor[frontRight] = Y1 - X2 - X1;
  motor[backRight] =  Y1 - X2 + X1;
  motor[frontLeft] = Y1 + X2 + X1;
  motor[backLeft] =  Y1 + X2 - X1;
}


void GoRH()//if teammate no autonomus
{
	kMaxPos=2400;
	StartTask(raiseOrLowerArmL);
	StartTask(raiseOrLowerArmR);
	motor[conveyor]=127;
	wait10Msec(50);
	motor[roller]=127;//intake
	wait10Msec(50);
	motor[conveyor]=0;
	motor[roller]=0;
	//unfold
	forward(127,350);
	motor[roller]=127;
	fire=true;
	forward(127,300);
	fire=false;
	wait10Msec(120);
	motor[conveyor]=127;
	backward(127,80);
	SensorValue[gyro]=0;
	wait10Msec(10);//drift side

	//power turn
	SensorValue[gyro]=0;
	wait10Msec(10);
  while(abs(SensorValue[gyro]) <= 920 )
  {
    motor[frontRight] = -127;
    motor[backRight] = -127;
    motor[frontLeft] = 127;
    motor[backLeft] = 127;
	}
	motor[frontRight] = 0;
  motor[backRight] = 0;
  motor[frontLeft] = 0;
  motor[backLeft] = 0;
	//--------- fire

	motor[conveyor]=0;
	//-------------
	backward(127,1400);
	turn(127,-90);
	fire=true;
	wait10Msec(10);
	fire=false;
	backward(127,2400);
	joystick=128;
	wait10Msec(10);
	turn(128,190);
	forward(128,900);
	motor[roller]=-127;
	wait10Msec(120);
	motor[roller]=0;
	backward(128,900);
	joystick=-128;
}

void GoRH1()//if teammate no autonomus
{
	kMaxPos=2400;
	StartTask(raiseOrLowerArmL);
	StartTask(raiseOrLowerArmR);
	motor[conveyor]=127;
	wait10Msec(50);
	motor[roller]=127;//intake
	wait10Msec(50);
	motor[conveyor]=0;
	motor[roller]=0;
	//unfold
	forward(127,350);
	motor[roller]=127;
	fire=true;
	forward(127,300);
	fire=false;
	wait10Msec(120);
	backward(127,80);
	motor[conveyor]=127;
	SensorValue[gyro]=0;
	wait10Msec(10);//drift side

	//power turn
	SensorValue[gyro]=0;
	wait10Msec(10);
  while(abs(SensorValue[gyro]) <= 920 )
  {
    motor[frontRight] = -127;
    motor[backRight] = -127;
    motor[frontLeft] = 127;
    motor[backLeft] = 127;
	}
	motor[frontRight] = 0;
  motor[backRight] = 0;
  motor[frontLeft] = 0;
  motor[backLeft] = 0;
	//--------- fire

	//-------------
	backward(127,1150);
	motor[conveyor]=0;
	turn(127,-90);
	fire=true;
	wait10Msec(10);
	fire=false;
	backward(127,1000);
	forward(127,1000);
	drift(128,-600);
	turn(128,-165);
	forward(127,500);
	joystick=128;
	forward(127,500);
	motor[roller]=-127;

}

void GoRM()
{
	kMaxPos=2400;
	StartTask(raiseOrLowerArmL);
	StartTask(raiseOrLowerArmR);
	joystick=127;
	motor[conveyor]=127;
	wait10Msec(50);
	motor[roller]=127;//intake
	wait10Msec(50);
	motor[conveyor]=0;
	motor[roller]=-127;

	forward(127,900);
	backward(127,100);
	turn(128,90);
	forward(127,1000);
	wait1Msec(1);
	turn(128,-48);
	turn(128,58);
  joystick=-128;
	forward(128,450);
	turn(128,-40);
	joystick=0;
	wait1Msec(1);
	forward(128,2150);
	joystick=128;
  turn(128,90);
  turn(128,-33);
	fire=true;
	forward(128,1500);
	fire=false;
	turn(128,100);
}

void GoRM1()
{
	kMaxPos=2400;
	StartTask(raiseOrLowerArmL);
	StartTask(raiseOrLowerArmR);
	joystick=127;
	motor[conveyor]=127;
	wait10Msec(50);
	motor[roller]=127;//intake
	wait10Msec(50);
	motor[conveyor]=0;
	motor[roller]=-127;

	forward(127,900);
	backward(127,100);
	turn(128,100);
	forward(127,1200);
	wait1Msec(1);
	turn(128,-48);
	turn(128,58);
  joystick=-128;
  forward(128,800);
  turn(128,32);
  fire=true;
  forward(128,2000);
  fire=false;


}

void GoBH()
{
	kMaxPos=2400;
	StartTask(raiseOrLowerArmL);
	StartTask(raiseOrLowerArmR);
	motor[conveyor]=127;
	wait10Msec(50);
	motor[roller]=127;//intake
	wait10Msec(50);
	motor[conveyor]=0;
	motor[roller]=0;
	//unfold
	forward(127,350);
	motor[roller]=127;
	fire=true;
	forward(127,300);
	fire=false;
	wait10Msec(120);
	motor[conveyor]=127;
	backward(127,80);
	SensorValue[gyro]=0;
	wait10Msec(10);//drift side

	//power turn
	SensorValue[gyro]=0;
	wait10Msec(10);
  while(SensorValue[gyro] >= -900 )
  {
    motor[frontRight] = 127;
    motor[backRight] = 127;
    motor[frontLeft] = -127;
    motor[backLeft] = -127;
	}
	motor[frontRight] = 0;
  motor[backRight] = 0;
  motor[frontLeft] = 0;
  motor[backLeft] = 0;
	//--------- fire

	motor[conveyor]=0;
	//-------------
	backward(127,1400);
	turn(127,105);
	fire=true;
	wait10Msec(10);
	fire=false;
	backward(127,2400);
	joystick=128;
	wait10Msec(10);
	turn(128,200);
	forward(128,900);
	motor[roller]=-127;
	wait10Msec(120);
	motor[roller]=0;
	backward(128,900);
	joystick=-128;
}

void GoBH1()//if teammate no autonomus
{
	kMaxPos=2400;
	StartTask(raiseOrLowerArmL);
	StartTask(raiseOrLowerArmR);
	motor[conveyor]=127;
	wait10Msec(50);
	motor[roller]=127;//intake
	wait10Msec(50);
	motor[conveyor]=0;
	motor[roller]=0;
	//unfold
	forward(127,350);
	motor[roller]=127;
	fire=true;
	forward(127,300);
	fire=false;
	wait10Msec(120);
	motor[conveyor]=127;
	backward(127,80);
	SensorValue[gyro]=0;
	wait10Msec(10);//drift side

	//power turn
	SensorValue[gyro]=0;
	wait10Msec(10);
  while(SensorValue[gyro] >= -900 )
  {
    motor[frontRight] = 127;
    motor[backRight] = 127;
    motor[frontLeft] = -127;
    motor[backLeft] = -127;
	}
	motor[frontRight] = 0;
  motor[backRight] = 0;
  motor[frontLeft] = 0;
  motor[backLeft] = 0;
	//--------- fire

	motor[conveyor]=0;
	//-------------
	backward(127,1400);
	turn(127,105);
	fire=true;
	wait10Msec(10);
	fire=false;
	backward(127,1000);
	forward(127,1000);
	drift(128,600);
	turn(128,165);
	forward(127,500);
	joystick=128;
	forward(127,500);
	motor[roller]=-127;

}

void GoBM()
{
	kMaxPos=2400;
	StartTask(raiseOrLowerArmL);
	StartTask(raiseOrLowerArmR);
	joystick=127;
	motor[conveyor]=127;
	wait10Msec(50);
	motor[roller]=127;//intake
	wait10Msec(50);
	motor[conveyor]=0;
	motor[roller]=-127;

	forward(127,900);
	backward(127,100);
	turn(128,-88);
	forward(127,1100);
	wait1Msec(1);
	turn(128,55);
	turn(128,-50);
  joystick=-128;
	forward(128,550);
	turn(128,50);
	joystick=0;
	forward(128,2050);
	joystick=128;
  turn(128,-80);
	turn(128,40);
	fire=true;
  forward(128,1400);
  fire=false;
	turn(128,-100);
}

void GoBM1()
{
		kMaxPos=2400;
	StartTask(raiseOrLowerArmL);
	StartTask(raiseOrLowerArmR);
	joystick=127;
	motor[conveyor]=127;
	wait10Msec(50);
	motor[roller]=127;//intake
	wait10Msec(50);
	motor[conveyor]=0;
	motor[roller]=-127;

	forward(127,900);
	backward(127,100);
	turn(128,-88);
	forward(127,1100);
	wait1Msec(1);
	turn(128,55);
	turn(128,-50);
  joystick=-128;
  forward(128,800);
  turn(128,32);
  fire=true;
  forward(128,2000);
  fire=false;


}

void turn(int power,int angle)
{
	int decidegrees = 10*angle;
	int error = 5;

  //While the absolute value of the gyro is less than the desired rotation - 100...
	if(decidegrees>=0)
	{
		SensorValue[gyro]=0;
	  while(abs(SensorValue[gyro]) < decidegrees-100 )
	  {
	    motor[frontRight] = -power;
	    motor[backRight] = -power;
	    motor[frontLeft] = power;
	    motor[backLeft] = power;
	  }
	  //Brief brake to eliminate some drift
	  motor[frontRight] = 5;
	  motor[backRight] = 5;
	  motor[frontLeft] = -5;
	  motor[backLeft] = -5;
	  wait1Msec(100);

	  //Second while loop to move the robot more slowly to its goal, also setting up a range
	  //for the amount of acceptable error in the system
	  ClearTimer(T1);
	  while(abs(SensorValue[gyro]) > decidegrees + error || abs(SensorValue[gyro]) < decidegrees - error)
	  {
	    if(abs(SensorValue[gyro]) > decidegrees)
	    {
	      motor[frontRight] = -30;
			  motor[backRight] = -30;
			  motor[frontLeft] = 30;
			  motor[backLeft] = 30;
	    }
	    else
	    {
	      motor[frontRight] = 30;
			  motor[backRight] = 30;
			  motor[frontLeft] = -30;
			  motor[backLeft] = -30;
			}
			if(time10[T1]>abs(angle/2)){break;}
		}
	}
	else
	{
		SensorValue[gyro]=0;
		wait1Msec(1);
		while(SensorValue[gyro] > decidegrees+100 )
	  {
	  	wait1Msec(1);
	    motor[frontRight] = power;
	    motor[backRight] = power;
	    motor[frontLeft] = -power;
	    motor[backLeft] = -power;
	  }
	  //Brief brake to eliminate some drift
	  motor[frontRight] = -5;
	  motor[backRight] = -5;
	  motor[frontLeft] = 5;
	  motor[backLeft] = 5;
	  wait1Msec(100);

	  //Second while loop to move the robot more slowly to its goal, also setting up a range
	  //for the amount of acceptable error in the system
	  ClearTimer(T1);
	  while(abs(SensorValue[gyro]) > decidegrees + error || abs(SensorValue[gyro]) < decidegrees - error)
	  {
	    if(abs(SensorValue[gyro]) < decidegrees)
	    {
	      motor[frontRight] = -20;
			  motor[backRight] = -20;
			  motor[frontLeft] = 20;
			  motor[backLeft] = 20;
	    }
	    else
	    {
	      motor[frontRight] = 20;
			  motor[backRight] = 20;
			  motor[frontLeft] = -20;
			  motor[backLeft] = -20;
			}
			if(time10[T1]>abs(angle/2)){break;}
		}

	}
  //Stop
  motor[frontRight] = 0;
  motor[frontRight] = 0;
  motor[frontLeft] = 0;
  motor[backLeft] = 0;

}


void drift(int power, int howfar)
{
	SensorValue[gyro]=0;
	howfar=-howfar;
	nMotorEncoder[backRight] = 0;
	nMotorEncoder[backLeft] = 0;
	if(howfar>0)
	{
		while(nMotorEncoder[backLeft] < (howfar-15))
		{
			motor[frontLeft]=motor[backRight]=-127;
			motor[backLeft]=motor[frontRight]=127;
		}
		motor[frontRight] = 0;
	  motor[backRight] = 0;
	  motor[frontLeft] = 0;
  	motor[backLeft] = 0;
		if(SensorValue[gyro] > 0)
	  {
      while(SensorValue[gyro]>10|SensorValue[gyro]<-10)
      {
	    	motor[frontRight] = 30;
			  motor[backRight] = 30;
			  motor[frontLeft] = -30;
		  	motor[backLeft] = -30;
			}
    }
    else
    {
	    while(SensorValue[gyro]>10|SensorValue[gyro]<-10)
      {
	    	motor[frontRight] = -30;
			  motor[backRight] = -30;
			  motor[frontLeft] = 30;
		  	motor[backLeft] = 30;
			}
		}
		motor[frontRight] = 0;
	  motor[backRight] = 0;
	  motor[frontLeft] = 0;
  	motor[backLeft] = 0;
	}
	else
	{
		while(nMotorEncoder[backRight] > (howfar+15))
		{
			motor[frontLeft]=motor[backRight]=127;
			motor[backLeft]=motor[frontRight]=-127;
		}
		motor[frontRight] = 0;
	  motor[backRight] = 0;
	  motor[frontLeft] = 0;
  	motor[backLeft] = 0;
		if(SensorValue[gyro] > 0)
	  {
      while(SensorValue[gyro]>10|SensorValue[gyro]<-10)
      {
	    	motor[frontRight] = 30;
			  motor[backRight] = 30;
			  motor[frontLeft] = -30;
		  	motor[backLeft] = -30;
			}
    }
    else
    {
	    while(SensorValue[gyro]>10|SensorValue[gyro]<-10)
      {
	    	motor[frontRight] = -30;
			  motor[backRight] = -30;
			  motor[frontLeft] = 30;
		  	motor[backLeft] = 30;
			}
		}
		motor[frontRight] = 0;
	  motor[backRight] = 0;
	  motor[frontLeft] = 0;
  	motor[backLeft] = 0;
	}
}

void forward(int power,int howfar)
{
	nMotorEncoder[backRight] = 0;
	nMotorEncoder[backLeft] = 0;
	while(nMotorEncoder[backRight] < (howfar-15) | nMotorEncoder[backLeft] < (howfar-15))
	{
		if(nMotorEncoder[backRight] < howfar ){
			motor[backRight] = power;
			motor[frontRight] = power;}
		else if(nMotorEncoder[backRight]>howfar){
			motor[backRight] = 0;
			motor[frontRight] = 0;}

		if(nMotorEncoder[backLeft] < howfar ){
			motor[backLeft] = power;
			motor[frontLeft] = power;}
		else if(nMotorEncoder[backLeft]>howfar){
			motor[backLeft] = 0;
			motor[frontLeft] = 0;}
		}
  motor[frontRight] = 0;
  motor[backRight] = 0;
  motor[frontLeft] = 0;
  motor[backLeft] = 0;
}

void backward(int power,int howfar)
{
	nMotorEncoder[backRight] = 0;
	nMotorEncoder[backLeft] = 0;
	while(nMotorEncoder[backRight] > (-howfar+15) | nMotorEncoder[backLeft] > (-howfar+15))
	{
		if(nMotorEncoder[backRight] > -howfar ){
			motor[backRight] = -power;
			motor[frontRight] = -power;}
		else if(nMotorEncoder[backRight]<-howfar){
			motor[backRight] = 0;
			motor[frontRight] = 0;}

		if(nMotorEncoder[backLeft] > -howfar ){
			motor[backLeft] = -power;
			motor[frontLeft] = -power;}
		else if(nMotorEncoder[backLeft]<-howfar){
			motor[backLeft] = 0;
			motor[frontLeft] = 0;}
		}
  motor[frontRight] = 0;
  motor[backRight] = 0;
  motor[frontLeft] = 0;
  motor[backLeft] = 0;
}

//-----------------------------------------------------------------------------------

task projectile()
{
	while(1){
		while(vexRT[Btn7DXmtr2] == 1|fire)         // If button 6U (upper right shoulder button) is pressed:
    {
      SensorValue[solenoid] = 1;
      SensorValue[solenoid2] = 1;  // ...activate the solenoid.
      encoderL=nMotorEncoder[backLeft];
      encoderR=nMotorEncoder[backRight];
      gyroref=SensorValue[gyro];
    }
    	gyroref=SensorValue[gyro];
    	SensorValue[solenoid] = 0;
      SensorValue[solenoid2] = 0;
      encoderL=nMotorEncoder[backLeft];
      encoderR=nMotorEncoder[backRight];
	}
}
//-----------------------------------------------------------------------------------

task raiseOrLowerArmL()
{
  const int kSlowSpeedRange = 50;
  const int kMinPos = 1300;

  const int kSlowSpeedPosLowering = kMinPos + kSlowSpeedRange;
  const int kSlowSpeedRaising     = kMaxPos - kSlowSpeedRange;

  const int kMotorSpeedUp   = +127;
  const int kMotorSpeedDown = -127;

  int nPositionToHold;
  int nLastError;
  bool bLastUpdateWasButtonPress = false;
  bool bButtonsHaveBeenPressed   = false;
  while(true)
  {
  	while(liftDa){}
	  if (joystick <= -90)// button is puchsed indicating ARM should be lowered
	  {
	    if (SensorValue[armPotentiometerL] < kMinPos)
	    {
	      motor[armmotL] = 0; // Arm is fully lowered. Stop the motor
	    }
	    else if (SensorValue[armPotentiometerL] < kSlowSpeedPosLowering)
	      motor[armmotL] = kMotorSpeedDown / 2;
	    else
	      motor[armmotL] = kMotorSpeedDown;
	    bLastUpdateWasButtonPress = true;
	  }

	  else if (joystick >= 90)// button is puchsed indicating ARM should be raised
	  {
	    if (SensorValue[armPotentiometerL] > kMaxPos)
	    {
	      motor[armmotL] = 0;// Arm is fully raised. Stop the motor
	    }
	    else if (SensorValue[armPotentiometerL] > kSlowSpeedRaising)
	      motor[armmotL] = kMotorSpeedUp / 2;
	    else
	      motor[armmotL] = kMotorSpeedUp;
	    bLastUpdateWasButtonPress = true;
	  }

	  else// No buttons are pushed.
	  {


	    if (bLastUpdateWasButtonPress) // A button has just been released.- Remember the position.-- Stop motor
	    {
	      bLastUpdateWasButtonPress = false;
	      nPositionToHold = (SensorValue[armPotentiometerL]+SensorValue[armPotentiometerL])/2;
	      if (nPositionToHold < kMinPos)
	        nPositionToHold = kMinPos;
	      else if (nPositionToHold > kMaxPos)
	        nPositionToHold = kMaxPos;
	      motor[armmotL] = 0;
	      ClearTimer(T4);
	      bButtonsHaveBeenPressed = true;
	      nLastError = SensorValue[armPotentiometerL] - nPositionToHold;
	    }
	    else if (bButtonsHaveBeenPressed)
	    {
	      const int kUpdateCycle    = 10;
	      const int kSpeedIncrement = 5;  //need to be adjusted

	      int nError;

	      if (time1[T4] > kUpdateCycle)
	      { // Not enough time has elapsed

		      ClearTimer(T4);
		      nError = SensorValue[armPotentiometerL] - nPositionToHold;

		      // Adjust the motor "hold" speed based on whether the position error is increasing or
		      // decreasing. Don't worry about small errors in the range -5 to +5.

		      if (nError < -10)
		      {
		        if (nError < nLastError)
		        {
		          // Error is increasing in magnitude. Adjust the speed.
		          if (SensorValue[armPotentiometerL] < kMaxPos)
		            motor[armmotL] += kSpeedIncrement;
		        }
		        else if (motor[armmotL] > 0)
		          motor[armmotL] -= kSpeedIncrement;
		      }
		      else if (nError > +10)
		      {
		        if (nError > nLastError)
		        {
		          if (SensorValue[armPotentiometerL] > kMinPos)
		            motor[armmotL] -= kSpeedIncrement;
		        }
		        else if (motor[armmotL] > 0)
		          motor[armmotL] += kSpeedIncrement;
		      }
		      nLastError = nError;
	  	  }
	    }
	    else{}
	  }
	}
}

//-----------------------------------------------------------------------------------

task raiseOrLowerArmR()
{
  const int kSlowSpeedRange = 50;
  const int kMinPos = 1300;

  const int kSlowSpeedPosLowering = kMinPos + kSlowSpeedRange;
  const int kSlowSpeedRaising     = kMaxPos - kSlowSpeedRange;

  const int kMotorSpeedUp   = +127;
  const int kMotorSpeedDown = -127;

  int nPositionToHold;
  int nLastError;
  bool bLastUpdateWasButtonPress = false;
  bool bButtonsHaveBeenPressed   = false;
  while(true)
  {
	  while(liftDa){}
  	if (joystick <= -90)// button is puchsed indicating ARM should be lowered
	  {
	    if (SensorValue[armPotentiometerR] < kMinPos)
	    {
	      motor[armmotR] = 0; // Arm is fully lowered. Stop the motor
	    }
	    else if (SensorValue[armPotentiometerR] < kSlowSpeedPosLowering)
	      motor[armmotR] = kMotorSpeedDown / 2;
	    else
	      motor[armmotR] = kMotorSpeedDown;
	    bLastUpdateWasButtonPress = true;
	  }

	  else if (joystick >= 90)// button is puchsed indicating ARM should be raised
	  {
	    if (SensorValue[armPotentiometerR] > kMaxPos)
	    {
	      motor[armmotR] = 0;// Arm is fully raised. Stop the motor
	    }
	    else if (SensorValue[armPotentiometerR] > kSlowSpeedRaising)
	      motor[armmotR] = kMotorSpeedUp / 2;
	    else
	      motor[armmotR] = kMotorSpeedUp;
	    bLastUpdateWasButtonPress = true;
	  }

	  else// No buttons are pushed.
	  {


	    if (bLastUpdateWasButtonPress) // A button has just been released.- Remember the position.-- Stop motor
	    {
	      bLastUpdateWasButtonPress = false;
	      nPositionToHold = (SensorValue[armPotentiometerL]+SensorValue[armPotentiometerR])/2;
	      if (nPositionToHold < kMinPos)
	        nPositionToHold = kMinPos;
	      else if (nPositionToHold > kMaxPos)
	        nPositionToHold = kMaxPos;
	      motor[armmotR] = 0;
	      ClearTimer(T4);
	      bButtonsHaveBeenPressed = true;
	      nLastError = SensorValue[armPotentiometerR] - nPositionToHold;
	    }
	    else if (bButtonsHaveBeenPressed)
	    {
	      const int kUpdateCycle    = 10;
	      const int kSpeedIncrement = 5;  //need to be adjusted

	      int nError;

	      if (time1[T4] > kUpdateCycle)
	      { // Not enough time has elapsed

		      ClearTimer(T4);
		      nError = SensorValue[armPotentiometerR] - nPositionToHold;

		      // Adjust the motor "hold" speed based on whether the position error is increasing or
		      // decreasing. Don't worry about small errors in the range -5 to +5.

		      if (nError < -10)
		      {
		        if (nError < nLastError)
		        {
		          // Error is increasing in magnitude. Adjust the speed.
		          if (SensorValue[armPotentiometerR] < kMaxPos)
		            motor[armmotR] += kSpeedIncrement;
		        }
		        else if (motor[armmotR] > 0)
		          motor[armmotR] -= kSpeedIncrement;
		      }
		      else if (nError > +10)
		      {
		        if (nError > nLastError)
		        {
		          if (SensorValue[armPotentiometerR] > kMinPos)
		            motor[armmotR] -= kSpeedIncrement;
		        }
		        else if (motor[armmotR] > 0)
		          motor[armmotR] += kSpeedIncrement;
		      }
		      nLastError = nError;
	  	  }
	    }
	    else{}
	  }
	}
}
