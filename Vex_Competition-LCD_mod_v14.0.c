#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    armPotentiometerL, sensorPotentiometer)
#pragma config(Sensor, in2,    armPotentiometerR, sensorPotentiometer)
#pragma config(Sensor, in3,    LineL,          sensorLineFollower)
#pragma config(Sensor, in4,    LineM,          sensorLineFollower)
#pragma config(Sensor, in5,    LineR,          sensorLineFollower)
#pragma config(Sensor, in6,    nPowerex,       sensorAnalog)
#pragma config(Sensor, in7,    forkPot,        sensorPotentiometer)
#pragma config(Sensor, in8,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  GO,             sensorTouch)
#pragma config(Sensor, dgtl2,  solBig,         sensorDigitalOut)
#pragma config(Sensor, dgtl3,  solShift,       sensorDigitalOut)
#pragma config(Sensor, dgtl4,  fork1,          sensorDigitalOut)
#pragma config(Sensor, dgtl5,  fork2,          sensorDigitalOut)
#pragma config(Sensor, dgtl6,  prgenc,         sensorQuadEncoder)
#pragma config(Sensor, dgtl11, winchencoder,   sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  rightIEM,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  leftIEM,        sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           frontRight,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           backRight,     tmotorServoContinuousRotation, openLoop, reversed, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port4,           roller,        tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port5,           armmotL,       tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port6,           fork,          tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port7,           armmotR,       tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port8,           backLeft,      tmotorServoContinuousRotation, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port9,           frontLeft,     tmotorServoContinuousRotation, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#define LCD_left 0x01
#define LCD_mid 0x02
#define LCD_right 0x04
#define eyeL (SensorValue[LineL]<threshold)
#define eyeM (SensorValue[LineM]<threshold)
#define eyeR (SensorValue[LineR]<threshold)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
//#include "Vex_Competition_v3.0_autonomus.h"
/*----------------------------------------------------------------------------------------------------*/

void mecanumdrive();
void GoRH();
void GoRM();
void GoBH();
void GoBM();
void GoSkill();
void GoSkillRisk();
void gyrocali();
void encodercali();
void drift(int power, int howfar);
void forward(int power,int howfar);
void backward(int power,int howfar);
void toLine(int power);
void turn(int power ,float angle);
void autohang();
void winchup (int howfar);
void forwardLine(int power,int howfar);
void turnthenfollow(int power,int howfar);


task raiseOrLowerArm();
task projectile();
task masterreset();
task autoslection();
task shift();
task raiseOrLowerFork();

int threshold=300,lfc=0;
int gyrocorrection=0,joystick,joystickf,StartingTile,encoderL,encoderR,gyroref,kMaxPos = 3000,linethreshold=2400;
bool fire=false,liftDa,hangmode=false,skipcali=false;
float ki=0.0001,kd=0.40,kp=0.48;
float kdf=0,kpf=0.17,kif=0;
float kil=0.00,kdl=0,kpl=15;
int kMaxPosf = 3100;

task tune()
{
	int val=0;
	string value;
	while(true)
	{
		switch (val)
		{
		case 0:
			displayLCDPos(0,0); displayNextLCDString("Kppp=");break;
		case 1:
			displayLCDPos(0,0); displayNextLCDString("Kiii=");break;
		case 2:
			displayLCDPos(0,0); displayNextLCDString("Kddd=");break;
		}

		while(!SensorValue[GO])
		{
			SensorValue[prgenc]=0;
			wait1Msec(50);
			switch (val)
			{
			case 0:
				kpf+=(float)(SensorValue[prgenc]/10000.0);
				if(kpf<0)
					kpf=0;
				sprintf(value, "%1.4f%c", kpf);
				break;
			case 1:
				kif+=(float)(SensorValue[prgenc]/10000.0);
				if(kif<0)
					kif=0;
				sprintf(value, "%1.4f%c", kif);
				break;
			case 2:
				kdf+=(float)(SensorValue[prgenc]/10000.0);
				if(kdf<0)
					kdf=0;
				sprintf(value, "%1.4f%c", kdf);
				break;
			}
			displayLCDString(0,5,value);
		}
		while(SensorValue[GO]){}
		val++;
		if(val>=3)
			val=0;
	}
}

void pre_auton()
{
	SensorValue[solShift]=0;
	clearLCDLine(0);
	clearLCDLine(1);// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	SensorType[in8] = sensorNone;
  wait1Msec(1000);
  //Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
  SensorType[in8] = sensorGyro;
  wait1Msec(400);
  SensorValue[gyro]=0;
	bStopTasksBetweenModes = true;
	bLCDBacklight = true;
	StartingTile=4;

	gyrocali();
	if(!skipcali)
		encodercali();
	StartTask(autoslection);
	//	StartTask(tune);
	//All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}
void gyrocali()
{

	SensorValue[gyro]=0;
	displayLCDCenteredString(0,"turn +90 degrees");
	while(nLCDButtons!=LCD_mid)
	{
		displayLCDPos(1,0);
		displayNextLCDNumber(SensorValue[gyro]);
		wait1Msec(100);
		if(nLCDButtons==LCD_left){
			skipcali=true;
			break;
		}
	}
	gyrocorrection=SensorValue[gyro]-900;
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDCenteredString(0,"Gyro Calibrated");
	displayLCDPos(1,1);
	displayNextLCDNumber(gyrocorrection,5);
	while(nLCDButtons==LCD_mid);
	clearLCDLine(0);
	clearLCDLine(1);
	if(skipcali)
		gyrocorrection=0;
}

void encodercali()
{
	nMotorEncoder[backLeft]=nMotorEncoder[backRight]=0;
	displayLCDCenteredString(0,"move forward");
	while(nLCDButtons!=LCD_right)
	{
		displayLCDPos(1,0);
		displayNextLCDNumber(nMotorEncoder[backLeft]);
		displayNextLCDChar(' ');
		displayNextLCDNumber(nMotorEncoder[backRight]);
		wait1Msec(100);
	}

	if(nMotorEncoder[backLeft]>100&nMotorEncoder[backRight]>100)
		displayLCDCenteredString(0,"Encoder Good");
	if(nMotorEncoder[backLeft]<100|nMotorEncoder[backRight]<100)
		displayLCDCenteredString(0,"Encoder Bad");

	while(nLCDButtons==LCD_right);
	clearLCDLine(0);
	clearLCDLine(1);

}
/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////
task autoslection()
{
	string mBattery,eBattery;
	wait1Msec(10);
	while(1){
		clearLCDLine(0);
		switch (StartingTile){
		case 1:
			displayLCDPos(0,0); displayNextLCDString("Red Hanging");
			break;
		case 2:
			displayLCDPos(0,0); displayNextLCDString("Red Middle");
			break;
		case 3:
			displayLCDPos(0,0); displayNextLCDString("Bule Hanging");
			break;
		case 4:
			displayLCDPos(0,0); displayNextLCDString("Blue Middle");
			break;
		case 5:
			displayLCDPos(0,0); displayNextLCDString("Challenge");
			break;
		case 6:
			displayLCDPos(0,0); displayNextLCDString("Challenge Risk");
			break;

		}
		while(nLCDButtons!=LCD_left)
		{
			//clearLCDLine(1);
			sprintf(mBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0);
			sprintf(eBattery, "%1.2f%c", (SensorValue[nPowerex]/284.0));
			displayLCDString(1,0,mBattery);
			displayLCDString(1,5,eBattery);
			if(hangmode)
				displayLCDString(1,10,"hang");
			else
				displayLCDString(1,10,"normal");
			wait1Msec(100);
		}
		StartingTile++;
		while(nLCDButtons==LCD_left){}
		wait1Msec(500);

		if(StartingTile>6)
			StartingTile=1;

	}
}

task autonomous()
{
	//unfold
	liftDa=false;
	StopTask(usercontrol);
	StopTask(raiseOrLowerArm);
	StartTask(projectile);
	//	StartTask(shift);

	switch(StartingTile)
	{
	case 1:
		GoRH();
		break;
	case 2:
		GoRM();
		break;
	case 3:
		GoBH();
		break;
	case 4:
		GoBM();
		break;
	case 5:
		GoSkill();
		break;
	case 6:
		GoSkillRisk();
		break;
	default:
		break;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	kMaxPos = 3000;
	StartTask(raiseOrLowerArm);
	StartTask(raiseOrLowerFork);
	StartTask(projectile);
	StartTask(autoslection);
	StartTask(shift);
	StartTask(masterreset);

	//	StartTask(tune);
	while(true) //Loop forever
	{
		mecanumdrive();
		joystick=vexRT[Ch2];
		if(vexRT[Btn6U] == 1)
			joystickf = 127;
		else if(vexRT[Btn6D] == 1)
			joystickf = -127;
		else
			joystickf = 0;
		//		joystickf=vexRT[Ch2];
		if(vexRT[Btn5U] == 1)
			motor[roller] = 127;
		else if(vexRT[Btn5D] == 1)
			motor[roller] = -127;
		else
			motor[roller] = 0;
		if(vexRT[Btn8L]==1)
		{
			while(vexRT[Btn8L]==1){}
			autohang();
		}
		if(vexRT[Btn8DXmtr2]==1)
			kMaxPos=2400;
		else
			kMaxPos=2845;
		if(hangmode)
		{
			motor[armmotR]=vexRT[Ch3Xmtr2];
			motor[armmotL]=vexRT[Ch2Xmtr2];
			//			motor[conveyor] =0;
		}
		else{}
		//			motor[conveyor] = vexRT[Ch3Xmtr2];
		if(SensorValue[armPotentiometerL]<=1500&!hangmode)
		{
			liftDa=true;
			if(joystick<=-70)
				motor[armmotL]=motor[armmotR]=joystick/3;
			else if(joystick>=100)
				motor[armmotL]=motor[armmotR]=joystick;
			else
				motor[armmotL]=motor[armmotR]=0;
		}
		else if(SensorValue[armPotentiometerL]>=1500&!hangmode)
		{
			liftDa=false;
		}
	}
}



void mecanumdrive()
{
	int X2 = 0, Y1 = 0, X1 = 0, threshold = 25;
	if(abs(vexRT[Ch3]) > threshold)
		Y1 = vexRT[Ch3];
	else
		Y1 = 0;
	if(abs(vexRT[Ch4]) > threshold)
		X1 = vexRT[Ch4];
	else
		X1 = 0;
	if(abs(vexRT[Ch1]) > threshold)
		X2 = vexRT[Ch1];
	else
		X2 = 0;
	if(hangmode)
	{
		motor[frontLeft] = Y1 + X2 + X1;
		motor[frontRight] = Y1 - X2 - X1;
		motor[backRight] =  vexRT[Ch2];
		motor[backLeft] =  vexRT(Ch2);
	}
	else if(!hangmode)
	{
		motor[frontLeft] = Y1 + X2 + X1;
		motor[frontRight] = Y1 - X2 - X1;
		motor[backRight] =  Y1 - X2 + X1;
		motor[backLeft] =  Y1 + X2 - X1;
	}
}

void GoSkill()
{
	SensorValue[solShift]=0;
	kMaxPos=3000;
	kMaxPosf = 1700;
	StartTask(raiseOrLowerArm);
	StartTask(raiseOrLowerFork);
	motor[roller]=127;//intake
	wait1Msec(400);	//unfold
	forward(127,300);
	joystick=-128;
	forward(40,230);
	wait1Msec(800);
	backward(70,50);
	joystickf=128;
	turn(80,10);
	backward(100,350);
	joystick=0;
	turn(80,-10);
	backward(128,750);
	turn(128,-180);
	while(!SensorValue[GO]){}
	forward(128,550);
	SensorValue[solBig]=1;
	wait1Msec(1000);
	SensorValue[solBig]=0;
	turn(80,45);
	forward(128,200);










}


void GoSkillRisk()
{
	kMaxPos=3000;
	StartTask(raiseOrLowerArm);
	motor[roller]=127;
	wait1Msec(300);
	forward(127,500);
	joystick=-128;
	forward(80,200);
	joystick=0;
	backward(128,730);
	motor[roller]=0;
	turn(128,-150);




	while(!SensorValue[GO]){}
	forward(128,1500);
	turn(128,-18);
	joystick=128;
	while(SensorValue[armPotentiometerL]<2700);
	forward(128,500);
	motor[roller]=-128;
	wait1Msec(2000);
	backward(128,400);
	joystick=-128;
	motor[roller]=0;
	turn(128,13);
	while(SensorValue[armPotentiometerL]>1350){
		joystick=-128;}
	backward(128,600);
	joystick=0;
	backward(128,800);
	turn(128,157);
	forward(128,200);




	while(!SensorValue[GO]){}
	motor[roller]=128;
	forward(127,500);
	forward(80,200);
	joystick=-128;
	forward(40,550);
	wait1Msec(600);
	joystick=-0;
	backward(128,450);
	turn(128,-88);
	motor[roller]=10;//intake
	forward(128,550);
	turn(128,-88);

	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=98;
	wait1Msec(100);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	wait1Msec(100);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=98;
	wait1Msec(100);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	wait1Msec(100);


	forward(80,850);
	joystick=-128;
	forward(128,500);
	joystick=0;
	forward(128,650);
	joystick=128;
	while(SensorValue[armPotentiometerL]<2700);
	forward(50,150);
	forward(128,400);
	motor[roller]=-128;
	wait1Msec(2000);
	backward(128,400);
	joystick=-128;
	motor[roller]=0;
	turn(128,13);
	while(SensorValue[armPotentiometerL]>1400)
		joystick= -128;
	wait1Msec(500);
	joystick=0;
	backward(128,1400);
	turn(128,-20);



	while(!SensorValue[GO]);
	kMaxPos=2400;
	joystick=128;
	wait1Msec(800);
	forward(127,700);
	backward(127,550);
	turn(128,50);
	forward(128,900);
	backward(128,500);
	backward(128,500);
	turn(128,20);



	while(!SensorValue[GO]);
	kMaxPos=2400;
	motor[roller]=0;
	forward(128,2200);
	joystick=128;
	backward(128,300);
	joystick=-0;
	turn(128,20);
	forward(128,1400);
	turn(128,-90);
	forward(128,300);
}

void GoRH()
{
	kMaxPos=3000;
	StartTask(raiseOrLowerArm);
	motor[roller]=127;//intake
	wait1Msec(400);	//unfold
	forward(127,300);

	joystick=-128;
	forward(40,230);

	wait1Msec(1000);
	joystick=-0;
	StopTask(raiseOrLowerArm);
	motor[armmotL]=motor[armmotR]=0;
	backward(128,450);
	turn(128,-85);
	motor[roller]=10;//intake

	while(!SensorValue[GO]){}
	forward(128,620);
	turn(128,-88);

	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=98;
	wait1Msec(100);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	wait1Msec(100);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=98;
	wait1Msec(100);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	wait1Msec(100);


	forward(80,850);
	StartTask(raiseOrLowerArm);
	joystick=-128;
	forward(128,500);
	joystick=0;
	forward(128,650);
	joystick=128;
	while(SensorValue[armPotentiometerL]<2700);
	forward(50,150);
	forward(128,400);
	motor[roller]=-128;
}


void GoRM()
{
	kMaxPos=2400;
	StartTask(raiseOrLowerArm);
	motor[roller]=127;//intake
	joystick=128;
	wait1Msec(800);
	motor[roller]=0;
	//unfold
	forward(127,700);
	backward(127,550);
	turn(128,50);
	forward(128,900);

	backward(128,400);
	joystick=-128;
	backward(128,400);
	turn(128,-20);
	while(SensorValue[armPotentiometerL]>1400)
		joystick=0;
	StopTask(raiseOrLowerArm);
	motor[armmotL]=motor[armmotR]=-30;
	wait1Msec(300);
	motor[armmotL]=motor[armmotR]=0;
	while(!SensorValue[GO]){}


	forward(128,1550);
	StartTask(raiseOrLowerArm);
	turn(128,-18);
	kMaxPos=2950;
	joystick=128;
	while(SensorValue[armPotentiometerL]<2700);
	forward(128,400);
	motor[roller]=-128;
}


void GoBH()
{
	kMaxPos=3000;
	StartTask(raiseOrLowerArm);
	motor[roller]=127;//intake
	wait1Msec(400);	//unfold
	forward(127,300);

	joystick=-128;
	forward(40,230);

	wait1Msec(1000);
	joystick=-0;
	StopTask(raiseOrLowerArm);
	motor[armmotL]=motor[armmotR]=0;
	backward(128,450);
	turn(128,88);
	motor[roller]=10;//intake
	while(!SensorValue[GO]){}
	forward(128,625);
	turn(128,90);


	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=98;
	wait1Msec(100);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	wait1Msec(100);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=98;
	wait1Msec(100);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	wait1Msec(100);


	forward(80,850);
	StartTask(raiseOrLowerArm);
	joystick=-128;
	forward(128,500);
	joystick=0;
	forward(128,650);
	joystick=128;
	//	turn(128,-2);
	while(SensorValue[armPotentiometerL]<2700);
	forward(50,170);
	forward(128,400);
	motor[roller]=-128;
}



void GoBM()
{
	kMaxPos=2400;
	StartTask(raiseOrLowerArm);
	motor[roller]=127;//intake
	joystick=128;
	wait1Msec(800);
	motor[roller]=0;
	//unfold
	forward(127,700);
	backward(127,550);
	turn(128,-50);
	forward(128,900);

	backward(128,400);
	joystick=-128;
	backward(128,400);
	turn(128,20);
	while(SensorValue[armPotentiometerL]>1400)
		joystick=0;
	StopTask(raiseOrLowerArm);
	motor[armmotL]=motor[armmotR]=-30;
	wait1Msec(300);
	motor[armmotL]=motor[armmotR]=0;
	while(!SensorValue[GO]){}


	forward(128,1700);
	StartTask(raiseOrLowerArm);
	turn(128,15);
	kMaxPos=2950;
	joystick=128;
	while(SensorValue[armPotentiometerL]<2700);
	forward(128,400);
	motor[roller]=-128;
}



void turn(int power,float angle)
{
	int decidegrees = -10*angle;
	int error = 3;

	//While the absolute value of the gyro is less than the desired rotation - 100...
	if(decidegrees>=0)
	{
		decidegrees=(float)decidegrees+(decidegrees/900)*gyrocorrection;
		SensorValue[gyro]=0;
		while(abs(SensorValue[gyro]) < decidegrees-100 )
		{
			motor[frontRight] = power;
			motor[backRight] = power;
			motor[frontLeft] = -power;
			motor[backLeft] = -power;
		}
		motor[frontRight] = -5;
		motor[backRight] = -5;
		motor[frontLeft] = 5;
		motor[backLeft] = 5;
		wait1Msec(1000);

		ClearTimer(T1);
		while(SensorValue[gyro] > decidegrees + error || SensorValue[gyro] < decidegrees - error)
		{
			if(SensorValue[gyro] < decidegrees)
			{
				motor[frontRight] = 40;
				motor[backRight] = 40;
				motor[frontLeft] = -40;
				motor[backLeft] = -40;
			}
			else
			{
				motor[frontRight] = -40;
				motor[backRight] = -40;
				motor[frontLeft] = 40;
				motor[backLeft] = 40;
			}
		}
	}
	else
	{

		decidegrees=decidegrees-gyrocorrection;
		SensorValue[gyro]=0;
		wait1Msec(10);
		while(SensorValue[gyro] > decidegrees+100 )
		{
			wait1Msec(10);
			motor[frontRight] = -power;
			motor[backRight] = -power;
			motor[frontLeft] = power;
			motor[backLeft] = power;
		}
		motor[frontRight] = 5;
		motor[backRight] = 5;
		motor[frontLeft] = -5;
		motor[backLeft] = -5;
		wait1Msec(1000);
		ClearTimer(T1);
		while(SensorValue[gyro] > decidegrees + error || SensorValue[gyro] < decidegrees - error)
		{
			if(SensorValue[gyro] < decidegrees)
			{
				motor[frontRight] = 40;
				motor[backRight] = 40;
				motor[frontLeft] = -40;
				motor[backLeft] = -40;
			}
			else
			{
				motor[frontRight] = -40;
				motor[backRight] = -40;
				motor[frontLeft] = 40;
				motor[backLeft] = 40;
			}
		}

	}
	motor[frontRight] = 0;
	motor[backRight] = 0;
	motor[frontLeft] = 0;
	motor[backLeft] = 0;

}


void drift(int power, int howfar)
{
	SensorValue[gyro]=0;
	nMotorEncoder[backRight] = 0;
	nMotorEncoder[backLeft] = 0;
	if(howfar>0)
	{
		while(nMotorEncoder[backRight] < (howfar-15))
		{
			motor[frontLeft]=motor[backRight]=127;
			motor[backLeft]=motor[frontRight]=-127;
		}
		motor[frontRight] = 0;
		motor[backRight] = 0;
		motor[frontLeft] = 0;
		motor[backLeft] = 0;
		ClearTimer(T1);
		if(SensorValue[gyro] > 0)
		{
			while(SensorValue[gyro]>10|SensorValue[gyro]<-10)
			{
				motor[frontRight] = 30;
				motor[backRight] = 30;
				motor[frontLeft] = -30;
				motor[backLeft] = -30;
				if(time10[T1]>howfar/2){break;}
			}
		}
		else
		{
			while(SensorValue[gyro]>10|SensorValue[gyro]<-10)
			{
				motor[frontRight] = -40;
				motor[backRight] = -40;
				motor[frontLeft] = 40;
				motor[backLeft] = 40;
				if(time10[T1]>howfar/2){break;}
			}
		}
		motor[frontRight] = 0;
		motor[backRight] = 0;
		motor[frontLeft] = 0;
		motor[backLeft] = 0;
	}
	else
	{
		while(nMotorEncoder[backRight] > (howfar+15))
		{
			motor[frontLeft]=motor[backRight]=-127;
			motor[backLeft]=motor[frontRight]=+127;
		}
		motor[frontRight] = 0;
		motor[backRight] = 0;
		motor[frontLeft] = 0;
		motor[backLeft] = 0;
		ClearTimer(T1);
		if(SensorValue[gyro] > 0)
		{
			while(SensorValue[gyro]>10|SensorValue[gyro]<-10)
			{
				motor[frontRight] = 30;
				motor[backRight] = 30;
				motor[frontLeft] = -30;
				motor[backLeft] = -30;
				if(time10[T1]>howfar/2){break;}
			}
		}
		else
		{
			while(SensorValue[gyro]>10|SensorValue[gyro]<-10)
			{
				motor[frontRight] = -30;
				motor[backRight] = -30;
				motor[frontLeft] = 30;
				motor[backLeft] = 30;
				if(time10[T1]>howfar/2){break;}
			}
		}
		motor[frontRight] = 0;
		motor[backRight] = 0;
		motor[frontLeft] = 0;
		motor[backLeft] = 0;
	}
}

void forward(int power,int howfar)
{
	nMotorEncoder[backRight] = 0;
	nMotorEncoder[backLeft] = 0;
	while(howfar-nMotorEncoder[backRight]>10 | howfar-nMotorEncoder[backLeft]>10)
	{
		if(nMotorEncoder[backRight] < howfar ){
			motor[backRight] = power;
			motor[frontRight] = power;}
		else {
			motor[backRight] = 0;
			motor[frontRight] = 0;}

		if(nMotorEncoder[backLeft] < howfar ){
			motor[backLeft] = power;
			motor[frontLeft] = power;}
		else {
			motor[backLeft] = 0;
			motor[frontLeft] = 0;}
	}
	motor[frontRight] = 0;
	motor[backRight] = 0;
	motor[frontLeft] = 0;
	motor[backLeft] = 0;
}

void backward(int power,int howfar)
{
	nMotorEncoder[backRight] = 0;
	nMotorEncoder[backLeft]  = 0;
	while(nMotorEncoder[backRight]+howfar>10 | nMotorEncoder[backLeft]+howfar>10)
	{
		if(nMotorEncoder[backRight] > -howfar ){
			motor[backRight] = -power;
			motor[frontRight] = -power;}
		else if(nMotorEncoder[backRight]<-howfar){
			motor[backRight] = 0;
			motor[frontRight] = 0;}

		if(nMotorEncoder[backLeft] > -howfar ){
			motor[backLeft] = -power;
			motor[frontLeft] = -power;}
		else if(nMotorEncoder[backLeft]<-howfar){
			motor[backLeft] = 0;
			motor[frontLeft] = 0;}
	}
	motor[frontRight] = 0;
	motor[backRight] = 0;
	motor[frontLeft] = 0;
	motor[backLeft] = 0;
}

void autohang()
{
	//	StopTask(projectile);
	SensorValue[solShift]=1;
	SensorValue[winchencoder]=0;
	while(SensorValue[winchencoder]==0)
	{
		motor[backLeft]=motor[backRight]=80;
		wait1Msec(200);
		motor[backLeft]=motor[backRight]=-80;
		wait1Msec(200);
	}
	motor[backLeft]=motor[backRight]=0;
	while(SensorValue[armPotentiometerL]<3050)
		motor[armmotL]=motor[armmotR]=128;
	SensorValue[solBig]=1;
	motor[frontLeft]=motor[frontRight]=128;
	wait1Msec(600);
	motor[armmotL]=motor[armmotR]=0;
	motor[frontLeft]=motor[frontRight]=0;
	winchup(2500);

	motor[armmotL]=motor[armmotR]=-128;
	while(SensorValue[armPotentiometerL]>1380&SensorValue[armPotentiometerR]>1380)
	{
		motor[backLeft]=motor[backRight]=128;
	}
	wait1Msec(200);
	motor[backLeft]=motor[backRight]=100;
	wait1Msec(200);
	motor[backLeft]=motor[backRight]=80;
	wait1Msec(200);
	motor[backLeft]=motor[backRight]=60;
	wait1Msec(200);
	motor[backLeft]=motor[backRight]=40;
	wait1Msec(200);
	motor[armmotL]=motor[armmotR]=-10;
	SensorValue[solBig]=0;
	motor[backLeft]=motor[backRight]=20;
	wait1Msec(200);
	motor[backLeft]=motor[backRight]=10;
	SensorValue[solBig]=0;
	wait1Msec(1000);
}
void winchup (int howfar)
{

	SensorValue[winchencoder]=0;
	while(SensorValue[winchencoder]<=howfar){motor[backLeft]=motor[backRight]=128;}
	motor[backLeft]=motor[backRight]=0;


}

//-----------------------------------------------------------------------------------

task projectile()
{
	while(1){

		while(vexRT[Btn7DXmtr2] == 0&!fire);
		while(vexRT[Btn7DXmtr2] == 1|fire)         // If button 6U (upper right shoulder button) is pressed:
		{
			if(!hangmode)
				SensorValue[solBig] = 1;
			encoderL=nMotorEncoder[backLeft];
			encoderR=nMotorEncoder[backRight];
			gyroref=SensorValue[gyro];
		}
		gyroref=SensorValue[gyro];
		if(hangmode)
			SensorValue[solBig] = !SensorValue[solBig] ;
		else
			SensorValue[solBig] = 0;
		encoderL=nMotorEncoder[backLeft];
		encoderR=nMotorEncoder[backRight];
		wait1Msec(100);
	}
}
task shift()
{
	bool forkopen=false;
	while(true){
		while(vexRT[Btn7U] == 0)
		{
			if(vexRT[Btn8R])//hangmode
			{
				while(vexRT[Btn8R]){}
				liftDa=true;
				hangmode=true;
				motor[backLeft]=motor[backRight]=128;
				wait1Msec(100);
				motor[backLeft]=motor[backRight]=-128;
				SensorValue[solShift]=1;
				StopTask(raiseOrLowerArm);
				motor[backLeft]=motor[backRight]=128;
				wait1Msec(100);
				motor[backLeft]=motor[backRight]=-128;
				wait1Msec(100);
				motor[backLeft]=motor[backRight]=128;
				wait1Msec(100);
				motor[backLeft]=motor[backRight]=-128;
				wait1Msec(100);
				motor[backLeft]=motor[backRight]=0;

			}
			if(vexRT[Btn8RXmtr2])//action
			{
				while(vexRT[Btn8RXmtr2]){}
				forkopen=!forkopen;
				if(forkopen)//if already open, close it
				{
					SensorValue[fork1]=0;
					wait1Msec(200);
					SensorValue[fork2]=0;
				}
				else
				{
					SensorValue[fork2]=1;
					wait1Msec(200);
					SensorValue[fork1]=1;
				}

			}
		}
		SensorValue[solShift] =!SensorValue[solShift];
		while(vexRT[Btn7U] == 1){}

	}
}


task masterreset()
{
	while(1){
		while(vexRT[Btn8U] == 1){}
		while(vexRT[Btn8U] == 0){}
		StopTask(raiseOrLowerArm);
		StopTask(raiseOrLowerFork);
		StopTask(usercontrol);
		StopTask(shift);
		StopTask(projectile);
		StopTask(autoslection);
		StartTask(raiseOrLowerArm);
		StartTask(raiseOrLowerFork);
		StartTask(usercontrol);
		StartTask(shift);
		StartTask(projectile);
		StartTask(autoslection);

		hangmode=false;
		liftDa=false;
		SensorValue[solBig]=0;
	}
}
//-----------------------------------------------------------------------------------

task raiseOrLowerArm()
{
	const int kSlowSpeedRange = 10;
	const int kMinPos = 1320;

	const int kSlowSpeedPosLowering = kMinPos + kSlowSpeedRange;
	const int kSlowSpeedRaising     = kMaxPos - kSlowSpeedRange;

	const int kMotorSpeedUp   = +127;
	const int kMotorSpeedDown = -127;
	float ITerm;
	const float outMax=128,outMin=-128;
	int nPositionToHold;
	bool bLastUpdateWasButtonPress = false;
	bool bButtonsHaveBeenPressed   = false;
	while(true)
	{
		while(liftDa){}
		if (joystick <= -90)// button is puchsed indicating ARM should be lowered
		{
			if (SensorValue[armPotentiometerL] < kMinPos)
			{
				motor[armmotL] = 0; // Arm is fully lowered. Stop the motor
			}
			else if (SensorValue[armPotentiometerL] < kSlowSpeedPosLowering)
				motor[armmotL] = kMotorSpeedDown / 2;
			else
				motor[armmotL] = kMotorSpeedDown;
			if (SensorValue[armPotentiometerR] < kMinPos)
			{
				motor[armmotR] = 0; // Arm is fully lowered. Stop the motor
			}
			else if (SensorValue[armPotentiometerR] < kSlowSpeedPosLowering)
				motor[armmotR] = kMotorSpeedDown / 2;
			else
				motor[armmotR] = kMotorSpeedDown;
			nPositionToHold = ((SensorValue[armPotentiometerL]+SensorValue[armPotentiometerR])/2+10);
			bLastUpdateWasButtonPress = true;
		}

		else if (joystick >= 90)// button is puchsed indicating ARM should be raised
		{
			if (SensorValue[armPotentiometerL] > kMaxPos)
			{
				motor[armmotL] = 10;// Arm is fully raised. Stop the motor
			}
			else if (SensorValue[armPotentiometerL] > kSlowSpeedRaising)
				motor[armmotL] = kMotorSpeedUp / 2;
			else
				motor[armmotL] = kMotorSpeedUp;
			if (SensorValue[armPotentiometerR] > kMaxPos)
			{
				motor[armmotR] = 10;// Arm is fully raised. Stop the motor
			}
			else if (SensorValue[armPotentiometerR] > kSlowSpeedRaising)
				motor[armmotR] = kMotorSpeedUp / 2;
			else
				motor[armmotR] = kMotorSpeedUp;
			bLastUpdateWasButtonPress = true;
			nPositionToHold = ((SensorValue[armPotentiometerL]+SensorValue[armPotentiometerR])/2)+10;
		}


		else// No buttons are pushed.
		{


			if (bLastUpdateWasButtonPress) // A button has just been released.- Remember the position.-- Stop motor
			{
				bLastUpdateWasButtonPress = false;
				if (nPositionToHold < kMinPos)
					nPositionToHold = kMinPos;
				else if (nPositionToHold > kMaxPos)
					nPositionToHold = kMaxPos;
				motor[armmotL] = 0;
				motor[armmotR] = 0;
				ClearTimer(T1);
				bButtonsHaveBeenPressed = true;
			}
			else if (bButtonsHaveBeenPressed)
			{
				unsigned long now = time1[T1];
				long lastInput;
				unsigned long lastTime;
				unsigned long SampleTime=10;

				unsigned long timeChange = (now - lastTime);
				if(timeChange>=SampleTime)
				{
					static float input = (SensorValue[armPotentiometerL]+SensorValue[armPotentiometerR])/2;
					static float error = nPositionToHold - input;

					ITerm+= (ki * error);
					if(ITerm > outMax) ITerm= outMax;
					else if(ITerm < outMin) ITerm= outMin;
					if(ki==0) ITerm=0;
					float dInput = (input - lastInput);
					/*Compute PID Output*/
					float output = kp * error + ITerm- kd * dInput;
					if(output > outMax) output = outMax;
					else if(output < outMin) output = outMin;
					motor[armmotL]= motor[armmotR]= output;
					lastInput = input;
					lastTime = now;
				}
			}
			else
			{
			}
		}
	}
}


//-----------------------------------------------------------------------------------


void toLine(int power)
{
	bool passL=false,passR=false;
	while(!passL & !passR)
	{
		if(SensorValue[LineR] > linethreshold){
			motor[backRight] = power;
			motor[frontRight] = power;}
		if(SensorValue[LineR] < linethreshold){
			passR=true;
			motor[backRight] = 0;
			motor[frontRight] = 0;}

		if(SensorValue[LineL] > linethreshold){
			motor[backLeft] = power;
			motor[frontLeft] = power;}
		if(SensorValue[LineL] < linethreshold){
			passL=true;
			motor[backLeft] = 0;
			motor[frontLeft] = 0;}
	}
	if(SensorValue[LineR] < linethreshold){
		passR=true;
		motor[backRight] = 0;
		motor[frontRight] = 0;}
	motor[frontRight] = -power/3;
	motor[backRight] = -power/3;
	motor[frontLeft] = -power/3;
	motor[backLeft] = -power/3;
	wait1Msec(60);
	motor[frontRight] = 0;
	motor[backRight] = 0;
	motor[frontLeft] = 0;
	motor[backLeft] = 0;


	if(!passL){
		while(!passL){
			if(SensorValue[LineL] > linethreshold){
				motor[backLeft] = 1.5*power;
				motor[frontLeft] = 1.5*power;}
			if(SensorValue[LineL] < linethreshold){
				passL=true;
				motor[backLeft] = 0;
				motor[frontLeft] = 0;
				passR=false;
				while(!passR){
					if(SensorValue[LineR] > linethreshold){
						motor[backRight] = -1.5*power;
						motor[frontRight] = -1.5*power;}
					if(SensorValue[LineR] < linethreshold){
						passR=true;
						motor[backRight] = 0;
						motor[frontRight] = 0;}
				}
				passL=false;
				while(!passL){
					if(SensorValue[LineL] > linethreshold){
						motor[backLeft] = 1.5*power;
						motor[frontLeft] = 1.5*power;}
					if(SensorValue[LineL] < linethreshold){
						passL=true;
						motor[backLeft] = 0;
						motor[frontLeft] = 0;}
				}
				passR=false;
				while(!passR){
					if(SensorValue[LineR] > linethreshold){
						motor[backRight] = -1.5*power;
						motor[frontRight] = -1.5*power;}
					if(SensorValue[LineR] < linethreshold){
						passR=true;
						motor[backRight] = 0;
						motor[frontRight] = 0;}
				}
			}
		}
	}
	if(!passR){
		while(!passR){
			if(SensorValue[LineR] > linethreshold){
				motor[backRight] = 1.5*power;
				motor[frontRight] = 1.5*power;}
			if(SensorValue[LineR] < linethreshold){
				passR=true;
				motor[backRight] = 0;
				motor[frontRight] = 0;
				passL=false;
				while(!passL){
					if(SensorValue[LineL] > linethreshold){
						motor[backLeft] = -1.5*power;
						motor[frontLeft] = -1.5*power;}
					if(SensorValue[LineL] < linethreshold){
						passL=true;
						motor[backLeft] = 0;
						motor[frontLeft] = 0;}
				}
				passR=false;
				while(!passR){
					if(SensorValue[LineR] > linethreshold){
						motor[backRight] = 1.5*power;
						motor[frontRight] = 1.5*power;}
					if(SensorValue[LineR] < linethreshold){
						passR=true;
						motor[backRight] = 0;
						motor[frontRight] = 0;}
				}
				passL=false;
				while(!passL){
					if(SensorValue[LineL] > linethreshold){
						motor[backLeft] = -1.5*power;
						motor[frontLeft] = -1.5*power;}
					if(SensorValue[LineL] < linethreshold){
						passL=true;
						motor[backLeft] = 0;
						motor[frontLeft] = 0;}
				}
			}
		}
	}
}

task raiseOrLowerFork()
{

	const int kMinPosf = 900;
	float error,input;
	const int kSlowSpeedRange = 80;
	const int kSlowSpeedLowering = kMinPosf + kSlowSpeedRange;
	const int kSlowSpeedRaising     = kMaxPosf - kSlowSpeedRange;

	const int kMotorSpeedUp   = +127;
	const int kMotorSpeedDown = -127;

	const float outMax=128,outMin=-128;
	int nPositionToHold;
	float ITerm;
	bool bLastUpdateWasButtonPress = false;
	bool bButtonsHaveBeenPressed   = false;
	while(true)
	{
		if (joystickf<-90)// button is puchsed indicating ARM should be lowered
		{
			if (SensorValue[forkPot] <= kMinPosf)
			{
				motor[fork] = 10; // Arm is fully lowered. Stop the motor
			}
			else if (SensorValue[forkPot] <= kSlowSpeedLowering)
				motor[fork] = kMotorSpeedDown / 2;
			else
				motor[fork] = kMotorSpeedDown;
			nPositionToHold = SensorValue[forkPot];
			bLastUpdateWasButtonPress = true;
		}

		else if (joystickf>90)// button is puchsed indicating ARM should be raised
		{
			if (SensorValue[forkPot] >= kMaxPosf)
			{
				motor[fork] = -10;// Arm is fully raised. Stop the motor
			}
			else if (SensorValue[forkPot] >= kSlowSpeedRaising)
				motor[fork] = kMotorSpeedUp / 2;
			else
				motor[fork] = kMotorSpeedUp;
			nPositionToHold = SensorValue[forkPot];
			bLastUpdateWasButtonPress = true;
		}

		else  // No buttons are pushed.
		{
			if (bLastUpdateWasButtonPress) // A button has just been released.- Remember the position.-- Stop motor
			{
				bLastUpdateWasButtonPress = false;
				if (nPositionToHold < kMinPosf)
					nPositionToHold = kMinPosf;
				else if (nPositionToHold > kMaxPosf)
					nPositionToHold = kMaxPosf;
				motor[fork] = 0;
				motor[fork] = 0;
				ClearTimer(T1);
				bButtonsHaveBeenPressed = true;
			}
			else if (bButtonsHaveBeenPressed)
			{
				unsigned long now = time1[T1];
				long lastInput;
				unsigned long lastTime;
				unsigned long SampleTime=10;

				unsigned long timeChange = (now - lastTime);
				if(timeChange>=SampleTime)
				{
					input = SensorValue[forkPot];
					error = -(nPositionToHold - input);
					ITerm+= (ki * error);
					if(ITerm > outMax) ITerm= outMax;
					else if(ITerm < outMin) ITerm= outMin;
					if(kif==0) ITerm=0;

					float dInput = (input - lastInput);
					/*Compute PID Output*/
					float output = -(kpf * error + ITerm - kdf * dInput);
					if(output > outMax) output = outMax;
					else if(output < outMin) output = outMin;
					motor[fork]= output;
					lastInput = input;
					lastTime = now;
				}
			}
			else
			{
			}

		}
	}
}




void turnthenfollow(int power,int howfar)
{
	int degturned;
	const int b=150;//lengh factor of the robot
	SensorValue(gyro)=0;
	while(!eyeM)//eyehits line)		//turn left
	{
		motor[backLeft]=motor[frontLeft]=power;
		motor[backRight]=motor[frontRight]=power;
	}
	motor[backLeft]=motor[frontLeft]=0;
	motor[backRight]=motor[frontRight]=0;
	forward(power/2,30);
	while(!eyeL)//eyehits line)		//turn left
	{
		motor[backLeft]=motor[frontLeft]=-power;
		motor[backRight]=motor[frontRight]=power;
	}
	motor[backLeft]=motor[frontLeft]=15;
	motor[backRight]=motor[frontRight]=-15;
	wait1Msec(105);
	motor[backLeft]=motor[frontLeft]=0;
	motor[backRight]=motor[frontRight]=0;//brief break
	nMotorEncoder[backLeft]=nMotorEncoder[backRight]=0;
	degturned=SensorValue(gyro);//read gyro

	forwardLine(power,howfar-(sinDegrees(degturned/10)*b)+b);//calc corrected distance



}
void forwardLine(int power,int howfar)//howfar uses encoder
{
	float ITerm;
	const float outMax=128,outMin=-128;
	nMotorEncoder[backLeft]=nMotorEncoder[backRight]=0;
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=power;
	while((nMotorEncoder[backLeft]+nMotorEncoder[backRight])/2<howfar)
	{
		motor[frontLeft]=motor[backLeft]=power-lfc;//don't forget the back wheels
		motor[frontRight]=motor[backRight]=power+lfc;
		unsigned long now = time1[T1];
		static float lastInput;
		unsigned long lastTime;
		unsigned long SampleTime=100;

		unsigned long timeChange = (now - lastTime);
		if(!eyeL&eyeM&!eyeR)//on track, clear stuff
		{
			ITerm=0;
			lfc=0;//line follower correction zero
		}
		else if(!(!eyeL&eyeM&!eyeR)&timeChange>=SampleTime)//off track, then react. sample time minaly for motor reaction delay
		{
			static float input;
			if(!eyeL&!eyeM&!eyeR&(lastInput==-4|lastInput==-8))//to much too the right
				input = -8;
			if(eyeL&!eyeM&!eyeR)//to much too the right
				input = -4;//give a negative
			if(eyeL&eyeM&!eyeR)
				input = -1;
			if(!eyeL&eyeM&!eyeR)//
				input = 0;//perfect
			if(!eyeL&eyeM&eyeR)
				input = 1;
			if(!eyeL&!eyeM&eyeR)
				input = 4;
			if(!eyeL&!eyeM&!eyeR&(lastInput==4|lastInput==8))
				input = 8;


			static float error = - input;

			ITerm+= kil * error;//should be the longer time refreshes, the better
			if(ITerm > outMax) ITerm= outMax;
			else if(ITerm < outMin) ITerm= outMin;
			float dInput = (input - lastInput)/timeChange;
			/*Compute PID Output*/
			float output = kpl * error + ITerm- kdl * dInput;
			if(output > outMax) output = outMax;
			else if(output < outMin) output = outMin;
			lfc= output;
			lastInput = input;
			lastTime = now;
		}
	}
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
}
