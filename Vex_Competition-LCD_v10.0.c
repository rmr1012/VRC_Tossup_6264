#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    armPotentiometerL, sensorPotentiometer)
#pragma config(Sensor, in2,    armPotentiometerR, sensorPotentiometer)
#pragma config(Sensor, in3,    gyro,           sensorGyro)
#pragma config(Sensor, in4,    LineR,          sensorLineFollower)
#pragma config(Sensor, in5,    LineL,          sensorLineFollower)
#pragma config(Sensor, in6,    nPowerex,       sensorAnalog)
#pragma config(Sensor, dgtl1,  GO,             sensorTouch)
#pragma config(Sensor, dgtl2,  prgenc,         sensorQuadEncoder)
#pragma config(Sensor, dgtl4,  led3,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl5,  led4,           sensorLEDtoVCC)
#pragma config(Sensor, dgtl6,  warning,        sensorLEDtoVCC)
#pragma config(Sensor, dgtl7,  solenoid,       sensorDigitalOut)
#pragma config(Sensor, dgtl8,  solenoid2,      sensorDigitalOut)
#pragma config(Sensor, dgtl9,  solenoid3,      sensorDigitalOut)
#pragma config(Sensor, dgtl10, ,               sensorTouch)
#pragma config(Sensor, dgtl11, winchencoder,   sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  rightIEM,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  leftIEM,        sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           frontRight,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           backRight,     tmotorServoContinuousRotation, openLoop, reversed, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port4,           roller,        tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port5,           armmotL,       tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port6,           conveyor,      tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port7,           armmotR,       tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port8,           backLeft,      tmotorServoContinuousRotation, openLoop, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port9,           frontLeft,     tmotorServoContinuousRotation, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#define LCD_left 0x01
#define LCD_mid 0x02
#define LCD_right 0x04
#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
//#include "Vex_Competition_v3.0_autonomus.h"
/*----------------------------------------------------------------------------------------------------*/

void mecanumdrive();
void GoRH();
void GoRM();
void GoBH();
void GoBM();
void GoSkill();
void GoSkillRisk();
void gyrocali();
void encodercali();
void drift(int power, int howfar);
void forward(int power,int howfar);
void backward(int power,int howfar);
void toLine(int power);
void turn(int power ,float angle);


task raiseOrLowerArm();
task projectile();
task masterreset();
task autoslection();
task shift();

int gyrocorrection=0,joystick,StartingTile,encoderL,encoderR,gyroref,kMaxPos = 3000,linethreshold=2400;
bool fire=false,winchgood=false,liftDa,hangmode=false,skipcali=false;
float ki=0.0001,kd=0.40,kp=0.48;

task tune()
{
	int val=0;
	string value;
	while(true)
	{
		switch (val)
		{
		case 0:
			displayLCDPos(0,0); displayNextLCDString("Kppp=");break;
		case 1:
			displayLCDPos(0,0); displayNextLCDString("Kiii=");break;
		case 2:
			displayLCDPos(0,0); displayNextLCDString("Kddd=");break;
		}

		while(!SensorValue[GO])
		{
			SensorValue[prgenc]=0;
			wait1Msec(5);
			switch (val)
			{
			case 0:
				kd+=(float)(SensorValue[prgenc]/10000.0);
				if(kd<0)
					kd=0;
				sprintf(value, "%1.4f%c", kd);
				break;
			case 1:
				ki+=(float)(SensorValue[prgenc]/10000.0);
				if(ki<0)
					ki=0;
				sprintf(value, "%1.4f%c", ki);
				break;
			case 2:
				kp+=(float)(SensorValue[prgenc]/10000.0);
				if(kp<0)
					kp=0;
				sprintf(value, "%1.4f%c", kp);
				break;
			}
			displayLCDString(0,5,value);
		}
		while(SensorValue[GO]){}
		val++;
		if(val>=3)
			val=0;
	}
}

void pre_auton()
{
	SensorValue[solenoid3]=0;
	clearLCDLine(0);
	clearLCDLine(1);// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;
	bLCDBacklight = true;
	StartingTile=5;

	gyrocali();
	if(!skipcali)
		encodercali();
	StartTask(autoslection);
	//All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}
void gyrocali()
{

	SensorValue[gyro]=0;
	displayLCDCenteredString(0,"turn +90 degrees");
	while(nLCDButtons!=LCD_mid)
	{
		displayLCDPos(1,0);
		displayNextLCDNumber(SensorValue[gyro]);
		wait10Msec(10);
		if(nLCDButtons==LCD_left){
			skipcali=true;
			break;
		}
	}
	gyrocorrection=SensorValue[gyro]-900;
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDCenteredString(0,"Gyro Calibrated");
	displayLCDPos(1,1);
	displayNextLCDNumber(gyrocorrection,5);
	while(nLCDButtons==LCD_mid);
	clearLCDLine(0);
	clearLCDLine(1);
	if(skipcali)
		gyrocorrection=0;
}

void encodercali()
{
	nMotorEncoder[backLeft]=nMotorEncoder[backRight]=0;
	displayLCDCenteredString(0,"move forward");
	while(nLCDButtons!=LCD_right)
	{
		displayLCDPos(1,0);
		displayNextLCDNumber(nMotorEncoder[backLeft]);
		displayNextLCDChar(' ');
		displayNextLCDNumber(nMotorEncoder[backRight]);
		wait10Msec(10);
	}

	if(nMotorEncoder[backLeft]>100&nMotorEncoder[backRight]>100)
		displayLCDCenteredString(0,"Encoder Good");
	if(nMotorEncoder[backLeft]<100|nMotorEncoder[backRight]<100)
		displayLCDCenteredString(0,"Encoder Bad");

	while(nLCDButtons==LCD_right);
	clearLCDLine(0);
	clearLCDLine(1);

}
/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////
task autoslection()
{
	string mBattery,eBattery;
	wait10Msec(1);
	while(1){
		clearLCDLine(0);
		switch (StartingTile){
		case 1:
			displayLCDPos(0,0); displayNextLCDString("Red Hanging");
			break;
		case 2:
			displayLCDPos(0,0); displayNextLCDString("Red Middle");
			break;
		case 3:
			displayLCDPos(0,0); displayNextLCDString("Bule Hanging");
			break;
		case 4:
			displayLCDPos(0,0); displayNextLCDString("Blue Middle");
			break;
		case 5:
			displayLCDPos(0,0); displayNextLCDString("Challenge");
			break;
		case 6:
			displayLCDPos(0,0); displayNextLCDString("Challenge Risk");
			break;

		}
		while(nLCDButtons!=LCD_left)
		{
			//clearLCDLine(1);
			sprintf(mBattery, "%1.2f%c", nImmediateBatteryLevel/1000.0);
			sprintf(eBattery, "%1.2f%c", (SensorValue[nPowerex]/284.0));
			displayLCDString(1,0,mBattery);
			displayLCDString(1,5,eBattery);
			if(hangmode)
				displayLCDString(1,10,"hang");
			else
				displayLCDString(1,10,"normal");
			wait10Msec(10);
		}
		StartingTile++;
		while(nLCDButtons==LCD_left){}
		wait10Msec(50);

		if(StartingTile>6)
			StartingTile=1;

	}
}

task autonomous()
{
	//unfold
	liftDa=false;
	StopTask(usercontrol);
	StopTask(raiseOrLowerArm);
	StartTask(projectile);
	//	StartTask(shift);

	switch(StartingTile)
	{
	case 1:
		GoRH();
		break;
	case 2:
		GoRM();
		break;
	case 3:
		GoBH();
		break;
	case 4:
		GoBM();
		break;
	case 5:
		GoSkill();
		break;
	case 6:
		GoSkillRisk();
		break;
	default:
		break;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////
void winchup (int howfar)
{
	winchgood=false;
	SensorValue[winchencoder]=0;
	while(SensorValue[winchencoder]<=howfar){motor[backLeft]=motor[backRight]=-128;}
	motor[backLeft]=motor[backRight]=0;
	winchgood=true;

}

task usercontrol()
{
	kMaxPos = 3000;
	StartTask(raiseOrLowerArm);
	StartTask(projectile);
	StartTask(autoslection);
	StartTask(shift);
	StartTask(masterreset);
	//	StartTask(tune);
	while(true) //Loop forever
	{
		mecanumdrive();
		joystick=vexRT[Ch2];
		if(vexRT[Btn5U] == 1)
			motor[roller] = 127;
		else if(vexRT[Btn5D] == 1)
			motor[roller] = -127;
		else
			motor[roller] = 0;

		if(vexRT[Btn8DXmtr2]==1)
			kMaxPos=2400;
		else
			kMaxPos=2845;
		if(hangmode)
		{
			motor[armmotR]=vexRT[Ch3Xmtr2];
			motor[armmotL]=vexRT[Ch2Xmtr2];
			motor[conveyor] =0;
		}
		else
			motor[conveyor] = vexRT[Ch3Xmtr2];
		if(SensorValue[armPotentiometerL]<=1500&!hangmode)
		{
			liftDa=true;
			if(joystick<=-70)
				motor[armmotL]=motor[armmotR]=joystick/3;
			else if(joystick>=100)
				motor[armmotL]=motor[armmotR]=joystick;
			else
				motor[armmotL]=motor[armmotR]=0;
		}
		else if(SensorValue[armPotentiometerL]>=1500&!hangmode)
		{
			liftDa=false;
		}
	}
}



void mecanumdrive()
{
	int X2 = 0, Y1 = 0, X1 = 0, threshold = 25;
	if(abs(vexRT[Ch3]) > threshold)
		Y1 = vexRT[Ch3];
	else
		Y1 = 0;
	if(abs(vexRT[Ch4]) > threshold)
		X1 = vexRT[Ch4];
	else
		X1 = 0;
	if(abs(vexRT[Ch1]) > threshold)
		X2 = vexRT[Ch1];
	else
		X2 = 0;
	if(hangmode&winchgood)
	{
		motor[frontLeft] = Y1 + X2 + X1;
		motor[frontRight] = Y1 - X2 - X1;
		motor[backRight] =  vexRT[Ch2];
		motor[backLeft] =  vexRT(Ch2);
	}
	else if(hangmode&!winchgood)
	{
		motor[frontLeft] = Y1 + X2 + X1;
		motor[frontRight] = Y1 - X2 - X1;
	}
	else if(!hangmode)
	{
		motor[frontLeft] = Y1 + X2 + X1;
		motor[frontRight] = Y1 - X2 - X1;
		motor[backRight] =  Y1 - X2 + X1;
		motor[backLeft] =  Y1 + X2 - X1;
	}
}

void GoSkill()
{
	kMaxPos=3000;
	StartTask(raiseOrLowerArm);
	motor[roller]=127;
	motor[conveyor]=-80;
	wait10Msec(30);
	motor[conveyor]=0;
	forward(127,500);
	joystick=-128;
	forward(80,200);
	joystick=0;
	StopTask(raiseOrLowerArm);
	motor[armmotL]=motor[armmotR]=0;
	backward(128,730);
	motor[roller]=0;
	turn(128,-150);


	while(!SensorValue[GO]){}
	StartTask(raiseOrLowerArm);
	forward(128,1500);
	turn(128,-20);
	joystick=128;
	while(SensorValue[armPotentiometerL]<2700);
	forward(128,500);
	motor[roller]=-128;
	motor[conveyor]=-128;
	wait10Msec(200);
	backward(128,400);
	joystick=-128;
	motor[roller]=0;
	motor[conveyor]=0;
	turn(128,15);
	while(SensorValue[armPotentiometerL]>1400){
		joystick=-128;}
	wait10Msec(50);
	joystick=0;
	StopTask(raiseOrLowerArm);
	motor[armmotL]=motor[armmotR]=0;
	backward(128,1400);
	turn(128,157);
	forward(128,200);



	while(!SensorValue[GO]){}
	StartTask(raiseOrLowerArm);
	motor[roller]=128;
	forward(127,500);
	forward(80,200);
	joystick=-128;
	forward(40,550);
	wait10Msec(60);
	joystick=0;
	StopTask(raiseOrLowerArm);
	motor[armmotL]=motor[armmotR]=0;
	backward(128,1400);
	turn(128,-150);


	while(!SensorValue[GO]){}
	StartTask(raiseOrLowerArm);
	forward(128,1500);
	turn(128,-20);
	joystick=128;
	while(SensorValue[armPotentiometerL]<2700);
	forward(128,500);
	motor[roller]=-128;
	motor[conveyor]=-128;
	wait10Msec(200);
	backward(128,400);
	joystick=-128;
	motor[roller]=0;
	motor[conveyor]=0;
	turn(128,15);
	while(SensorValue[armPotentiometerL]>1400){
		joystick=-128;}
	wait10Msec(50);
	joystick=0;
	StopTask(raiseOrLowerArm);
	motor[armmotL]=motor[armmotR]=0;
	backward(128,1400);
	turn(128,-20);



	while(!SensorValue[GO]);
	StartTask(raiseOrLowerArm);
	kMaxPos=2400;
	joystick=128;
	wait10Msec(80);
	forward(127,700);
	backward(127,550);
	turn(128,50);
	forward(128,900);
	backward(128,500);
	backward(128,500);
	turn(128,20);




	while(!SensorValue[GO]);
	kMaxPos=2400;
	motor[conveyor]=0;
	motor[roller]=-128;
	forward(128,2200);
	joystick=128;
	backward(128,300);
	joystick=-0;
	turn(128,30);
	forward(128,1400 );
	turn(128,-90);
	forward(128,300);
}


void GoSkillRisk()
{
	kMaxPos=3000;
	StartTask(raiseOrLowerArm);
	motor[roller]=127;
	motor[conveyor]=-80;
	wait10Msec(30);
	motor[conveyor]=0;
	forward(127,500);
	joystick=-128;
	forward(80,200);
	joystick=0;
	backward(128,730);
	motor[roller]=0;
	turn(128,-150);




	while(!SensorValue[GO]){}
	forward(128,1500);
	turn(128,-18);
	joystick=128;
	while(SensorValue[armPotentiometerL]<2700);
	forward(128,500);
	motor[roller]=-128;
	motor[conveyor]=-128;
	wait10Msec(200);
	backward(128,400);
	joystick=-128;
	motor[roller]=0;
	motor[conveyor]=0;
	turn(128,13);
	while(SensorValue[armPotentiometerL]>1350){
		joystick=-128;}
	backward(128,600);
	joystick=0;
	backward(128,800);
	turn(128,157);
	forward(128,200);




	while(!SensorValue[GO]){}
	motor[roller]=128;
	forward(127,500);
	forward(80,200);
	joystick=-128;
	forward(40,550);
	wait10Msec(60);
	joystick=-0;
	backward(128,450);
	turn(128,-88);
	motor[roller]=10;//intake
	forward(128,550);
	turn(128,-88);

	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=98;
	wait10Msec(10);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	wait10Msec(10);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=98;
	wait10Msec(10);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	wait10Msec(10);


	forward(80,850);
	joystick=-128;
	forward(128,500);
	joystick=0;
	forward(128,650);
	joystick=128;
	while(SensorValue[armPotentiometerL]<2700);
	forward(50,150);
	forward(128,400);
	motor[roller]=-128;
	motor[conveyor]=-128;
	wait10Msec(200);
	backward(128,400);
	joystick=-128;
	motor[roller]=0;
	motor[conveyor]=0;
	turn(128,13);
	while(SensorValue[armPotentiometerL]>1400)
		joystick= -128;
	wait10Msec(50);
	joystick=0;
	backward(128,1400);
	turn(128,-20);



	while(!SensorValue[GO]);
	kMaxPos=2400;
	joystick=128;
	wait10Msec(80);
	forward(127,700);
	backward(127,550);
	turn(128,50);
	forward(128,900);
	backward(128,500);
	backward(128,500);
	turn(128,20);



	while(!SensorValue[GO]);
	kMaxPos=2400;
	motor[conveyor]=0;
	motor[roller]=0;
	forward(128,2200);
	joystick=128;
	backward(128,300);
	joystick=-0;
	turn(128,20);
	forward(128,1400);
	turn(128,-90);
	forward(128,300);
}
void GoRH()
{
	kMaxPos=3000;
	StartTask(raiseOrLowerArm);
	motor[roller]=127;//intake
	motor[conveyor]=-8;
	wait10Msec(40);	//unfold
	motor[conveyor]=0;
	forward(127,300);

	joystick=-128;
	forward(40,230);

	wait10Msec(100);
	joystick=-0;
	StopTask(raiseOrLowerArm);
	motor[armmotL]=motor[armmotR]=0;
	backward(128,450);
	turn(128,-85);
	motor[roller]=10;//intake

	while(!SensorValue[GO]){}
	forward(128,620);
	turn(128,-88);

	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=98;
	wait10Msec(10);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	wait10Msec(10);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=98;
	wait10Msec(10);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	wait10Msec(10);


	forward(80,850);
	StartTask(raiseOrLowerArm);
	joystick=-128;
	forward(128,500);
	joystick=0;
	forward(128,650);
	joystick=128;
	while(SensorValue[armPotentiometerL]<2700);
	forward(50,150);
	forward(128,400);
	motor[roller]=-128;
	motor[conveyor]=-128;
}


void GoRM()
{
	kMaxPos=2400;
	StartTask(raiseOrLowerArm);
	motor[roller]=127;//intake
	//	motor[conveyor]=-60;
	joystick=128;
	wait10Msec(80);
	//	motor[conveyor]=0;
	motor[roller]=0;
	//unfold
	forward(127,700);
	backward(127,550);
	turn(128,50);
	forward(128,900);

	backward(128,400);
	joystick=-128;
	backward(128,400);
	turn(128,-20);
	while(SensorValue[armPotentiometerL]>1400)
		joystick=0;
	StopTask(raiseOrLowerArm);
	motor[armmotL]=motor[armmotR]=-30;
	wait10Msec(30);
	motor[armmotL]=motor[armmotR]=0;
	while(!SensorValue[GO]){}


	forward(128,1550);
	StartTask(raiseOrLowerArm);
	turn(128,-18);
	kMaxPos=2950;
	joystick=128;
	while(SensorValue[armPotentiometerL]<2700);
	forward(128,400);
	motor[roller]=-128;
	motor[conveyor]=-128;
}


void GoBH()
{
	kMaxPos=3000;
	StartTask(raiseOrLowerArm);
	motor[roller]=127;//intake
	motor[conveyor]=-8;
	wait10Msec(40);	//unfold
	motor[conveyor]=0;
	forward(127,300);

	joystick=-128;
	forward(40,230);

	wait10Msec(100);
	joystick=-0;
	StopTask(raiseOrLowerArm);
	motor[armmotL]=motor[armmotR]=0;
	backward(128,450);
	turn(128,88);
	motor[roller]=10;//intake
	while(!SensorValue[GO]){}
	forward(128,625);
	turn(128,90);


	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=98;
	wait10Msec(10);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	wait10Msec(10);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=98;
	wait10Msec(10);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	wait10Msec(10);


	forward(80,850);
	StartTask(raiseOrLowerArm);
	joystick=-128;
	forward(128,500);
	joystick=0;
	forward(128,650);
	joystick=128;
	//	turn(128,-2);
	while(SensorValue[armPotentiometerL]<2700);
	forward(50,170);
	forward(128,400);
	motor[roller]=-128;
	motor[conveyor]=-128;
}



void GoBM()
{
	kMaxPos=2400;
	StartTask(raiseOrLowerArm);
	motor[roller]=127;//intake
	//	motor[conveyor]=-60;
	joystick=128;
	wait10Msec(80);
	//	motor[conveyor]=0;
	motor[roller]=0;
	//unfold
	forward(127,700);
	backward(127,550);
	turn(128,-50);
	forward(128,900);

	backward(128,400);
	joystick=-128;
	backward(128,400);
	turn(128,20);
	while(SensorValue[armPotentiometerL]>1400)
		joystick=0;
	StopTask(raiseOrLowerArm);
	motor[armmotL]=motor[armmotR]=-30;
	wait10Msec(30);
	motor[armmotL]=motor[armmotR]=0;
	while(!SensorValue[GO]){}


	forward(128,1700);
	StartTask(raiseOrLowerArm);
	turn(128,15);
	kMaxPos=2950;
	joystick=128;
	while(SensorValue[armPotentiometerL]<2700);
	forward(128,400);
	motor[roller]=-128;
	motor[conveyor]=-128;
}



void turn(int power,float angle)
{
	int decidegrees = 10*angle;
	int error = 3;

	//While the absolute value of the gyro is less than the desired rotation - 100...
	if(decidegrees>=0)
	{
		decidegrees=(float)decidegrees+(decidegrees/900)*gyrocorrection;
		SensorValue[gyro]=0;
		while(abs(SensorValue[gyro]) < decidegrees-100 )
		{
			motor[frontRight] = -power;
			motor[backRight] = -power;
			motor[frontLeft] = power;
			motor[backLeft] = power;
		}
		motor[frontRight] = 5;
		motor[backRight] = 5;
		motor[frontLeft] = -5;
		motor[backLeft] = -5;
		wait1Msec(100);

		ClearTimer(T1);
		while(SensorValue[gyro] > decidegrees + error || SensorValue[gyro] < decidegrees - error)
		{
			if(SensorValue[gyro] < decidegrees)
			{
				motor[frontRight] = -40;
				motor[backRight] = -40;
				motor[frontLeft] = 40;
				motor[backLeft] = 40;
			}
			else
			{
				motor[frontRight] = 40;
				motor[backRight] = 40;
				motor[frontLeft] = -40;
				motor[backLeft] = -40;
			}
		}
	}
	else
	{

		decidegrees=decidegrees-gyrocorrection;
		SensorValue[gyro]=0;
		wait1Msec(1);
		while(SensorValue[gyro] > decidegrees+100 )
		{
			wait1Msec(1);
			motor[frontRight] = power;
			motor[backRight] = power;
			motor[frontLeft] = -power;
			motor[backLeft] = -power;
		}
		motor[frontRight] = -5;
		motor[backRight] = -5;
		motor[frontLeft] = 5;
		motor[backLeft] = 5;
		wait1Msec(100);
		ClearTimer(T1);
		while(SensorValue[gyro] > decidegrees + error || SensorValue[gyro] < decidegrees - error)
		{
			if(SensorValue[gyro] < decidegrees)
			{
				motor[frontRight] = -40;
				motor[backRight] = -40;
				motor[frontLeft] = 40;
				motor[backLeft] = 40;
			}
			else
			{
				motor[frontRight] = 40;
				motor[backRight] = 40;
				motor[frontLeft] = -40;
				motor[backLeft] = -40;
			}
		}

	}
	motor[frontRight] = 0;
	motor[backRight] = 0;
	motor[frontLeft] = 0;
	motor[backLeft] = 0;

}


void drift(int power, int howfar)
{
	SensorValue[gyro]=0;
	nMotorEncoder[backRight] = 0;
	nMotorEncoder[backLeft] = 0;
	if(howfar>0)
	{
		while(nMotorEncoder[backRight] < (howfar-15))
		{
			motor[frontLeft]=motor[backRight]=127;
			motor[backLeft]=motor[frontRight]=-127;
		}
		motor[frontRight] = 0;
		motor[backRight] = 0;
		motor[frontLeft] = 0;
		motor[backLeft] = 0;
		ClearTimer(T1);
		if(SensorValue[gyro] > 0)
		{
			while(SensorValue[gyro]>10|SensorValue[gyro]<-10)
			{
				motor[frontRight] = 30;
				motor[backRight] = 30;
				motor[frontLeft] = -30;
				motor[backLeft] = -30;
				if(time10[T1]>howfar/2){break;}
			}
		}
		else
		{
			while(SensorValue[gyro]>10|SensorValue[gyro]<-10)
			{
				motor[frontRight] = -40;
				motor[backRight] = -40;
				motor[frontLeft] = 40;
				motor[backLeft] = 40;
				if(time10[T1]>howfar/2){break;}
			}
		}
		motor[frontRight] = 0;
		motor[backRight] = 0;
		motor[frontLeft] = 0;
		motor[backLeft] = 0;
	}
	else
	{
		while(nMotorEncoder[backRight] > (howfar+15))
		{
			motor[frontLeft]=motor[backRight]=-127;
			motor[backLeft]=motor[frontRight]=+127;
		}
		motor[frontRight] = 0;
		motor[backRight] = 0;
		motor[frontLeft] = 0;
		motor[backLeft] = 0;
		ClearTimer(T1);
		if(SensorValue[gyro] > 0)
		{
			while(SensorValue[gyro]>10|SensorValue[gyro]<-10)
			{
				motor[frontRight] = 30;
				motor[backRight] = 30;
				motor[frontLeft] = -30;
				motor[backLeft] = -30;
				if(time10[T1]>howfar/2){break;}
			}
		}
		else
		{
			while(SensorValue[gyro]>10|SensorValue[gyro]<-10)
			{
				motor[frontRight] = -30;
				motor[backRight] = -30;
				motor[frontLeft] = 30;
				motor[backLeft] = 30;
				if(time10[T1]>howfar/2){break;}
			}
		}
		motor[frontRight] = 0;
		motor[backRight] = 0;
		motor[frontLeft] = 0;
		motor[backLeft] = 0;
	}
}

void forward(int power,int howfar)
{
	nMotorEncoder[backRight] = 0;
	nMotorEncoder[backLeft] = 0;
	while(nMotorEncoder[backRight] < (howfar-10) | nMotorEncoder[backLeft] < (howfar-10))
	{
		if(nMotorEncoder[backRight] < howfar ){
			motor[backRight] = power;
			motor[frontRight] = power;}
		else {
			motor[backRight] = 0;
			motor[frontRight] = 0;}

		if(nMotorEncoder[backLeft] < howfar ){
			motor[backLeft] = power;
			motor[frontLeft] = power;}
		else {
			motor[backLeft] = 0;
			motor[frontLeft] = 0;}
	}
	motor[frontRight] = 0;
	motor[backRight] = 0;
	motor[frontLeft] = 0;
	motor[backLeft] = 0;
}

void backward(int power,int howfar)
{
	nMotorEncoder[backRight] = 0;
	nMotorEncoder[backLeft]  = 0;
	while(nMotorEncoder[backRight] > (-howfar+15) | nMotorEncoder[backLeft] > (-howfar+15))
	{
		if(nMotorEncoder[backRight] > -howfar ){
			motor[backRight] = -power;
			motor[frontRight] = -power;}
		else if(nMotorEncoder[backRight]<-howfar){
			motor[backRight] = 0;
			motor[frontRight] = 0;}

		if(nMotorEncoder[backLeft] > -howfar ){
			motor[backLeft] = -power;
			motor[frontLeft] = -power;}
		else if(nMotorEncoder[backLeft]<-howfar){
			motor[backLeft] = 0;
			motor[frontLeft] = 0;}
	}
	motor[frontRight] = 0;
	motor[backRight] = 0;
	motor[frontLeft] = 0;
	motor[backLeft] = 0;
}



//-----------------------------------------------------------------------------------

task projectile()
{
	while(1){
		while(vexRT[Btn7DXmtr2] == 1|fire)         // If button 6U (upper right shoulder button) is pressed:
		{
			SensorValue[solenoid] = 1;
			SensorValue[solenoid2] = 1;  // ...activate the solenoid.
			encoderL=nMotorEncoder[backLeft];
			encoderR=nMotorEncoder[backRight];
			gyroref=SensorValue[gyro];
		}
		gyroref=SensorValue[gyro];
		SensorValue[solenoid] = 0;
		SensorValue[solenoid2] = 0;
		encoderL=nMotorEncoder[backLeft];
		encoderR=nMotorEncoder[backRight];
	}
}
task shift()
{
	while(true){
		while(vexRT[Btn7U] == 0)
		{
			if(vexRT[Btn8R])//hangmode
			{
				while(vexRT[Btn8R]){}
				liftDa=true;
				hangmode=true;
				motor[backLeft]=motor[backRight]=128;
				wait10Msec(10);
				motor[backLeft]=motor[backRight]=-128;
				SensorValue[solenoid3]=1;
				StopTask(raiseOrLowerArm);
				motor[backLeft]=motor[backRight]=128;
				wait10Msec(10);
				motor[backLeft]=motor[backRight]=-128;
				wait10Msec(10);
				motor[backLeft]=motor[backRight]=128;
				wait10Msec(10);
				motor[backLeft]=motor[backRight]=-128;
				wait10Msec(10);
				motor[backLeft]=motor[backRight]=0;
				winchup(1000);
			}
		}
		SensorValue[solenoid3] =!SensorValue[solenoid3];
		while(vexRT[Btn7U] == 1){}

	}
}


task masterreset()
{
	while(1){
		while(vexRT[Btn8U] == 1){}
		while(vexRT[Btn8U] == 0){}
		StopTask(raiseOrLowerArm);
		StopTask(usercontrol);
		StopTask(shift);
		StopTask(projectile);
		StopTask(autoslection);
		StartTask(raiseOrLowerArm);
		StartTask(usercontrol);
		StartTask(shift);
		StartTask(projectile);
		StartTask(autoslection);

		hangmode=winchgood=false;
		liftDa=false;
		SensorValue[solenoid3]=0;
	}
}
//-----------------------------------------------------------------------------------

task raiseOrLowerArm()
{
	const int kSlowSpeedRange = 10;
	const int kMinPos = 1320;

	const int kSlowSpeedPosLowering = kMinPos + kSlowSpeedRange;
	const int kSlowSpeedRaising     = kMaxPos - kSlowSpeedRange;

	const int kMotorSpeedUp   = +127;
	const int kMotorSpeedDown = -127;
	float ITerm;
	const float outMax=128,outMin=-128;
	int nPositionToHold;
	bool bLastUpdateWasButtonPress = false;
	bool bButtonsHaveBeenPressed   = false;
	while(true)
	{
		while(liftDa){}
		if (joystick <= -90)// button is puchsed indicating ARM should be lowered
		{
			if (SensorValue[armPotentiometerL] < kMinPos)
			{
				motor[armmotL] = 0; // Arm is fully lowered. Stop the motor
			}
			else if (SensorValue[armPotentiometerL] < kSlowSpeedPosLowering)
				motor[armmotL] = kMotorSpeedDown / 2;
			else
				motor[armmotL] = kMotorSpeedDown;
			if (SensorValue[armPotentiometerR] < kMinPos)
			{
				motor[armmotR] = 0; // Arm is fully lowered. Stop the motor
			}
			else if (SensorValue[armPotentiometerR] < kSlowSpeedPosLowering)
				motor[armmotR] = kMotorSpeedDown / 2;
			else
				motor[armmotR] = kMotorSpeedDown;
			nPositionToHold = ((SensorValue[armPotentiometerL]+SensorValue[armPotentiometerR])/2+10);
			bLastUpdateWasButtonPress = true;
		}

		else if (joystick >= 90)// button is puchsed indicating ARM should be raised
		{
			if (SensorValue[armPotentiometerL] > kMaxPos)
			{
				motor[armmotL] = 10;// Arm is fully raised. Stop the motor
			}
			else if (SensorValue[armPotentiometerL] > kSlowSpeedRaising)
				motor[armmotL] = kMotorSpeedUp / 2;
			else
				motor[armmotL] = kMotorSpeedUp;
			if (SensorValue[armPotentiometerR] > kMaxPos)
			{
				motor[armmotR] = 10;// Arm is fully raised. Stop the motor
			}
			else if (SensorValue[armPotentiometerR] > kSlowSpeedRaising)
				motor[armmotR] = kMotorSpeedUp / 2;
			else
				motor[armmotR] = kMotorSpeedUp;
			bLastUpdateWasButtonPress = true;
			nPositionToHold = ((SensorValue[armPotentiometerL]+SensorValue[armPotentiometerR])/2)+10;
		}


		else// No buttons are pushed.
		{


			if (bLastUpdateWasButtonPress) // A button has just been released.- Remember the position.-- Stop motor
			{
				bLastUpdateWasButtonPress = false;
				if (nPositionToHold < kMinPos)
					nPositionToHold = kMinPos;
				else if (nPositionToHold > kMaxPos)
					nPositionToHold = kMaxPos;
				motor[armmotL] = 0;
				motor[armmotR] = 0;
				ClearTimer(T1);
				bButtonsHaveBeenPressed = true;
			}
			else if (bButtonsHaveBeenPressed)
			{


				unsigned long now = time1[T1];
				long lastInput;
				unsigned long lastTime;
				unsigned long SampleTime=10;

				unsigned long timeChange = (now - lastTime);
				if(timeChange>=SampleTime)
				{
					static float input = (SensorValue[armPotentiometerL]+SensorValue[armPotentiometerR])/2;
					static float error = nPositionToHold - input;

					ITerm+= (ki * error);
					if(ITerm > outMax) ITerm= outMax;
					else if(ITerm < outMin) ITerm= outMin;
					float dInput = (input - lastInput);
					/*Compute PID Output*/
					float output = kp * error + ITerm- kd * dInput;
					if(output > outMax) output = outMax;
					else if(output < outMin) output = outMin;
					motor[armmotL]= motor[armmotR]= output;
					lastInput = input;
					lastTime = now;
				}
				//writeDebugStreamLine("		%1.2f",(float)kp * errorL);
				//writeDebugStream("		%1.2f",ITermL);
				//writeDebugStream("		%1.2f",(float)kd * dInputL);
				//	writeDebugStream("		%1.2f",outputL);
				//		writeDebugStreamLine("		%d",SensorValue[armPotentiometerL]);
				//		writeDebugStream("		%d",nPositionToHold);

				//		if(abs(SensorValue[armPotentiometerL]-nPositionToHold)<20)
				//		motor[armmotL] = 8;
				//else




				/*		float inputR = SensorValue[armPotentiometerR];
				float errorR = nPositionToHold - inputR;
				if(errorR>0&errorR-20>0)errorR=errorR-20;
				else if(errorR<0&errorR+20<0)errorR=errorR+20;
				else errorR=0;
				ITermR+= (ki * errorR);
				if(ITermR > outMax) ITermR= outMax;
				else if(ITermR < outMin) ITermR= outMin;
				float dInputR = (inputR - lastInputR);

				//Compute PID Output
				float outputR = kp * errorR + ITermR- kd * dInputR;

				if(outputR > outMax) outputR = outMax;
				else if(outputR < outMin) outputR = outMin;
				//if(abs(SensorValue[armPotentiometerR]-nPositionToHold)<20)
				//motor[armmotR] = 8;
				//else
				motor[armmotR] = outputR;

				//Remember some variables for next time
				lastInputR = inputR;
				lastTime = now;*/

			}
			else
			{
			}
		}
	}
}


//-----------------------------------------------------------------------------------

task raiseOrLowerArmR()
{

}

void toLine(int power)
{
	bool passL=false,passR=false;
	while(!passL & !passR)
	{
		if(SensorValue[LineR] > linethreshold){
			motor[backRight] = power;
			motor[frontRight] = power;}
		if(SensorValue[LineR] < linethreshold){
			passR=true;
			motor[backRight] = 0;
			motor[frontRight] = 0;}

		if(SensorValue[LineL] > linethreshold){
			motor[backLeft] = power;
			motor[frontLeft] = power;}
		if(SensorValue[LineL] < linethreshold){
			passL=true;
			motor[backLeft] = 0;
			motor[frontLeft] = 0;}
	}
	if(SensorValue[LineR] < linethreshold){
		passR=true;
		motor[backRight] = 0;
		motor[frontRight] = 0;}
	motor[frontRight] = -power/3;
	motor[backRight] = -power/3;
	motor[frontLeft] = -power/3;
	motor[backLeft] = -power/3;
	wait10Msec(6);
	motor[frontRight] = 0;
	motor[backRight] = 0;
	motor[frontLeft] = 0;
	motor[backLeft] = 0;


	if(!passL){
		while(!passL){
			if(SensorValue[LineL] > linethreshold){
				motor[backLeft] = 1.5*power;
				motor[frontLeft] = 1.5*power;}
			if(SensorValue[LineL] < linethreshold){
				passL=true;
				motor[backLeft] = 0;
				motor[frontLeft] = 0;
				passR=false;
				while(!passR){
					if(SensorValue[LineR] > linethreshold){
						motor[backRight] = -1.5*power;
						motor[frontRight] = -1.5*power;}
					if(SensorValue[LineR] < linethreshold){
						passR=true;
						motor[backRight] = 0;
						motor[frontRight] = 0;}
				}
				passL=false;
				while(!passL){
					if(SensorValue[LineL] > linethreshold){
						motor[backLeft] = 1.5*power;
						motor[frontLeft] = 1.5*power;}
					if(SensorValue[LineL] < linethreshold){
						passL=true;
						motor[backLeft] = 0;
						motor[frontLeft] = 0;}
				}
				passR=false;
				while(!passR){
					if(SensorValue[LineR] > linethreshold){
						motor[backRight] = -1.5*power;
						motor[frontRight] = -1.5*power;}
					if(SensorValue[LineR] < linethreshold){
						passR=true;
						motor[backRight] = 0;
						motor[frontRight] = 0;}
				}
			}
		}
	}
	if(!passR){
		while(!passR){
			if(SensorValue[LineR] > linethreshold){
				motor[backRight] = 1.5*power;
				motor[frontRight] = 1.5*power;}
			if(SensorValue[LineR] < linethreshold){
				passR=true;
				motor[backRight] = 0;
				motor[frontRight] = 0;
				passL=false;
				while(!passL){
					if(SensorValue[LineL] > linethreshold){
						motor[backLeft] = -1.5*power;
						motor[frontLeft] = -1.5*power;}
					if(SensorValue[LineL] < linethreshold){
						passL=true;
						motor[backLeft] = 0;
						motor[frontLeft] = 0;}
				}
				passR=false;
				while(!passR){
					if(SensorValue[LineR] > linethreshold){
						motor[backRight] = 1.5*power;
						motor[frontRight] = 1.5*power;}
					if(SensorValue[LineR] < linethreshold){
						passR=true;
						motor[backRight] = 0;
						motor[frontRight] = 0;}
				}
				passL=false;
				while(!passL){
					if(SensorValue[LineL] > linethreshold){
						motor[backLeft] = -1.5*power;
						motor[frontLeft] = -1.5*power;}
					if(SensorValue[LineL] < linethreshold){
						passL=true;
						motor[backLeft] = 0;
						motor[frontLeft] = 0;}
				}
			}
		}
	}
}
