#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    forkPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, in3,    LineL,          sensorLineFollower)
#pragma config(Sensor, in4,    LineM,          sensorLineFollower)
#pragma config(Sensor, in5,    LineR,          sensorLineFollower)
#pragma config(Sensor, in6,    LineB,          sensorLineFollower)
#pragma config(Sensor, in7,    nPowerex,       sensorAnalog)
#pragma config(Sensor, in8,    armPotentiometerL, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  GOL,            sensorTouch)
#pragma config(Sensor, dgtl2,  solDump,        sensorDigitalOut)
#pragma config(Sensor, dgtl3,  solShift,       sensorDigitalOut)
#pragma config(Sensor, dgtl4,  fork2,          sensorDigitalOut)
#pragma config(Sensor, dgtl5,  fork1,          sensorDigitalOut)
#pragma config(Sensor, dgtl6,  solBig,         sensorDigitalOut)
#pragma config(Sensor, dgtl7,  solBreak,       sensorDigitalOut)
#pragma config(Sensor, dgtl8,  solLock,        sensorDigitalOut)
#pragma config(Sensor, dgtl9,  pWarning,       sensorLEDtoVCC)
#pragma config(Sensor, dgtl10, prgenc,         sensorQuadEncoder)
#pragma config(Sensor, dgtl12, GOR,            sensorTouch)
#pragma config(Sensor, I2C_1,  rightIEM,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  leftIEM,        sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           frontRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           backRight,     tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port4,           roller,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           armmotL,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           fork,          tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           armmotR,       tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           backLeft,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port9,           frontLeft,     tmotorVex393_MC29, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#define LCD_left nLCDButtons==0x01
#define LCD_mid nLCDButtons==0x02
#define LCD_right nLCDButtons==0x04
#define eyeL (SensorValue[LineL]<threshold)
#define eyeM (SensorValue[LineM]<threshold)
#define eyeR (SensorValue[LineR]<threshold)
#define eyeB (SensorValue[LineB]<threshold)

#include "Vex_Competition_Includes.c"//Main competition background code...do not modify!
//#include "Dennis++_v1.0.h"


//autonumos options
void GoRH();
void GoRM();
void GoBH();
void GoBM();
void GoRH2();
void GoBH2();
void GoDrive();
void GoSkill();
void GoSkillRisk();

//calibration mothods
void gyrocali();
void encodercali();

//maneuver mothods
void drift(int power, int howfar);
void forward(int power,int howfar);
void backward(int power,int howfar);
void turn(int power ,float angle);
void turnPCS90(int power,float angle);
void turnPCS45(int power,float angle);
void turnIEC(int power,int degrees);

//breaking mothods
void breakDrive();
void breakDrivet();
void breakDrivesideL();
void breakDrivesideR();

//line tracking mothods
void turnthenfollow(int power,int howfar,int approx);
int forwardLine(int power,int howfar,int lastinput);

void securedDump();
void autohang();

//servace/background tasks
task raiseOrLowerArm();
task masterreset();
task autoslection();
task shift();
task raiseOrLowerFork();
task openFork();
task visualMem();


//global variable delarations
int threshold=1600,lfc=0;
int gyrocorrection=0,joystick,joystickf,StartingTile,encoderL,encoderR,gyroref,kMaxPos = 3000,linethreshold=2400;
bool fire=false,liftDa=false,hangmode=false,skipcali=false,openup=false,lockarm=false,prehangmode=false;
bool eyeLm=false,eyeMm=false,eyeRm=false,eyeBm=false,memEn=false;//eye memory section;
float ki=0.0001,kd=0.40,kp=0.48;//arm PID consts
float kdf=0,kpf=0.17,kif=0;//fork PID consts
float kil=0.00,kdl=0,kpl=4;// Line following PID consts
int kMaxPosf = 1500;
int nPositionToHold;
int nPositionToHoldf;
int kMotorSpeedUp   = +127;
int battStd;
int inputl;


void pre_auton()
{
	SensorValue[solShift]=0;
	clearLCDLine(0);
	clearLCDLine(1);// Set bstopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	SensorType[in2] = sensorNone;
	SensorType[in8] = sensorNone;
	wait1Msec(1000);
	//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
	SensorType[in2] = sensorGyro;
	SensorType[in8] = sensorPotentiometer;
	battStd=nAvgBatteryLevel;

	wait1Msec(400);
	SensorValue[gyro]=0;
	SensorValue[solDump]=1;
	bStopTasksBetweenModes = true;
	bLCDBacklight = true;
	StartingTile=7;
	startTask(masterreset);
	startTask(autoslection);

	//	startTask(tune);
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task

task autoslection()
{
	string mBattery,eBattery,fkpt;
	wait1Msec(10);
	while(1){
		while(nLCDButtons!=kButtonLeft)
		{
			//clearLCDLine(1);
			sprintf(mBattery, "%1.2f%c", nAvgBatteryLevel/1000.0);
			sprintf(eBattery, " %1.2f%c", (SensorValue[nPowerex]/284.0));
			sprintf(fkpt, " %4.0f%c ", (SensorValue[forkPot]));

			displayLCDString(1,0,mBattery);
			displayLCDString(1,5,eBattery);

			displayLCDString(1,11,fkpt);
			if(LCD_mid)
			{
				while(LCD_mid);
				gyrocali();

			}
			if(LCD_right)
			{
				while(LCD_right);
				encodercali();
			}
			wait1Msec(1);
			clearLCDLine(0);
			switch (StartingTile){
			case 1:
				displayLCDPos(0,0); displayNextLCDString("Red Hanging");
				break;
			case 2:
				displayLCDPos(0,0); displayNextLCDString("Red Hanging 2");
				break;
			case 3:
				displayLCDPos(0,0); displayNextLCDString("Red Middle");
				break;
			case 4:
				displayLCDPos(0,0); displayNextLCDString("Blue Hanging");
				break;
			case 5:
				displayLCDPos(0,0); displayNextLCDString("Blue Hanging 2");
				break;
			case 6:
				displayLCDPos(0,0); displayNextLCDString("Blue Middle");
				break;
			case 7:
				displayLCDPos(0,0); displayNextLCDString("Challenge");
				break;
			case 8:
				displayLCDPos(0,0); displayNextLCDString("Challenge Risk");
				break;

			}
		}
		StartingTile++;
		while(LCD_left){}
		wait1Msec(1);

		if(StartingTile>8)
			StartingTile=1;
	}
}

task autonomous()
{
	//unfold
	liftDa=false;
	stopTask(usercontrol);
	stopTask(raiseOrLowerArm);
	//	startTask(shift);

	switch(StartingTile)
	{
	case 1:
		GoRH();
		break;
	case 2:
		GoRH2();
		break;
	case 3:
		GoRM();
		break;
	case 4:
		GoBH();
		break;
	case 5:
		GoBH2();
		break;
	case 6:
		GoBM();
		break;
	case 7:
		GoSkill();
		break;
	case 8:
		GoSkillRisk();
		break;
	default:
		break;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
task pMonitor()
{

	int cBig=0,cDump=0,cFork=0,cBreak=0,cLock=0,cShift=0;
	float pLord;
	bool bBig,bDump,bFork,bBreak,bLock,bShift;
	const float pInit=100.0,pThresh=45.0;//psi
	const float kBig=1.0,kDump=0.8,kFork=0.5,kBreak=0.25,kLock=0.5,kShift=0.5;
	//          2 dbl    2 dbl     2 sgl       1 sgl       1 dbl      1 dbl
	bool tooLow=false;

	while(1)
	{
		bBig=(bool)SensorValue[solBig];
		bDump=(bool)SensorValue[solDump];
		bFork=(bool)SensorValue[fork1];
		bBreak=(bool)SensorValue[solBreak];
		bLock=(bool)SensorValue[solLock];
		bShift=(bool)SensorValue[solShift];
		pLord=(float) pInit - (kBig*cBig) - (kDump*cDump) - (kFork*cFork) - (kBreak*cBreak) - (kLock*cLock) - (kShift*cShift);
		if(pLord<pThresh)
			tooLow=true;
		else
		{
			tooLow=false;
			SensorValue[pWarning]=false;
		}
		if(time1[T1]>350&tooLow){
			SensorValue[pWarning]=!SensorValue[pWarning];
			clearTimer(T1);
		}
		wait1Msec(10);
		if(bBig!=(bool)SensorValue[solBig])//constracted or extended
			cBig++;
		if(bDump!=(bool)SensorValue[solDump])//constracted or extended
			cDump++;
		if(bLock!=(bool)SensorValue[solLock])//constracted or extended
			cLock++;
		if(bShift!=(bool)SensorValue[solShift])//constracted or extended
			cShift++;
		if(bBreak==false&SensorValue[solBreak]==true)//only extented count
			cBreak++;
		if(bFork==false&SensorValue[fork1]==true)//only extented count
			cFork++;
	}
}
task driveThisShit()
{
	const float Imax=8.0;
	const float Ri=0.08;//ohms
	float current,Iratio,ctrRod=1.0;
	bool virgin=true,act=false;
	int powersav,poweravg,deltaS=0,lastpos=0;
	string inpt,time,speedd,currents,joystickk,powerrr;
	clearTimer(T4);
	nMotorEncoder[backLeft]=0;
	while(1)
	{
		int X2 = 0, Y1 = 0, threshold = 10;
		if(abs(vexRT[Ch3]) > threshold)
			Y1 = vexRT[Ch3];
		else
			Y1 = 0;
		if(abs(vexRT[Ch1]) > threshold)
			X2 = vexRT[Ch1];
		else
			X2 = 0;
		while(hangmode)
			motor[frontLeft] = 	motor[frontRight] = motor[backRight] =	motor[backLeft] =  -vexRT[Ch2];
		motor[frontLeft] = (float)ctrRod*(Y1 + X2 );
		motor[frontRight] = (float)ctrRod*(Y1 - X2 );
		motor[backRight] = (float)ctrRod*( Y1 - X2 );
		motor[backLeft] = (float)ctrRod*( Y1 + X2 );
		current=(float)(battStd-nAvgBatteryLevel)/(1000.0*Ri);
		poweravg=(abs(Y1 + X2)+abs(Y1 - X2 ))/2;
		deltaS=nMotorEncoder[backLeft]-lastpos;
		lastpos=nMotorEncoder[backLeft];

/*
		sprintf(speedd, " %4.0f%c", SensorValue[armPotentiometerL]);
		sprintf(time, " %5.0f%c", time1[T4]);
		sprintf(currents, " %2.3f%c", current);
		sprintf(powerrr, " %3.0f%c", motor[armmotL]);
		sprintf(joystickk, " %3.0f%c", joystick);
		writeDebugStream(time);
		writeDebugStream(currents);
		writeDebugStream(powerrr);
		writeDebugStream(joystickk);
		writeDebugStreamLine(speedd);*/



		if(current>Imax & virgin)
		{
			virgin=false;
			clearTimer(T3);
			powersav=poweravg;
		}
		if(current>Imax & !virgin & time1[T3]>200 & abs(deltaS)<5 )//also consider delta pos
		{
			act=true;
		}
		if(act)
		{
			Iratio=(float)current/Imax;
			ctrRod=(float)(1/Iratio);
			if(current>Imax-3.5)
				ctrRod=(float)(ctrRod-0.04);
			else if(current<(Imax-3.5))
				ctrRod=(float)(ctrRod+0.04);
			if (ctrRod>1.5)
				ctrRod=1.5;
			else if (ctrRod<0.1)
				ctrRod=0.1;
			ctrRod=0.2;

		}
		if ((3*poweravg<=powersav & act)|abs(deltaS)>5)
		{
			act=false;
			virgin=true;
			ctrRod=1.0;
		}
		wait1Msec(40);
	}


}

task usercontrol()
{
	bool forkopen=false;
	kMaxPos = 3070;
	kMaxPosf = 2500;
	SensorValue[solBig] = 0;
	startTask(raiseOrLowerArm);
	startTask(raiseOrLowerFork);
	startTask(autoslection);
	startTask(shift);
	startTask(openFork);
	startTask(masterreset);
	startTask(driveThisShit);
	startTask(pMonitor);

	//	startTask(tune);
	while(true) //Loop forever
	{

		joystick=vexRT[Ch2];

		if(vexRT[Btn8L])//action
		{
			while(vexRT[Btn8L]){}
			forkopen=!forkopen;
			if(forkopen)
				openup=true;
			else
				openup=false;
		}

		if(vexRT[Btn6U])
			joystickf = 128;
		else if(vexRT[Btn6D])
			joystickf = -128;
		else
			joystickf = 0;
		if(vexRT[Btn5U] == 1)
			motor[roller] = 127;
		else if(vexRT[Btn5D] == 1)
			motor[roller] = -127;
		else
			motor[roller] = 0;
		/*	if(vexRT[Btn7R]==1)
		{
		while(vexRT[Btn7R]==1){}
		GoDrive();
		}*/
		/*	if(vexRT[Btn8DXmtr2]==1)
		kMaxPos=2400;
		else
		kMaxPos=2845;*/

		//	else if(vexRT[Btn7D])
		if(vexRT[Btn7L])
			SensorValue[solDump]=1;
		else if(vexRT[Btn7R])
			SensorValue[solDump]=0;
		if(SensorValue[armPotentiometerL]<=1500&!hangmode)
		{
			liftDa=true;
			if(joystick<=-70)
				motor[armmotL]=motor[armmotR]=joystick/4;
			else if(joystick>=100)
				motor[armmotL]=motor[armmotR]=joystick;
			else if(SensorValue[armPotentiometerL]>1400)
				motor[armmotL]=motor[armmotR]=-24;
			else if(SensorValue[armPotentiometerL]<1430)
				motor[armmotL]=motor[armmotR]=-8;
		}
		else if(SensorValue[armPotentiometerL]>=1500&!hangmode)
		{
			liftDa=false;
		}
		if(hangmode)
			motor[armmotL]=motor[armmotR]=vexRT[Ch2];
	}
}



void GoSkill()
{
	SensorValue[solShift]=0;
	joystick=0;
	kMaxPos=3100;
	kMaxPosf = 1350;
//	bool scan;
	startTask(raiseOrLowerFork);
	startTask(openFork);
	startTask(visualMem);



//forwardLine(128,4000);
//while(!(SensorValue[GOL]|SensorValue[GOR])){}
	forward(128,280);
	motor[armmotL]=motor[armmotR]=-15;
		while(!(eyeM|eyeR|eyeL))//eyehits line)		//
	{
		motor[backLeft]=motor[frontLeft]=80;
		motor[backRight]=motor[frontRight]=80;
	}
	kMaxPos=1700;
	joystick=128;
	forward(128,120);

	//startTask(raiseOrLowerArm);
	breakDrive();
	nPositionToHold=1700;
	SensorValue[solBreak]=1;
	//while(SensorValue[armPotentiometerL]<1550);
	turn(128,55);
//	while(!(SensorValue[GOL]|SensorValue[GOR])){}

	SensorValue[solDump]=0;

	SensorValue[solBreak]=0;
	SensorValue[gyro]=0;
	motor[roller]=128;
	joystickf=-128;
	wait1Msec(900);


	startTask(visualMem);
	backward(70,50)
	breakDrive();
	turn(128,-50);
	while(!eyeB)
	motor[frontRight] =	motor[backRight] =motor[frontLeft] =motor[backLeft] =70;

	backward(60,40);
	breakDrive();
	SensorValue[solBreak]=1;
	turn(128,-85);
	SensorValue[gyro]=0;
	motor[armmotL]=motor[armmotR]=-40;
	while( SensorValue[gyro]>-600  &  (!(eyeM|eyeR|eyeL|eyeMm|eyeRm|eyeLm)) )
	{
		motor[frontRight] =	motor[backRight] = 50;
		motor[frontLeft] =motor[backLeft] =-50;
	}
	motor[armmotL]=motor[armmotR]=0;
	motor[frontRight] =	motor[backRight] = -50;
	motor[frontLeft] =motor[backLeft] =50;
	wait1Msec(200);
	while( !(eyeL))
	{
		motor[frontRight] =	motor[backRight] = -60;
		motor[frontLeft] =motor[backLeft] = 60;
	}

//	breakDrivet();
	motor[frontRight] =	motor[backRight] = 0;
	motor[frontLeft] =motor[backLeft] = 0;
	SensorValue[solBreak]=0;

forwardLine(60,600,forwardLine(85,600,0));

	motor[armmotL]=motor[armmotR]=0;

	/*backward(128,200);

	turn(128,-70);



while(!(SensorValue[GOL]|SensorValue[GOR])){}
	kMaxPosf = 2400;
	joystickf=128;
	forward(128,300);
	openup=true;
	forward(128,940);
	openup=false;
	joystickf=-128;
	breakDrive();
	wait1Msec(200);

	forward(128,200);
	kMaxPosf=1200;
	startTask(raiseOrLowerArm);
	joystickf=128;
	kMaxPos=3000;
	liftDa=false;
	joystick=128;

	forward(70,200);
	breakDrive();
	while(SensorValue[armPotentiometerL]<2800);
	joystickf=0;
	forward(128,500);
	breakDrive();
	SensorValue[solDump]=1;

	motor[roller]=-128;
	wait1Msec(800);


	backward(128,400);
	motor[roller]=0;
	while(SensorValue[armPotentiometerL]>1390){
		joystick=-128;}
	joystick=0;
	stopTask(raiseOrLowerArm);
	motor[armmotL]=motor[armmotR]=0;
	SensorValue[solDump]=0;
	backward(128,1400);
	turn(128,180);





	while(!(SensorValue[GOL]|SensorValue[GOR])){}


	motor[roller]=128;
	forward(128,840);

	motor[roller]=127;//intake
	forward(127,300);
	liftDa=true;
	motor[armmotL]=motor[armmotR]=-15;
	joystickf=128;
	forward(90,250);

	wait1Msec(500);

	backward(128,500);
	motor[roller]=50;//intake
	joystickf=0;
	motor[armmotL]=motor[armmotR]=0;
	backward(128,900);
	turn(128,-160);
	motor[roller]=20;//intake






	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	kMaxPosf = 2400;
	forward(128,1440);
	kMaxPosf=1200;
	startTask(raiseOrLowerArm);
	joystickf=128;
	kMaxPos=3000;
	liftDa=false;
	joystick=128;

	forward(70,200);
	breakDrive();
	while(SensorValue[armPotentiometerL]<2800);
	joystickf=0;
	forward(128,500);
	breakDrive();
	SensorValue[solDump]=1;

	motor[roller]=-128;
	wait1Msec(800);


	backward(128,400);
	motor[roller]=0;
	while(SensorValue[armPotentiometerL]>1390){
		joystick=-128;}
	joystick=0;
	stopTask(raiseOrLowerArm);
	motor[armmotL]=motor[armmotR]=0;
	SensorValue[solDump]=0;
	backward(128,1400);
	turn(128,180);









	while(!(SensorValue[GOL]|SensorValue[GOR])){}

	forward(128,800);
	SensorValue[solDump]=1;
	turn(128,90);

	while(!(SensorValue[GOL]|SensorValue[GOR])){}









	kMaxPosf=2500;
	joystickf=0;
	nPositionToHoldf=400;
	openup=true;
	SensorValue[fork1]=SensorValue[fork2]=true;

	wait1Msec(300);
	backward(80,200);

	wait1Msec(200);
	SensorValue[solDump]=0;
	joystickf=128;
	backward(60,300);
	while(SensorValue[forkPot]<2250);
	joystickf=-128;
	//	backward(60,400);
	kMaxPos=2100;
	joystick=128;
	while(SensorValue[forkPot]>500);
	joystickf=0;
	backward(60,450);
	kMaxPosf=1400;
	joystickf=128;
	while(SensorValue[forkPot]<1300);
	joystickf=0;
	turnPCS90(128,90);
	SensorValue[solBig]=1;
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=50;
	wait1Msec(400);
	joystick=-128;
	SensorValue[solBig]=0;
//	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	kMaxPosf=2600;
	while(SensorValue[armPotentiometerL]>1400);
	joystick=0;
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	kMaxPosf=2400;
	joystickf=128;
	while(SensorValue[forkPot]<2250);
	joystickf=-128;
	openup=false;
	kMaxPos=2500;
	joystick=128;
	turn(80,18);

	while(SensorValue[armPotentiometerL]<2400);
	joystickf=0;
	joystick=0;

	SensorValue[solBig]=1;
	wait1Msec(350);
	joystick=-128;
	turnpcs90(128,-120);
	SensorValue[solBig]=0;
	while(SensorValue[armPotentiometerL]>1400);
	joystick=0;
	openup=true;
	backward(80,600);




	joystickf=128;
	backward(60,300);
	while(SensorValue[forkPot]<2350);
	joystickf=-128;
	//	backward(60,400);
	kMaxPos=2100;
	joystick=128;
	while(SensorValue[forkPot]>500);
	joystickf=0;
	backward(60,500);
	kMaxPosf=1400;
	joystickf=128;
	while(SensorValue[forkPot]<1300);
	joystickf=0;
	turnPCS90(128,120);
	SensorValue[solBig]=1;
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=50;
	wait1Msec(400);


	kMaxPosf=2600;
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	kMaxPosf=2400;
	turn(75,-100);
	kMaxPos=2600;
	kMaxPosf=1350;
	joystickf=0;
	joystick=128;
	forward(128,2400);
	turn(128,135);
	joystick=0;


	while(!(SensorValue[GOL]|SensorValue[GOR])){}

	forward(128,500);
	turn(128,30);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=50;
	wait1Msec(400);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	kMaxPos=3050;
	joystick=128;
	while(SensorValue[armPotentiometerL]<2980);
	SensorValue[solShift]=1;
	kMaxPosf=1700;
	joystickf=128;
	wait1Msec(200);
	stopTask(raiseOrLowerArm);
	motor[frontLeft] = 	motor[frontRight] = motor[backRight] =	motor[backLeft] =128;
	motor[armmotL]=motor[armmotR]=-128;
	wait1Msec(500);
	SensorValue[solLock]=true;
	joystickf=0;
	while(SensorValue[armPotentiometerL]>1450);
	motor[frontLeft] = 	motor[frontRight] = motor[backRight] =	motor[backLeft] =0;
	*/
}


void GoSkillRisk()

{


	turnIEC(50,90);
	breakDrivet();
}

void GoRH()
{
	kMaxPos=3000;
	startTask(raiseOrLowerArm);
	motor[roller]=127;//intake
	wait1Msec(400);	//unfold
	forward(127,300);

	joystick=-128;
	forward(40,230);

	wait1Msec(1000);
	joystick=-0;
	stopTask(raiseOrLowerArm);
	motor[armmotL]=motor[armmotR]=0;
	backward(128,450);
	turn(128,-85);
	motor[roller]=10;//intake

	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	forward(128,620);
	turn(128,-88);

	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=98;
	wait1Msec(100);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	wait1Msec(100);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=98;
	wait1Msec(100);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	wait1Msec(100);


	forward(80,850);
	startTask(raiseOrLowerArm);
	joystick=-128;
	forward(128,500);
	joystick=0;
	forward(128,650);
	joystick=128;
	while(SensorValue[armPotentiometerL]<2700);
	forward(50,150);
	forward(128,400);
	motor[roller]=-128;
}


void GoRM()
{
	kMaxPos=3050;
	startTask(raiseOrLowerArm);

	SensorValue[solBig]=1;
	wait1Msec(400);
	SensorValue[solBig]=0;
	//unfold

	motor[roller]=20;//intake
	stopTask(raiseOrLowerFork);
	forward(128,300);
	SensorValue[solBig]=1;
	motor[fork]=-40;
	forward(128,300);
	SensorValue[solBig]=0;
	joystick=0;
	memEn=false;//init memory
	forward(128,800);
	kMaxPos=3000;
	liftDa=false;
	joystick=128;

	joystick=128;
	forward(70,400);
	breakDrive();
	while(SensorValue[armPotentiometerL]<2800);
	forward(128,500);


	motor[roller]=-128;
	clearTimer(T3);
	memEn=true;
	while(time1[T3]<1300)
	{
		motor[backLeft]=-80;
		motor[backRight]=+80;//turncw
		while(!eyeB)
		{
			if(time1[T3]>3300)
				break;
		}
		motor[backLeft]=0;
		motor[backRight]=0;//stop
		breakDrivet();
		while(time1[T3]<1300);

	}
	memEn=false;

	startTask(raiseOrLowerFork);

	backward(128,300);
	motor[roller]=0;
	while(SensorValue[armPotentiometerL]>1400){
		joystick=-128;}
	joystick=0;
	liftDa=true;
	//	while(!(SensorValue[GOL]|SensorValue[GOR])){}


	motor[armmotL]=motor[armmotR]=0;


	backward(128,300);
	motor[roller]=0;
	motor[backRight]=motor[frontLeft]=80;
	motor[backLeft]=motor[frontRight]=-80;
	wait1Msec(300);
	motor[backRight]=motor[frontLeft]=0;
	motor[backLeft]=motor[frontRight]=0;
	stopTask(raiseOrLowerFork);
	motor[fork]=0;
	joystickf=0;
	backward(80,300);
	breakDrive();
	SensorValue[solBig]=1; //hits big ball
	wait1Msec(250);
	SensorValue[solBig]=0;

	backward(80,400);
	turn(128,75);

	backward(128,400);
}


void GoBH()
{
	kMaxPos=3000;
	startTask(raiseOrLowerArm);
	motor[roller]=127;//intake
	wait1Msec(400);	//unfold
	forward(127,300);

	joystick=-128;
	forward(40,230);

	wait1Msec(1000);
	joystick=-0;
	stopTask(raiseOrLowerArm);
	motor[armmotL]=motor[armmotR]=0;
	backward(128,450);
	turn(128,88);
	motor[roller]=10;//intake
	while(!(SensorValue[GOL]|SensorValue[GOR])){}
	forward(128,625);
	turn(128,90);


	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=98;
	wait1Msec(100);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	wait1Msec(100);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=98;
	wait1Msec(100);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	wait1Msec(100);


	forward(80,850);
	startTask(raiseOrLowerArm);
	joystick=-128;
	forward(128,500);
	joystick=0;
	forward(128,650);
	joystick=128;
	//	turn(128,-2);
	while(SensorValue[armPotentiometerL]<2700);
	forward(50,170);
	forward(128,400);
	motor[roller]=-128;
}



void GoBM()
{
	kMaxPos=3050;
	startTask(raiseOrLowerArm);

	SensorValue[solBig]=1;
	wait1Msec(400);
	SensorValue[solBig]=0;
	//unfold

	motor[roller]=20;//intake
	stopTask(raiseOrLowerFork);
	forward(128,300);
	SensorValue[solBig]=1;
	motor[fork]=-40;
	forward(128,300);
	SensorValue[solBig]=0;
	joystick=0;
	memEn=false;//init memory
	forward(128,800);
	kMaxPos=3000;
	liftDa=false;
	joystick=128;

	joystick=128;
	forward(70,400);
	breakDrive();
	while(SensorValue[armPotentiometerL]<2800);
	forward(128,500);

	//	while(SensorValue[armPotentiometerL]<2800);


	//	motor[frontRight] =motor[backRight]=motor[frontLeft] =motor[backLeft] =0;
	motor[roller]=-128;
	clearTimer(T3);
	memEn=true;
	while(time1[T3]<1300)
	{
		motor[backLeft]=80;
		motor[backRight]=-80;//turncw
		while(!eyeB)
		{
			if(time1[T3]>3300)
				break;
		}
		motor[backLeft]=0;
		motor[backRight]=0;//stop
		breakDrivet();
		while(time1[T3]<1300);

	}
	memEn=false;

	startTask(raiseOrLowerFork);

	backward(128,300);
	motor[roller]=0;
	while(SensorValue[armPotentiometerL]>1400){
		joystick=-128;}
	joystick=0;
	liftDa=true;
	//	while(!(SensorValue[GOL]|SensorValue[GOR])){}


	motor[armmotL]=motor[armmotR]=0;


	backward(128,300);
	motor[roller]=0;
	motor[backRight]=motor[frontLeft]=80;
	motor[backLeft]=motor[frontRight]=-80;
	wait1Msec(300);
	motor[backRight]=motor[frontLeft]=0;
	motor[backLeft]=motor[frontRight]=0;
	stopTask(raiseOrLowerFork);
	motor[fork]=0;
	joystickf=0;
	backward(80,300);
	breakDrive();
	SensorValue[solBig]=1; //hits big ball
	wait1Msec(250);
	SensorValue[solBig]=0;

	backward(80,400);
	turn(128,-75);

	backward(128,400);
}



void GoRH2()
{
	startTask(openFork);
	startTask(raiseOrLowerFork);
	//	wait1Msec(800);
	joystickf=-128;
	kMaxPosf=2600;
	openup=true;
	SensorValue[fork1]=SensorValue[fork2]=true;
	wait1Msec(500);
	backward(80,150);
	//	breakDrive();
	SensorValue[solBig]=true;
	//	breakDrive():
	wait1Msec(200);
	SensorValue[solBig]=false;
	kMotorSpeedUp   = 85;
	joystickf=128;
	backward(60,300);
	while(SensorValue[forkPot]<2700);
	kMotorSpeedUp   = 128;
	joystickf=-128;
	//	backward(60,400);

	while(SensorValue[forkPot]>1200);
	backward(60,350);
	kMaxPosf=1800;
	joystickf=128;
	backward(80,350);
	turn(128,90);
	forward(128,1450);
	breakDrive();
	motor[roller]=-128;
	SensorValue[solBig]=true;
	wait1Msec(300);
	SensorValue[solBig]=false;
	kMaxPosf=1500;
	joystickf=128;
	while(SensorValue[forkPot]<2800);
	wait1Msec(300);
	SensorValue[solBig]=true;
	wait1Msec(300);
	SensorValue[solBig]=false;
	wait1Msec(1000);
	joystickf=-128;
	openup=false;
	backward(128,300);
	turn(128,180);
	motor[roller]=0;
	forward(128,1000);

}




void GoBH2()
{
	startTask(openFork);
	startTask(raiseOrLowerFork);
	//	wait1Msec(800);
	joystickf=-128;
	kMaxPosf=2600;
	openup=true;
	SensorValue[fork1]=SensorValue[fork2]=true;
	wait1Msec(500);
	backward(80,150);
	//	breakDrive();
	SensorValue[solBig]=true;
	//	breakDrive():
	wait1Msec(200);
	SensorValue[solBig]=false;
	kMotorSpeedUp   = 85;
	joystickf=128;
	backward(60,300);
	while(SensorValue[forkPot]<2700);
	kMotorSpeedUp   = 128;
	joystickf=-128;
	//	backward(60,400);

	while(SensorValue[forkPot]>1200);

	backward(60,350);
	kMaxPosf=1800;
	joystickf=128;
	backward(80,350);
	turn(128,-90);
	forward(128,1450);
	breakDrive();
	motor[roller]=-128;
	SensorValue[solBig]=true;
	wait1Msec(300);
	SensorValue[solBig]=false;
	kMaxPosf=2500;
	joystickf=128;
	while(SensorValue[forkPot]<2800);
	wait1Msec(300);
	SensorValue[solBig]=true;
	wait1Msec(300);
	SensorValue[solBig]=false;
	wait1Msec(1000);
	joystickf=-128;
	openup=false;
	backward(128,300);
	turn(128,180);
	motor[roller]=0;
	forward(128,1000);

}


void turn(int power,float angle)
{
	int decidegrees = -10*angle;
	int error = 15;

	//While the absolute value of the gyro is less than the desired rotation - 100...
	if(decidegrees>=0)
	{
		decidegrees=(float)decidegrees+(decidegrees/900)*gyrocorrection;
		SensorValue[gyro]=0;
		while(abs(SensorValue[gyro]) < decidegrees*0.6 )
		{
			motor[frontRight] = power;
			motor[backRight] = power;
			motor[frontLeft] = -power;
			motor[backLeft] = -power;
		}
		clearTimer(T3);
		while((SensorValue[gyro] > decidegrees + error || SensorValue[gyro] < decidegrees - error)&time1[T3]<500)
		{
			if(SensorValue[gyro] < decidegrees)
			{
				motor[frontRight] = 30;
				motor[backRight] = 30;
				motor[frontLeft] = -30;
				motor[backLeft] = -30;
			}
			else
			{
				motor[frontRight] = -30;
				motor[backRight] = -30;
				motor[frontLeft] = 30;
				motor[backLeft] = 30;
			}
		}
	}
	else
	{

		decidegrees=decidegrees-gyrocorrection;
		SensorValue[gyro]=0;
		wait1Msec(10);
		while(SensorValue[gyro] > decidegrees*0.6 )
		{
			wait1Msec(10);
			motor[frontRight] = -power;
			motor[backRight] = -power;
			motor[frontLeft] = power;
			motor[backLeft] = power;
		}
		clearTimer(T3);
		while((SensorValue[gyro] > decidegrees + error || SensorValue[gyro] < decidegrees - error)&time1[T3]<500)
		{
			if(SensorValue[gyro] < decidegrees)
			{
				motor[frontRight] = 40;
				motor[backRight] = 40;
				motor[frontLeft] = -40;
				motor[backLeft] = -40;
			}
			else
			{
				motor[frontRight] = -40;
				motor[backRight] = -40;
				motor[frontLeft] = 40;
				motor[backLeft] = 40;
			}
		}

	}
	motor[frontRight] = 0;
	motor[backRight] = 0;
	motor[frontLeft] = 0;
	motor[backLeft] = 0;

}

void turnPCS90(int power,float angle)
{
	int decidegrees = -10*angle;
	int error = 10;
	float const kt=0.1;
	float const kit=0.025;
	float const kdt=0.020;
	float errort,outpower;
	long Ierr=0;
	int Derr=0;
	int lastInput=0;
	int timewait;
	bool vv=true;
	bool stillfinding=true;
//	string PPP,III,DDD,gyrooo,timeee,powerrr;
//	float Pp,Ii,Dd;
	//While the absolute value of the gyro is less than the desired rotation - 100...
	if(decidegrees>=0)
	{
		vv=true;
		decidegrees=(float)decidegrees+(decidegrees/900)*gyrocorrection;
		SensorValue[gyro]=0;
		while(abs(SensorValue[gyro]) < decidegrees-200 )
		{
			motor[frontRight] = power;
			motor[backRight] = power;
			motor[frontLeft] = -power;
			motor[backLeft] = -power;
		}
		clearTimer(T3);
		timewait=10*power;
		while(time1[T3]<timewait&stillfinding)
		{
			errort=-(decidegrees-SensorValue[gyro]);
			if(vv)
				outpower=kt*errort;
			else{
				outpower=4*kt*errort+kit*Ierr-kdt*Derr;
				Ierr+=errort;}
			Derr=lastInput-SensorValue[gyro];

			if(outpower>0)
				outpower=(float)(outpower*0.675)+25;
			if(outpower<0)
				outpower=(float)(outpower*0.675)-25;

			motor[frontRight] = -outpower;
			motor[backRight] = -outpower;
			motor[frontLeft] = outpower;
			motor[backLeft] = outpower;
			lastInput=SensorValue[gyro];
			wait1Msec(50);
			if(abs(decidegrees-SensorValue[gyro]) <10)
				Ierr=0;

			if(vv&abs(decidegrees-SensorValue[gyro]) <20)
			{
				vv=false;
			//	wait1Msec(40);
				Ierr=0;
			}
			if(abs(errort)<error&abs(Derr)<3)
				stillfinding=false;

		}
	}
	else
	{
		vv=true;
		decidegrees=decidegrees-gyrocorrection;
		SensorValue[gyro]=0;
		wait1Msec(10);
		while(SensorValue[gyro] > (float)decidegrees+200 )
		{
			motor[frontRight] = -power;
			motor[backRight] = -power;
			motor[frontLeft] = power;
			motor[backLeft] = power;
		}

		clearTimer(T3);
		timewait=10*power;
		while((time1[T3]<timewait)&stillfinding)
		{
			errort=decidegrees-SensorValue[gyro];
			if(vv)
				outpower=kt*errort;
			else{
				outpower=4*kt*errort+kit*Ierr-kdt*Derr;
				Ierr+=errort;}
			Derr=lastInput-SensorValue[gyro];

			if(outpower>0)
				outpower=(float)(outpower*0.675)+25;
			if(outpower<0)
				outpower=(float)(outpower*0.675)-25;

			motor[frontRight] = outpower;
			motor[backRight] = outpower;
			motor[frontLeft] = -outpower;
			motor[backLeft] = -outpower;
			lastInput=SensorValue[gyro];
			wait1Msec(50);
			if(abs(decidegrees-SensorValue[gyro]) <10)
				Ierr=0;

			if(vv&decidegrees-SensorValue[gyro] > -20)
			{
				vv=false;
			//	wait1Msec(40);
				Ierr=0;
			}
			if(abs(errort)<error&abs(Derr)<3)
				stillfinding=false;

/*			Pp=errort*kt
			Ii=Ierr*kit;
			Dd=Derr*kdt;

			sprintf(PPP, " %2.5f%c", Pp );
			sprintf(III, " %2.5f%c", Ii);
			sprintf(DDD, " %2.5f%c", Dd);
			sprintf(powerrr, " %3.0f%c", motor[backLeft]);
			sprintf(timeee, " %4.0f%c", time1[T4]);
			sprintf(gyrooo, " %5.0f%c", SensorValue[gyro]);
			writeDebugStream(PPP);
			writeDebugStream(III);
			writeDebugStream(DDD);
			writeDebugStream(powerrr);
			writeDebugStream(timeee);
			writeDebugStreamLine(gyrooo);*/


		}
	}
	motor[frontRight] = 0;
	motor[backRight] = 0;
	motor[frontLeft] = 0;
	motor[backLeft] = 0;
}


void turnPCS45(int power,float angle)
{
	int decidegrees = -10*angle;
	int error = 10;
	float const kt=0.1;
	float const kit=0.025;
	float const kdt=0.020;
	float errort,outpower;
	long Ierr=0;
	int Derr=0;
	int lastInput=0;
	int timewait;
	bool vv=true;
	bool stillfinding=true;
	//string PPP,III,DDD,gyrooo,timeee,powerrr;
//	float Pp,Ii,Dd;
	//While the absolute value of the gyro is less than the desired rotation - 100...
	if(decidegrees>=0)
	{
		vv=true;
		decidegrees=(float)decidegrees+(decidegrees/900)*gyrocorrection;
		SensorValue[gyro]=0;
		while(abs(SensorValue[gyro]) < decidegrees-200 )
		{
			motor[frontRight] = power;
			motor[backRight] = power;
			motor[frontLeft] = -power;
			motor[backLeft] = -power;
		}
		clearTimer(T3);
		timewait=8*power;
		while(time1[T3]<timewait*stillfinding)
		{
			errort=-(decidegrees-SensorValue[gyro]);
			if(vv)
				outpower=kt*errort;
			else{
				outpower=4*kt*errort+kit*Ierr-kdt*Derr;
				Ierr+=errort;}
			Derr=lastInput-SensorValue[gyro];

			if(outpower>0)
				outpower=(float)(outpower*0.675)+25;
			if(outpower<0)
				outpower=(float)(outpower*0.675)-25;

			motor[frontRight] = -outpower;
			motor[backRight] = -outpower;
			motor[frontLeft] = outpower;
			motor[backLeft] = outpower;
			lastInput=SensorValue[gyro];
			wait1Msec(50);
			if(abs(decidegrees-SensorValue[gyro]) <10)
				Ierr=0;

			if(vv&abs(decidegrees-SensorValue[gyro]) <20)
			{
				vv=false;
			//	wait1Msec(40);
				Ierr=0;
			}
						if(abs(errort)<error&abs(Derr)<3)
				stillfinding=false;

		}
	}
	else
	{
		vv=true;
		decidegrees=decidegrees-gyrocorrection;
		SensorValue[gyro]=0;
		wait1Msec(10);
		while(SensorValue[gyro] > (float)decidegrees+200 )
		{
			motor[frontRight] = -power;
			motor[backRight] = -power;
			motor[frontLeft] = power;
			motor[backLeft] = power;
		}

		clearTimer(T3);
		timewait=8*power;
		while(time1[T3]<timewait&stillfinding)
		{
			errort=decidegrees-SensorValue[gyro];
			if(vv)
				outpower=kt*errort;
			else{
				outpower=4*kt*errort+kit*Ierr-kdt*Derr;
				Ierr+=errort;}
			Derr=lastInput-SensorValue[gyro];

			if(outpower>0)
				outpower=(float)(outpower*0.675)+25;
			if(outpower<0)
				outpower=(float)(outpower*0.675)-25;

			motor[frontRight] = outpower;
			motor[backRight] = outpower;
			motor[frontLeft] = -outpower;
			motor[backLeft] = -outpower;
			lastInput=SensorValue[gyro];
			wait1Msec(50);
			if(abs(decidegrees-SensorValue[gyro]) <10)
				Ierr=0;

			if(vv&decidegrees-SensorValue[gyro] > -20)
			{
				vv=false;
			//	wait1Msec(40);
				Ierr=0;
			}
						if(abs(errort)<error&abs(Derr)<3)
				stillfinding=false;

/*			Pp=errort*kt
			Ii=Ierr*kit;
			Dd=Derr*kdt;

			sprintf(PPP, " %2.5f%c", Pp );
			sprintf(III, " %2.5f%c", Ii);
			sprintf(DDD, " %2.5f%c", Dd);
			sprintf(powerrr, " %3.0f%c", motor[backLeft]);
			sprintf(timeee, " %4.0f%c", time1[T4]);
			sprintf(gyrooo, " %5.0f%c", SensorValue[gyro]);
			writeDebugStream(PPP);
			writeDebugStream(III);
			writeDebugStream(DDD);
			writeDebugStream(powerrr);
			writeDebugStream(timeee);
			writeDebugStreamLine(gyrooo);*/


		}
	}
	motor[frontRight] = 0;
	motor[backRight] = 0;
	motor[frontLeft] = 0;
	motor[backLeft] = 0;
}


void forward(int power,int howfar)
{
	nMotorEncoder[backRight] = 0;
	nMotorEncoder[backLeft] = 0;
	while(howfar-nMotorEncoder[backRight]>5 | howfar-nMotorEncoder[backLeft]>5)
	{
		if(nMotorEncoder[backRight] < howfar ){
			motor[backRight] = power;
			motor[frontRight] = power;}
		else {
			motor[backRight] = 0;
			motor[frontRight] = 0;}

		if(nMotorEncoder[backLeft] < howfar ){
			motor[backLeft] = power;
			motor[frontLeft] = power;}
		else {
			motor[backLeft] = 0;
			motor[frontLeft] = 0;}
	}
	motor[frontRight] = 0;
	motor[backRight] = 0;
	motor[frontLeft] = 0;
	motor[backLeft] = 0;
}

void backward(int power,int howfar)
{
	nMotorEncoder[backRight] = 0;
	nMotorEncoder[backLeft]  = 0;
	while(nMotorEncoder[backRight]+howfar>10 | nMotorEncoder[backLeft]+howfar>10)
	{
		if(nMotorEncoder[backRight] > -howfar ){
			motor[backRight] = -power;
			motor[frontRight] = -power;}
		else if(nMotorEncoder[backRight]<-howfar){
			motor[backRight] = 0;
			motor[frontRight] = 0;}

		if(nMotorEncoder[backLeft] > -howfar ){
			motor[backLeft] = -power;
			motor[frontLeft] = -power;}
		else if(nMotorEncoder[backLeft]<-howfar){
			motor[backLeft] = 0;
			motor[frontLeft] = 0;}
	}
	motor[frontRight] = 0;
	motor[backRight] = 0;
	motor[frontLeft] = 0;
	motor[backLeft] = 0;
}

void autohang()//rewrite
{
	stopTask(raiseOrLowerArm);
	SensorValue[solShift]=1;
	motor[backLeft]=motor[backRight]=0;
	while(SensorValue[armPotentiometerL]<3050)
		motor[armmotL]=motor[armmotR]=128;
	SensorValue[solBig]=1;
	motor[frontLeft]=motor[frontRight]=128;
	wait1Msec(600);
	motor[armmotL]=motor[armmotR]=0;
	motor[frontLeft]=motor[frontRight]=0;

	motor[armmotL]=motor[armmotR]=-128;
	while(SensorValue[armPotentiometerL]>1380)
	{
		motor[backLeft]=motor[backRight]=128;
	}
	wait1Msec(200);
	motor[backLeft]=motor[backRight]=100;
	wait1Msec(200);
	motor[backLeft]=motor[backRight]=80;
	wait1Msec(200);
	motor[backLeft]=motor[backRight]=60;
	wait1Msec(200);
	motor[backLeft]=motor[backRight]=40;
	wait1Msec(200);
	motor[armmotL]=motor[armmotR]=-10;
	SensorValue[solBig]=0;
	motor[backLeft]=motor[backRight]=20;
	wait1Msec(200);
	motor[backLeft]=motor[backRight]=10;
	SensorValue[solBig]=0;
	wait1Msec(1000);
}


//-----------------------------------------------------------------------------------


task shift()
{
	while(true){

		if(vexRT[Btn8R])//hangmode
		{
			while(vexRT[Btn8R]){}
			if(prehangmode){
				hangmode=true;
				prehangmode=false;
				liftDa=true;
				SensorValue[solShift]=1;
				SensorValue[solLock]=1;
				stopTask(raiseOrLowerArm);
			}
			if(!prehangmode)
				prehangmode=true;
		}
		if(vexRT[Btn7U])
		{
			while(vexRT[Btn7U]);
			SensorValue[solBreak] =!SensorValue[solBreak];
		}
		if(vexRT[Btn8U])         // If button 6U (upper right shoulder button) is pressed:
		{
	//		while(vexRT[Btn8U]);
			if(!hangmode&!prehangmode)
				SensorValue[solBig] = 1;
			if(prehangmode)
				SensorValue[solBig] = !SensorValue[solBig] ;
		}
		else
		{
			if(!hangmode&!prehangmode)
			SensorValue[solBig] = 0;
		}

	}
}
task openFork()
{
	bool openupsav;
	while(1)
	{
		if(!openup)//action
		{
			SensorValue[fork1]=0;
			wait1Msec(200);
			SensorValue[fork2]=0;
		}
		else
		{
			SensorValue[fork2]=1;
			wait1Msec(200);
			SensorValue[fork1]=1;
		}
		openupsav=openup;
		//		while(openup==openupsav){}


	}
}


task masterreset()
{
	while(1){
		while(vexRT[Btn8D] == 1){}
		while(vexRT[Btn8D] == 0){}
		stopTask(raiseOrLowerArm);
		stopTask(raiseOrLowerFork);
		stopTask(usercontrol);
		stopTask(shift);
		stopTask(autoslection);
		stopTask(openFork);
		stopTask(driveThisShit);
		startTask(driveThisShit);
		startTask(raiseOrLowerArm);
		startTask(raiseOrLowerFork);
		startTask(usercontrol);
		startTask(shift);
		startTask(autoslection);
		startTask(openFork);
		kMaxPos=3070;
		joystick=0;
		hangmode=false;
		liftDa=false;
		openup=false;
		prehangmode=false;
		SensorValue[solBig]=0;
		SensorValue[solShift]=0;
		SensorValue[solLock]=0;
	}
}
//-----------------------------------------------------------------------------------

task raiseOrLowerArm()
{
	const int kSlowSpeedRange = 10;
	const int kMinPos = 1325;

	const int kSlowSpeedPosLowering = kMinPos + kSlowSpeedRange;
	const int kSlowSpeedRaising     = kMaxPos - kSlowSpeedRange;

	const int kMotorSpeedUp   = +127;
	const int kMotorSpeedDown = -127;
	float ITerm;
	int error;
	const float outMax=128,outMin=-128;
	bool bLastUpdateWasButtonPress = false;
	bool bButtonsHaveBeenPressed   = false;

	while(true)
	{
		while(liftDa){}
		if (joystick <= -90)// button is puchsed indicating ARM should be lowered
		{
			if (SensorValue[armPotentiometerL] < kMinPos)
			{
				motor[armmotL] = 0;
				motor[armmotR] = 0;// Arm is fully lowered. Stop the motor
			}
			else if (SensorValue[armPotentiometerL] < kSlowSpeedPosLowering){
				motor[armmotL] = kMotorSpeedDown / 2;
				motor[armmotR] = kMotorSpeedDown / 2;
			}
			else{
				motor[armmotL] = kMotorSpeedDown;
				motor[armmotR] = kMotorSpeedDown;
			}
			nPositionToHold = (SensorValue[armPotentiometerL]+10);
			bLastUpdateWasButtonPress = true;
		}

		else if (joystick >= 90)// button is puchsed indicating ARM should be raised
		{
			if (SensorValue[armPotentiometerL] > kMaxPos)
			{
				motor[armmotL] = 10;
				motor[armmotR] = 10;// Arm is fully raised. Stop the motor
			}
			else if (SensorValue[armPotentiometerL] > kSlowSpeedRaising){
				motor[armmotL] = kMotorSpeedUp / 2;
				motor[armmotR] = kMotorSpeedUp / 2;
			}
			else{
				motor[armmotL] = kMotorSpeedUp;
				motor[armmotR] = kMotorSpeedUp;
			}

			nPositionToHold = (SensorValue[armPotentiometerL]+10);
		}


		else// No buttons are pushed.
		{


			if (bLastUpdateWasButtonPress) // A button has just been released.- Remember the position.-- Stop motor
			{
				bLastUpdateWasButtonPress = false;
				if (nPositionToHold < kMinPos)
					nPositionToHold = kMinPos;
				else if (nPositionToHold > kMaxPos)
					nPositionToHold = kMaxPos;
				motor[armmotL] = 0;
				motor[armmotR] = 0;
				clearTimer(T4);
				bButtonsHaveBeenPressed = true;
			}
			else if (bButtonsHaveBeenPressed)
			{
				int SampleTime=10;
				long lastInput;
				if(time1[T4]>=SampleTime)
				{
					float input = SensorValue[armPotentiometerL];
					error = nPositionToHold - input;

					ITerm+= (ki * error);
					ITerm= 0;
					if(ITerm > outMax) ITerm= outMax;
					else if(ITerm < outMin) ITerm= outMin;
					if(ki==0) ITerm=0;
					float dInput = (input - lastInput);
					/*Compute PID Output*/
					float output = kp * error + ITerm- kd * dInput;
					if(output > outMax) output = outMax;
					else if(output < outMin) output = outMin;
					motor[armmotL]= motor[armmotR]= output;
					lastInput = input;
					clearTimer(T4);
				}
			}
			else
			{
		//		motor[armmotL]= motor[armmotR]= 0;
			}
		}
	}
}


//-----------------------------------------------------------------------------------



task raiseOrLowerFork()
{

	const int kMinPosf = 350;
	float error,input;
	const int kSlowSpeedRange = 80;
	const int kSlowSpeedLowering = kMinPosf + kSlowSpeedRange;
	const int kSlowSpeedRaising     = kMaxPosf - kSlowSpeedRange;


	const float outMax=128,outMin=-128;

	float ITerm;
	bool bLastUpdateWasButtonPress = false;
	bool bButtonsHaveBeenPressed   = false;
	while(true)
	{
		if (joystickf<-90)// button is puchsed indicating ARM should be lowered
		{
			if (SensorValue[forkPot] <= kMinPosf)
			{
				motor[fork] = -10; // Arm is fully lowered. Stop the motor
			}
			else if (SensorValue[forkPot] <= kSlowSpeedLowering)
				motor[fork] =-kMotorSpeedUp / 2;
			else
				motor[fork] = -kMotorSpeedUp;
			nPositionToHoldf = SensorValue[forkPot];
			bLastUpdateWasButtonPress = true;
		}

		else if (joystickf>90)// button is puchsed indicating ARM should be raised
		{
			if (SensorValue[forkPot] >= kMaxPosf)
			{
				motor[fork] = +10;// Arm is fully raised. Stop the motor
			}
			else if (SensorValue[forkPot] >= kSlowSpeedRaising)
				motor[fork] = kMotorSpeedUp / 2;
			else
				motor[fork] = kMotorSpeedUp;
			nPositionToHoldf = SensorValue[forkPot];
			bLastUpdateWasButtonPress = true;
		}

		else  // No buttons are pushed.
		{
			if (bLastUpdateWasButtonPress) // A button has just been released.- Remember the position.-- Stop motor
			{
				bLastUpdateWasButtonPress = false;
				if (nPositionToHoldf < kMinPosf)
					nPositionToHoldf = kMinPosf;
				else if (nPositionToHoldf > kMaxPosf)
					nPositionToHoldf = kMaxPosf;
				motor[fork] = 0;
				motor[fork] = 0;
				clearTimer(T2);
				bButtonsHaveBeenPressed = true;
			}
			else if (bButtonsHaveBeenPressed)
			{
				unsigned long now = time1[T2];
				long lastInput;
				unsigned long lastTime;
				unsigned long SampleTime=10;

				unsigned long timeChange = (now - lastTime);
				if(timeChange>=SampleTime)
				{
					input = SensorValue[forkPot];
					error = -(nPositionToHoldf - input);
					ITerm+= (ki * error);
					if(ITerm > outMax) ITerm= outMax;
					else if(ITerm < outMin) ITerm= outMin;
					if(kif==0) ITerm=0;

					float dInput = (input - lastInput);
					/*Compute PID Output*/
					float output = -(kpf * error + ITerm - kdf * dInput);
					if(output > outMax) output = outMax;
					else if(output < outMin) output = outMin;
					motor[fork]= output;
					lastInput = input;
					lastTime = now;
				}
			}
			else
			{
			}

		}
	}
}




void turnthenfollow(int power,int howfar,int approx)
{
	int degturned;
	//	const int b=150;//lengh factor of the robot
	SensorValue[gyro]=0;


	wait1Msec(100);
	while(!eyeL&-SensorValue[gyro]>approx*15)//eyehits line)		//turn left
	{
		motor[backLeft]=motor[frontLeft]=-power;
		motor[backRight]=motor[frontRight]=power;
	}
	if(eyeL)
	{
		motor[backLeft]=motor[frontLeft]=15;
		motor[backRight]=motor[frontRight]=-15;
		wait1Msec(100);
		motor[backLeft]=motor[frontLeft]=0;
		motor[backRight]=motor[frontRight]=0;//brief break
		nMotorEncoder[backLeft]=nMotorEncoder[backRight]=0;
		degturned=SensorValue(gyro);//read gyro
	}
	else if(!eyeL&-SensorValue[gyro]<=approx*15)
	{
		while(!eyeL&-SensorValue[gyro]<approx*5)//eyehits line)		//turn left
		{
			motor[backLeft]=motor[frontLeft]=power;
			motor[backRight]=motor[frontRight]=-power;
		}
		if(eyeL)
		{
			motor[backLeft]=motor[frontLeft]=-15;
			motor[backRight]=motor[frontRight]=15;
			wait1Msec(100);
			motor[backLeft]=motor[frontLeft]=0;
			motor[backRight]=motor[frontRight]=0;//brief break
			nMotorEncoder[backLeft]=nMotorEncoder[backRight]=0;
			degturned=SensorValue(gyro);//read gyro
		}
	}
	SensorValue[solBreak]=0;
//	forwardLine(power,howfar);//calc corrected distance



}
int forwardLine(int power,int howfar,int lastinput)//howfar uses encoder
{
	float ITerm;
	int error;
	//int lastInput;
	const float outMax=128,outMin=-128;
	nMotorEncoder[backLeft]=nMotorEncoder[backRight]=0;
	clearTimer(T3);
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=power;
	//	motor[frontLeft]=motor[frontRight]=power;
	while((nMotorEncoder[backLeft]+nMotorEncoder[backRight])/2<howfar)
	{
		//motor[frontLeft]=power-lfc;//don't forget the back wheels
		//	motor[frontRight]=power+lfc;

		motor[frontLeft]=motor[backLeft]=power-lfc;//don't forget the back wheels
		motor[frontRight]=motor[backRight]=power+lfc;
		long SampleTime=10;
		if(!eyeL&eyeM&!eyeR)//on track, clear stuff
		{
			ITerm=0;
			lfc=0;//line follower correction zero
		}
		else if(!(!eyeL&eyeM&!eyeR)&time1[T3]>=SampleTime)//off track, then react. sample time minaly for motor reaction delay
		{
			static float input;
			if(!eyeL&!eyeM&!eyeR&(lastInput==-4|lastInput==-8))//to much too the right
				input = -8;
			if(eyeL&!eyeM&!eyeR)//to much too the right
				input = -4;//give a negative
			if(eyeL&eyeM&!eyeR)
				input = -1;
			if(!eyeL&eyeM&!eyeR)//
				input = 0;//perfect
			if(eyeL&eyeM&eyeR)//
				input = 0;//horizontal line
			if(!eyeL&eyeM&eyeR)
				input = 1;
			if(!eyeL&!eyeM&eyeR)
				input = 4;
			if(!eyeL&!eyeM&!eyeR&(lastInput==4|lastInput==8))
				input = 8;


			error = - input;

			ITerm+= kil * error;//should be the longer time refreshes, the better
			if(ITerm > outMax) ITerm= outMax;
			else if(ITerm < outMin) ITerm= outMin;
			//		float dInput = (input - lastInput)/timeChange;
			/*Compute PID Output*/
			float dInput=0;
			float output = kpl * error + ITerm - kdl * dInput;
			if(output > outMax) output = outMax;
			else if(output < outMin) output = outMin;
			lfc= output;
			lastInput = input;
			clearTimer(T3);
		}
	}
	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
	return lastinput;
//	motor[frontLeft]=motor[frontRight]=motor[backLeft]=motor[backRight]=0;
}

void securedDump()
{
	//int gyromov;
	//	SensorValue[gyro]=0;
	kMaxPos=2900;
	joystick=128;
	while(SensorValue[armPotentiometerL]<2800);
	forward(128,350);
	motor[roller]=-128;
	wait1Msec(2000);
	backward(128,300);
	motor[roller]=0;
	while(SensorValue[armPotentiometerL]>1400){
		joystick=-128;}
	//	gyromov=SensorValue[gyro]/10;
	//turn(40,gyromov);

}



void breakDrive()
{
	int speed;
	nMotorEncoder[backLeft]=0;
	wait1Msec(10);
	int initspeed=nMotorEncoder[backLeft];
	int power=-initspeed*1000;
	speed=initspeed;
	motor[frontRight] =	motor[backRight] =motor[frontLeft] =motor[backLeft] = power;
	clearTimer(T4);
	while(abs(speed)>1)
	{
		speed=nMotorEncoder[backLeft];
		wait1Msec(20);
		nMotorEncoder[backLeft]=0;
		if(((speed<=0) & (initspeed>0))|((speed>=0) & (initspeed<0)))
		{
			motor[frontRight] =	motor[backRight] =motor[frontLeft] =motor[backLeft] = 0;
			break;
		}
		if(time1[T4]>300)
			break;
	}
	motor[frontRight] =	motor[backRight] =motor[frontLeft] =motor[backLeft] = 0;
}


void breakDrivet()
{
	int speedl,speedr,initg;
	initg=SensorValue[gyro];
	wait1Msec(20);
	int initspeedl=SensorValue[gyro]-initg;
	int initspeedr=initg-SensorValue[gyro];//left neg
	int powerl=initspeedl*1000;
	int powerr=initspeedr*1000;
	speedr=initspeedr;
	speedl=initspeedl;
	motor[frontRight] =	motor[backRight] = powerr;
	motor[frontLeft] =motor[backLeft] =powerl;
	clearTimer(T3);
	while((abs(speedl)>1|abs(speedr)>1)&time1[T3]<300)
	{
		initg=SensorValue[gyro];
		wait1Msec(20);
		speedl=SensorValue[gyro]-initg;
		speedr=initg-SensorValue[gyro];//left neg
		if(((speedl<=0) & (initspeedl>0))|((speedl>=0) & (initspeedl<0)))
		{
			motor[frontLeft] =motor[backLeft] = 0;
		}
		if(((speedr<=0) & (initspeedr>0))|((speedr>=0) & (initspeedr<0)))
		{
			motor[frontRight] =	motor[backRight]=0;
		}

	}
	motor[frontRight] =	motor[backRight] =motor[frontLeft] =motor[backLeft] = 0;
}
void breakDrivesideL()
{

	int speedl;
	nMotorEncoder[backLeft]=0;
	wait1Msec(10);
	int initspeedl=nMotorEncoder[backLeft];
	int powerl=-initspeedl*1000;
	speedl=initspeedl;
	motor[frontLeft] =motor[backLeft] =powerl;
	clearTimer(T3);
	while(abs(speedl)>1)
	{
		speedl=nMotorEncoder[backLeft];
		wait1Msec(20);
		nMotorEncoder[backLeft]=0;
		if(((speedl<=0) & (initspeedl>0))|((speedl>=0) & (initspeedl<0)))
		{
			motor[frontLeft] =motor[backLeft] = 0;
		}
		if(time1[T3]>300)
			break;
	}
	if((speedl<=0&initspeedl>0)|(speedl>=0&initspeedl<0))
		motor[frontLeft] =motor[backLeft] = 0;


}

void breakDrivesideR()
{

	int speedr;
	nMotorEncoder[backRight]=0;
	wait1Msec(10);
	int initspeedr=nMotorEncoder[backRight];
	int powerr=-initspeedr*1000;
	speedr=initspeedr;
	motor[frontRight] =motor[backRight] =powerr;
	clearTimer(T3);
	while(abs(speedr)>1)
	{
		speedr=nMotorEncoder[backRight];
		wait1Msec(20);
		nMotorEncoder[backRight]=0;
		if(((speedr<=0) & (initspeedr>0))|((speedr>=0) & (initspeedr<0)))
		{
			motor[frontRight] =motor[backRight] = 0;
		}
		if(time1[T3]>300)
			break;
	}
	if((speedr<=0&initspeedr>0)|(speedr>=0&initspeedr<0))
		motor[frontRight] =motor[backRight] = 0;
}

task visualMem()//auton only
{
	while(true)
	{
		if(memEn)
		{
			if(eyeL)
				eyeLm=true;
			if(eyeM)
				eyeMm=true;
			if(eyeR)
				eyeRm=true;
			if(eyeB)
				eyeBm=true;
		}
		else
			eyeLm=eyeRm=eyeMm=eyeBm=false;

	}
}

void turnIEC(int power,int degrees)
{
	bool booml=false,boomr=false,leftgood=false,rightgood=false;//break-ed
	int howfar=(int)degrees*2.7;
	if(howfar<=0)
	{
		nMotorEncoder[backRight] = 0;
		nMotorEncoder[backLeft] = 0;
		while(!leftgood | !rightgood)
		{
			if(nMotorEncoder[backRight] < -howfar&(!boomr) ){
				motor[backRight] = power;
				motor[frontRight] = power;}
			else if(nMotorEncoder[backRight] >howfar &(!boomr))
			{
				breakDrivesideR();
				boomr=true;
			}
			else if(boomr)
			{
				motor[backRight] = 	motor[frontRight] = 0;
				rightgood=true;
			}
			if(nMotorEncoder[backLeft] > howfar&(!booml) )
			{
				motor[backLeft] = -power;
				motor[frontLeft] = -power;
			}
			else if(nMotorEncoder[backLeft] < -howfar&(!booml))
			{
				breakDrivesideL();
				booml=true;
			}
			else if(booml)
			{
				motor[backLeft] = 	motor[frontLeft] = 0;
				leftgood=true;
			}
		}
	}
	else if(howfar>=0)
	{
		nMotorEncoder[backRight] = 0;
		nMotorEncoder[backLeft] = 0;
		while(!leftgood | !rightgood)
		{
			if(nMotorEncoder[backLeft] >- howfar&(!booml) ){
				motor[backLeft] = power;
				motor[frontLeft] = power;}
			else if(nMotorEncoder[backLeft] <-howfar &(!booml))
			{
				breakDrivesideL();
				booml=true;
			}
			else if(booml)
			{
				motor[backLeft] = 	motor[frontLeft] = 0;
				leftgood=true;
			}
			if(nMotorEncoder[backRight] <howfar&(!boomr) )
			{
				motor[backRight] = -power;
				motor[frontRight] = -power;
			}
			else if(nMotorEncoder[backRight] >howfar&(!boomr))
			{
				breakDrivesideR();
				boomr=true;
			}
			else if(boomr)
			{
				motor[backRight] = 	motor[frontRight] = 0;
				rightgood=true;
			}

		}
	}

}

void gyrocali()//gyro calibration
{
	SensorValue[gyro]=0;
	displayLCDString(0,0,"turn -90");
	while(nLCDButtons!=kButtonCenter)
	{
		displayLCDPos(0,9);
		displayNextLCDNumber(SensorValue[gyro]);
		wait1Msec(100);
	}
	gyrocorrection=SensorValue[gyro]-900;
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDString(0,0,"Gyro Good");
	displayLCDPos(0,10);
	displayNextLCDNumber(gyrocorrection,5);
	while(LCD_mid);
	clearLCDLine(0);
	clearLCDLine(1);
}

void encodercali()
{
	bool redo=true;
	while(redo)
	{
		redo=false;
		int samplel1,samplel2;
		int sampler1,sampler2;
		nMotorEncoder[backLeft]=nMotorEncoder[backRight]=0;
		displayLCDCenteredString(0,"testing....");

		wait1Msec(300);
		samplel1=nMotorEncoder[backLeft];
		sampler1=nMotorEncoder[backRight];

		wait1Msec(300);
		samplel2=nMotorEncoder[backLeft];
		sampler2=nMotorEncoder[backRight];

		motor[backLeft]=motor[backRight]=0;
		wait1Msec(50);

		if(samplel1!=0|samplel2!=0)
		{
			displayLCDPos(0,0);
			displayNextLCDString("LL Good");
		}
		else
		{
			displayLCDPos(0,0);
			displayNextLCDString("LL BAD");
			redo=true;
		}

		if(sampler1!=0|sampler2!=0)
		{
			displayLCDPos(0,8);
			displayNextLCDString("RR Good");
		}
		else
		{
			displayLCDPos(0,8);
			displayNextLCDString("RR BAD");
			redo=true;
		}

		while(nLCDButtons==kButtonNone)
		{
			displayLCDPos(1,5);
			displayNextLCDString("redo  skip ");
		}
		if(nLCDButtons==kButtonRight)
		{
			redo=false;
			while(nLCDButtons==kButtonRight);
		}

		else if(nLCDButtons==kButtonCenter)
		{
			redo=true;
			clearLCDLine(0);
			clearLCDLine(1);
			displayLCDPos(0,0);
			displayNextLCDString("reboot encoders");
			displayLCDPos(1,0);
			displayNextLCDString("......");
			//			resetMotorEncoder(backRight);
			//			resetMotorEncoder(backLeft);
			SensorType[I2C_1]=sensorNone;
			SensorType[I2C_2]=sensorNone;
			wait1Msec(400);
			SensorType[I2C_1]=sensorQuadEncoderOnI2CPort;
			SensorType[I2C_2]=sensorQuadEncoderOnI2CPort;

		}

	}
}

task tune()
{
	int val=0;
	string value;
	while(true)
	{
		switch (val)
		{
		case 0:
			displayLCDPos(0,0); displayNextLCDString("Kppp=");break;
		case 1:
			displayLCDPos(0,0); displayNextLCDString("Kiii=");break;
		case 2:
			displayLCDPos(0,0); displayNextLCDString("Kddd=");break;
		}

		while(!(SensorValue[GOL]|SensorValue[GOR]))
		{
			SensorValue[prgenc]=0;
			wait1Msec(50);
			switch (val)
			{
			case 0:
				kpf+=(float)(SensorValue[prgenc]/10000.0);
				if(kpf<0)
					kpf=0;
				sprintf(value, "%1.4f%c", kpf);
				break;
			case 1:
				kif+=(float)(SensorValue[prgenc]/10000.0);
				if(kif<0)
					kif=0;
				sprintf(value, "%1.4f%c", kif);
				break;
			case 2:
				kdf+=(float)(SensorValue[prgenc]/10000.0);
				if(kdf<0)
					kdf=0;
				sprintf(value, "%1.4f%c", kdf);
				break;
			}
			displayLCDString(0,5,value);
		}
		while(SensorValue[GOL]){}
		val++;
		if(val>=3)
			val=0;
	}
}
